"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun lineread () (shen.lineread-loop (read-byte (stinput)) ()))

(defun shen.lineread-loop (V1300 V1301) (cond ((= V1300 (shen.hat)) (simple-error "line read aborted")) ((element? V1300 (cons (shen.newline) (cons (shen.carriage-return) ()))) (let Line (compile shen.<st_input> V1301 (lambda E shen.nextline)) (if (or (= Line shen.nextline) (empty? Line)) (shen.lineread-loop (read-byte (stinput)) (append V1301 (cons V1300 ()))) Line))) (true (shen.lineread-loop (read-byte (stinput)) (append V1301 (cons V1300 ()))))))

(defun read-file (V1302) (let Bytelist (read-file-as-bytelist V1302) (compile shen.<st_input> Bytelist shen.read-error)))

(defun shen.read-error (V1309) (cond ((and (cons? V1309) (and (cons? (hd V1309)) (and (cons? (tl V1309)) (= () (tl (tl V1309)))))) (simple-error (cn "read error here:

 " (shen.app (shen.compress-50 50 (hd V1309)) "
" shen.a)))) (true (simple-error "read error
"))))

(defun shen.compress-50 (V1314 V1315) (cond ((= () V1315) "") ((= 0 V1314) "") ((cons? V1315) (cn (n->string (hd V1315)) (shen.compress-50 (- V1314 1) (tl V1315)))) (true (shen.sys-error shen.compress-50))))

(defun shen.<st_input> (V1320) (let Result (let Parse_shen.<lsb> (shen.<lsb> V1320) (if (not (= (fail) Parse_shen.<lsb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lsb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rsb> (shen.<rsb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rsb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rsb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (cons (macroexpand (shen.cons_form (shen.hdtl Parse_shen.<st_input1>))) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<lrb> (shen.<lrb> V1320) (if (not (= (fail) Parse_shen.<lrb>)) (let Parse_shen.<st_input1> (shen.<st_input1> Parse_shen.<lrb>) (if (not (= (fail) Parse_shen.<st_input1>)) (let Parse_shen.<rrb> (shen.<rrb> Parse_shen.<st_input1>) (if (not (= (fail) Parse_shen.<rrb>)) (let Parse_shen.<st_input2> (shen.<st_input2> Parse_shen.<rrb>) (if (not (= (fail) Parse_shen.<st_input2>)) (shen.pair (hd Parse_shen.<st_input2>) (shen.package-macro (macroexpand (shen.hdtl Parse_shen.<st_input1>)) (shen.hdtl Parse_shen.<st_input2>))) (fail))) (fail))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<lcurly> (shen.<lcurly> V1320) (if (not (= (fail) Parse_shen.<lcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<lcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons { (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<rcurly> (shen.<rcurly> V1320) (if (not (= (fail) Parse_shen.<rcurly>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<rcurly>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons } (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<bar> (shen.<bar> V1320) (if (not (= (fail) Parse_shen.<bar>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<bar>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons bar! (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<semicolon> (shen.<semicolon> V1320) (if (not (= (fail) Parse_shen.<semicolon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<semicolon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons ; (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<colon> (shen.<colon> V1320) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<equal> (shen.<equal> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<equal>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<equal>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons := (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<colon> (shen.<colon> V1320) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<minus> (shen.<minus> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons :- (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<colon> (shen.<colon> V1320) (if (not (= (fail) Parse_shen.<colon>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<colon>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons : (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<comma> (shen.<comma> V1320) (if (not (= (fail) Parse_shen.<comma>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comma>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (intern ",") (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<comment> (shen.<comment> V1320) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<atom> (shen.<atom> V1320) (if (not (= (fail) Parse_shen.<atom>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<atom>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (cons (macroexpand (shen.hdtl Parse_shen.<atom>)) (shen.hdtl Parse_shen.<st_input>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<whitespaces> (shen.<whitespaces> V1320) (if (not (= (fail) Parse_shen.<whitespaces>)) (let Parse_shen.<st_input> (shen.<st_input> Parse_shen.<whitespaces>) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V1320) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) (if (= Result (fail)) (fail) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)) Result)))

(defun shen.<lsb> (V1325) (let Result (if (and (cons? (hd V1325)) (= 91 (hd (hd V1325)))) (shen.pair (hd (shen.pair (tl (hd V1325)) (shen.hdtl V1325))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<rsb> (V1330) (let Result (if (and (cons? (hd V1330)) (= 93 (hd (hd V1330)))) (shen.pair (hd (shen.pair (tl (hd V1330)) (shen.hdtl V1330))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<lcurly> (V1335) (let Result (if (and (cons? (hd V1335)) (= 123 (hd (hd V1335)))) (shen.pair (hd (shen.pair (tl (hd V1335)) (shen.hdtl V1335))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<rcurly> (V1340) (let Result (if (and (cons? (hd V1340)) (= 125 (hd (hd V1340)))) (shen.pair (hd (shen.pair (tl (hd V1340)) (shen.hdtl V1340))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<bar> (V1345) (let Result (if (and (cons? (hd V1345)) (= 124 (hd (hd V1345)))) (shen.pair (hd (shen.pair (tl (hd V1345)) (shen.hdtl V1345))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<semicolon> (V1350) (let Result (if (and (cons? (hd V1350)) (= 59 (hd (hd V1350)))) (shen.pair (hd (shen.pair (tl (hd V1350)) (shen.hdtl V1350))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<colon> (V1355) (let Result (if (and (cons? (hd V1355)) (= 58 (hd (hd V1355)))) (shen.pair (hd (shen.pair (tl (hd V1355)) (shen.hdtl V1355))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<comma> (V1360) (let Result (if (and (cons? (hd V1360)) (= 44 (hd (hd V1360)))) (shen.pair (hd (shen.pair (tl (hd V1360)) (shen.hdtl V1360))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<equal> (V1365) (let Result (if (and (cons? (hd V1365)) (= 61 (hd (hd V1365)))) (shen.pair (hd (shen.pair (tl (hd V1365)) (shen.hdtl V1365))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<minus> (V1370) (let Result (if (and (cons? (hd V1370)) (= 45 (hd (hd V1370)))) (shen.pair (hd (shen.pair (tl (hd V1370)) (shen.hdtl V1370))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<lrb> (V1375) (let Result (if (and (cons? (hd V1375)) (= 40 (hd (hd V1375)))) (shen.pair (hd (shen.pair (tl (hd V1375)) (shen.hdtl V1375))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<rrb> (V1380) (let Result (if (and (cons? (hd V1380)) (= 41 (hd (hd V1380)))) (shen.pair (hd (shen.pair (tl (hd V1380)) (shen.hdtl V1380))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<atom> (V1385) (let Result (let Parse_shen.<str> (shen.<str> V1385) (if (not (= (fail) Parse_shen.<str>)) (shen.pair (hd Parse_shen.<str>) (shen.control-chars (shen.hdtl Parse_shen.<str>))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<number> (shen.<number> V1385) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<sym> (shen.<sym> V1385) (if (not (= (fail) Parse_shen.<sym>)) (shen.pair (hd Parse_shen.<sym>) (if (= (shen.hdtl Parse_shen.<sym>) "<>") (cons vector (cons 0 ())) (intern (shen.hdtl Parse_shen.<sym>)))) (fail))) (if (= Result (fail)) (fail) Result)) Result)) Result)))

(defun shen.control-chars (V1386) (cond ((= () V1386) "") ((and (cons? V1386) (and (= "c" (hd V1386)) (and (cons? (tl V1386)) (= "#" (hd (tl V1386)))))) (let CodePoint (shen.code-point (tl (tl V1386))) (let AfterCodePoint (shen.after-codepoint (tl (tl V1386))) (@s (n->string (shen.decimalise CodePoint)) (shen.control-chars AfterCodePoint))))) ((cons? V1386) (@s (hd V1386) (shen.control-chars (tl V1386)))) (true (shen.sys-error shen.control-chars))))

(defun shen.code-point (V1389) (cond ((and (cons? V1389) (= ";" (hd V1389))) "") ((and (cons? V1389) (element? (hd V1389) (cons "0" (cons "1" (cons "2" (cons "3" (cons "4" (cons "5" (cons "6" (cons "7" (cons "8" (cons "9" (cons "0" ()))))))))))))) (cons (hd V1389) (shen.code-point (tl V1389)))) (true (simple-error (cn "code point parse error " (shen.app V1389 "
" shen.a))))))

(defun shen.after-codepoint (V1394) (cond ((= () V1394) ()) ((and (cons? V1394) (= ";" (hd V1394))) (tl V1394)) ((cons? V1394) (shen.after-codepoint (tl V1394))) (true (shen.sys-error shen.after-codepoint))))

(defun shen.decimalise (V1395) (shen.pre (reverse (shen.digits->integers V1395)) 0))

(defun shen.digits->integers (V1400) (cond ((and (cons? V1400) (= "0" (hd V1400))) (cons 0 (shen.digits->integers (tl V1400)))) ((and (cons? V1400) (= "1" (hd V1400))) (cons 1 (shen.digits->integers (tl V1400)))) ((and (cons? V1400) (= "2" (hd V1400))) (cons 2 (shen.digits->integers (tl V1400)))) ((and (cons? V1400) (= "3" (hd V1400))) (cons 3 (shen.digits->integers (tl V1400)))) ((and (cons? V1400) (= "4" (hd V1400))) (cons 4 (shen.digits->integers (tl V1400)))) ((and (cons? V1400) (= "5" (hd V1400))) (cons 5 (shen.digits->integers (tl V1400)))) ((and (cons? V1400) (= "6" (hd V1400))) (cons 6 (shen.digits->integers (tl V1400)))) ((and (cons? V1400) (= "7" (hd V1400))) (cons 7 (shen.digits->integers (tl V1400)))) ((and (cons? V1400) (= "8" (hd V1400))) (cons 8 (shen.digits->integers (tl V1400)))) ((and (cons? V1400) (= "9" (hd V1400))) (cons 9 (shen.digits->integers (tl V1400)))) (true ())))

(defun shen.<sym> (V1405) (let Result (let Parse_shen.<alpha> (shen.<alpha> V1405) (if (not (= (fail) Parse_shen.<alpha>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alpha>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<alphanums> (V1410) (let Result (let Parse_shen.<alphanum> (shen.<alphanum> V1410) (if (not (= (fail) Parse_shen.<alphanum>)) (let Parse_shen.<alphanums> (shen.<alphanums> Parse_shen.<alphanum>) (if (not (= (fail) Parse_shen.<alphanums>)) (shen.pair (hd Parse_shen.<alphanums>) (@s (shen.hdtl Parse_shen.<alphanum>) (shen.hdtl Parse_shen.<alphanums>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V1410) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) "") (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<alphanum> (V1415) (let Result (let Parse_shen.<alpha> (shen.<alpha> V1415) (if (not (= (fail) Parse_shen.<alpha>)) (shen.pair (hd Parse_shen.<alpha>) (shen.hdtl Parse_shen.<alpha>)) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<num> (shen.<num> V1415) (if (not (= (fail) Parse_shen.<num>)) (shen.pair (hd Parse_shen.<num>) (shen.hdtl Parse_shen.<num>)) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<num> (V1420) (let Result (if (cons? (hd V1420)) (let Parse_Byte (hd (hd V1420)) (if (shen.numbyte? Parse_Byte) (shen.pair (hd (shen.pair (tl (hd V1420)) (shen.hdtl V1420))) (n->string Parse_Byte)) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.numbyte? (V1425) (cond ((= 48 V1425) true) ((= 49 V1425) true) ((= 50 V1425) true) ((= 51 V1425) true) ((= 52 V1425) true) ((= 53 V1425) true) ((= 54 V1425) true) ((= 55 V1425) true) ((= 56 V1425) true) ((= 57 V1425) true) (true false)))

(defun shen.<alpha> (V1430) (let Result (if (cons? (hd V1430)) (let Parse_Byte (hd (hd V1430)) (if (shen.symbol-code? Parse_Byte) (shen.pair (hd (shen.pair (tl (hd V1430)) (shen.hdtl V1430))) (n->string Parse_Byte)) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.symbol-code? (V1431) (or (= V1431 126) (or (and (> V1431 94) (< V1431 123)) (or (and (> V1431 59) (< V1431 91)) (or (and (> V1431 41) (and (< V1431 58) (not (= V1431 44)))) (or (and (> V1431 34) (< V1431 40)) (= V1431 33)))))))

(defun shen.<str> (V1436) (let Result (let Parse_shen.<dbq> (shen.<dbq> V1436) (if (not (= (fail) Parse_shen.<dbq>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<dbq>) (if (not (= (fail) Parse_shen.<strcontents>)) (let Parse_shen.<dbq> (shen.<dbq> Parse_shen.<strcontents>) (if (not (= (fail) Parse_shen.<dbq>)) (shen.pair (hd Parse_shen.<dbq>) (shen.hdtl Parse_shen.<strcontents>)) (fail))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<dbq> (V1441) (let Result (if (cons? (hd V1441)) (let Parse_Byte (hd (hd V1441)) (if (= Parse_Byte 34) (shen.pair (hd (shen.pair (tl (hd V1441)) (shen.hdtl V1441))) Parse_Byte) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<strcontents> (V1446) (let Result (let Parse_shen.<strc> (shen.<strc> V1446) (if (not (= (fail) Parse_shen.<strc>)) (let Parse_shen.<strcontents> (shen.<strcontents> Parse_shen.<strc>) (if (not (= (fail) Parse_shen.<strcontents>)) (shen.pair (hd Parse_shen.<strcontents>) (cons (shen.hdtl Parse_shen.<strc>) (shen.hdtl Parse_shen.<strcontents>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V1446) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<byte> (V1451) (let Result (if (cons? (hd V1451)) (let Parse_Byte (hd (hd V1451)) (shen.pair (hd (shen.pair (tl (hd V1451)) (shen.hdtl V1451))) (n->string Parse_Byte))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<strc> (V1456) (let Result (if (cons? (hd V1456)) (let Parse_Byte (hd (hd V1456)) (if (not (= Parse_Byte 34)) (shen.pair (hd (shen.pair (tl (hd V1456)) (shen.hdtl V1456))) (n->string Parse_Byte)) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<backslash> (V1461) (let Result (if (cons? (hd V1461)) (let Parse_Byte (hd (hd V1461)) (if (= Parse_Byte 92) (shen.pair (hd (shen.pair (tl (hd V1461)) (shen.hdtl V1461))) (n->string Parse_Byte)) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<number> (V1466) (let Result (let Parse_shen.<minus> (shen.<minus> V1466) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (- 0 (shen.hdtl Parse_shen.<number>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<plus> (shen.<plus> V1466) (if (not (= (fail) Parse_shen.<plus>)) (let Parse_shen.<number> (shen.<number> Parse_shen.<plus>) (if (not (= (fail) Parse_shen.<number>)) (shen.pair (hd Parse_shen.<number>) (shen.hdtl Parse_shen.<number>)) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<predigits> (shen.<predigits> V1466) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<postdigits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1)))) (fail))) (fail))) (fail))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<digits> (shen.<digits> V1466) (if (not (= (fail) Parse_shen.<digits>)) (let Parse_shen.<E> (shen.<E> Parse_shen.<digits>) (if (not (= (fail) Parse_shen.<E>)) (let Parse_shen.<log10> (shen.<log10> Parse_shen.<E>) (if (not (= (fail) Parse_shen.<log10>)) (shen.pair (hd Parse_shen.<log10>) (* (shen.expt 10 (shen.hdtl Parse_shen.<log10>)) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<predigits> (shen.<predigits> V1466) (if (not (= (fail) Parse_shen.<predigits>)) (let Parse_shen.<stop> (shen.<stop> Parse_shen.<predigits>) (if (not (= (fail) Parse_shen.<stop>)) (let Parse_shen.<postdigits> (shen.<postdigits> Parse_shen.<stop>) (if (not (= (fail) Parse_shen.<postdigits>)) (shen.pair (hd Parse_shen.<postdigits>) (+ (shen.pre (reverse (shen.hdtl Parse_shen.<predigits>)) 0) (shen.post (shen.hdtl Parse_shen.<postdigits>) 1))) (fail))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<digits> (shen.<digits> V1466) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) (if (= Result (fail)) (fail) Result)) Result)) Result)) Result)) Result)) Result)))

(defun shen.<E> (V1471) (let Result (if (and (cons? (hd V1471)) (= 101 (hd (hd V1471)))) (shen.pair (hd (shen.pair (tl (hd V1471)) (shen.hdtl V1471))) shen.skip) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<log10> (V1476) (let Result (let Parse_shen.<minus> (shen.<minus> V1476) (if (not (= (fail) Parse_shen.<minus>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<minus>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (- 0 (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<digits> (shen.<digits> V1476) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.pre (reverse (shen.hdtl Parse_shen.<digits>)) 0)) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<plus> (V1481) (let Result (if (cons? (hd V1481)) (let Parse_Byte (hd (hd V1481)) (if (= Parse_Byte 43) (shen.pair (hd (shen.pair (tl (hd V1481)) (shen.hdtl V1481))) Parse_Byte) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<stop> (V1486) (let Result (if (cons? (hd V1486)) (let Parse_Byte (hd (hd V1486)) (if (= Parse_Byte 46) (shen.pair (hd (shen.pair (tl (hd V1486)) (shen.hdtl V1486))) Parse_Byte) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<predigits> (V1491) (let Result (let Parse_shen.<digits> (shen.<digits> V1491) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V1491) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<postdigits> (V1496) (let Result (let Parse_shen.<digits> (shen.<digits> V1496) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (shen.hdtl Parse_shen.<digits>)) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<digits> (V1501) (let Result (let Parse_shen.<digit> (shen.<digit> V1501) (if (not (= (fail) Parse_shen.<digit>)) (let Parse_shen.<digits> (shen.<digits> Parse_shen.<digit>) (if (not (= (fail) Parse_shen.<digits>)) (shen.pair (hd Parse_shen.<digits>) (cons (shen.hdtl Parse_shen.<digit>) (shen.hdtl Parse_shen.<digits>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<digit> (shen.<digit> V1501) (if (not (= (fail) Parse_shen.<digit>)) (shen.pair (hd Parse_shen.<digit>) (cons (shen.hdtl Parse_shen.<digit>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<digit> (V1506) (let Result (if (cons? (hd V1506)) (let Parse_X (hd (hd V1506)) (if (shen.numbyte? Parse_X) (shen.pair (hd (shen.pair (tl (hd V1506)) (shen.hdtl V1506))) (shen.byte->digit Parse_X)) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.byte->digit (V1507) (cond ((= 48 V1507) 0) ((= 49 V1507) 1) ((= 50 V1507) 2) ((= 51 V1507) 3) ((= 52 V1507) 4) ((= 53 V1507) 5) ((= 54 V1507) 6) ((= 55 V1507) 7) ((= 56 V1507) 8) ((= 57 V1507) 9) (true (shen.sys-error shen.byte->digit))))

(defun shen.pre (V1510 V1511) (cond ((= () V1510) 0) ((cons? V1510) (+ (* (shen.expt 10 V1511) (hd V1510)) (shen.pre (tl V1510) (+ V1511 1)))) (true (shen.sys-error shen.pre))))

(defun shen.post (V1514 V1515) (cond ((= () V1514) 0) ((cons? V1514) (+ (* (shen.expt 10 (- 0 V1515)) (hd V1514)) (shen.post (tl V1514) (+ V1515 1)))) (true (shen.sys-error shen.post))))

(defun shen.expt (V1518 V1519) (cond ((= 0 V1519) 1) ((> V1519 0) (* V1518 (shen.expt V1518 (- V1519 1)))) (true (* 1 (/ (shen.expt V1518 (+ V1519 1)) V1518)))))

(defun shen.<st_input1> (V1524) (let Result (let Parse_shen.<st_input> (shen.<st_input> V1524) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<st_input2> (V1529) (let Result (let Parse_shen.<st_input> (shen.<st_input> V1529) (if (not (= (fail) Parse_shen.<st_input>)) (shen.pair (hd Parse_shen.<st_input>) (shen.hdtl Parse_shen.<st_input>)) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<comment> (V1534) (let Result (let Parse_shen.<backslash> (shen.<backslash> V1534) (if (not (= (fail) Parse_shen.<backslash>)) (let Parse_shen.<times> (shen.<times> Parse_shen.<backslash>) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<any> (shen.<any> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<any>)) (let Parse_shen.<times> (shen.<times> Parse_shen.<any>) (if (not (= (fail) Parse_shen.<times>)) (let Parse_shen.<backslash> (shen.<backslash> Parse_shen.<times>) (if (not (= (fail) Parse_shen.<backslash>)) (shen.pair (hd Parse_shen.<backslash>) shen.skip) (fail))) (fail))) (fail))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<times> (V1539) (let Result (if (cons? (hd V1539)) (let Parse_Byte (hd (hd V1539)) (if (= Parse_Byte 42) (shen.pair (hd (shen.pair (tl (hd V1539)) (shen.hdtl V1539))) Parse_Byte) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<any> (V1544) (let Result (let Parse_shen.<comment> (shen.<comment> V1544) (if (not (= (fail) Parse_shen.<comment>)) (let Parse_shen.<any> (shen.<any> Parse_shen.<comment>) (if (not (= (fail) Parse_shen.<any>)) (shen.pair (hd Parse_shen.<any>) shen.skip) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<blah> (shen.<blah> V1544) (if (not (= (fail) Parse_shen.<blah>)) (let Parse_shen.<any> (shen.<any> Parse_shen.<blah>) (if (not (= (fail) Parse_shen.<any>)) (shen.pair (hd Parse_shen.<any>) shen.skip) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V1544) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) shen.skip) (fail))) (if (= Result (fail)) (fail) Result)) Result)) Result)))

(defun shen.<blah> (V1557) (cond ((and (cons? V1557) (and (cons? (hd V1557)) (and (= 42 (hd (hd V1557))) (and (cons? (tl (hd V1557))) (= 92 (hd (tl (hd V1557)))))))) (fail)) ((and (cons? V1557) (and (cons? (hd V1557)) (and (cons? (tl V1557)) (= () (tl (tl V1557)))))) (cons (tl (hd V1557)) (cons shen.skip ()))) (true (fail))))

(defun shen.<whitespaces> (V1562) (let Result (let Parse_shen.<whitespace> (shen.<whitespace> V1562) (if (not (= (fail) Parse_shen.<whitespace>)) (let Parse_shen.<whitespaces> (shen.<whitespaces> Parse_shen.<whitespace>) (if (not (= (fail) Parse_shen.<whitespaces>)) (shen.pair (hd Parse_shen.<whitespaces>) shen.skip) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<whitespace> (shen.<whitespace> V1562) (if (not (= (fail) Parse_shen.<whitespace>)) (shen.pair (hd Parse_shen.<whitespace>) shen.skip) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<whitespace> (V1567) (let Result (if (cons? (hd V1567)) (let Parse_X (hd (hd V1567)) (if (let Parse_Case Parse_X (or (= Parse_Case 32) (or (= Parse_Case 13) (or (= Parse_Case 10) (= Parse_Case 9))))) (shen.pair (hd (shen.pair (tl (hd V1567)) (shen.hdtl V1567))) shen.skip) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.cons_form (V1568) (cond ((= () V1568) ()) ((and (cons? V1568) (and (cons? (tl V1568)) (and (cons? (tl (tl V1568))) (and (= () (tl (tl (tl V1568)))) (= (hd (tl V1568)) bar!))))) (cons cons (cons (hd V1568) (tl (tl V1568))))) ((cons? V1568) (cons cons (cons (hd V1568) (cons (shen.cons_form (tl V1568)) ())))) (true (shen.sys-error shen.cons_form))))

(defun shen.package-macro (V1571 V1572) (cond ((and (cons? V1571) (and (= $ (hd V1571)) (and (cons? (tl V1571)) (= () (tl (tl V1571)))))) (append (explode (hd (tl V1571))) V1572)) ((and (cons? V1571) (and (= package (hd V1571)) (and (cons? (tl V1571)) (and (= null (hd (tl V1571))) (cons? (tl (tl V1571))))))) (append (tl (tl (tl V1571))) V1572)) ((and (cons? V1571) (and (= package (hd V1571)) (and (cons? (tl V1571)) (cons? (tl (tl V1571)))))) (let ListofExceptions (shen.eval-without-macros (hd (tl (tl V1571)))) (let Record (shen.record-exceptions ListofExceptions (hd (tl V1571))) (let PackageNameDot (intern (cn (str (hd (tl V1571))) ".")) (append (shen.packageh PackageNameDot ListofExceptions (tl (tl (tl V1571)))) V1572))))) (true (cons V1571 V1572))))

(defun shen.record-exceptions (V1573 V1574) (let CurrExceptions (trap-error (get V1574 shen.external-symbols (value *property-vector*)) (lambda E ())) (let AllExceptions (union V1573 CurrExceptions) (put V1574 shen.external-symbols AllExceptions (value *property-vector*)))))

(defun shen.packageh (V1583 V1584 V1585) (cond ((cons? V1585) (cons (shen.packageh V1583 V1584 (hd V1585)) (shen.packageh V1583 V1584 (tl V1585)))) ((or (shen.sysfunc? V1585) (or (variable? V1585) (or (element? V1585 V1584) (or (shen.doubleunderline? V1585) (shen.singleunderline? V1585))))) V1585) ((and (symbol? V1585) (not (shen.prefix? (cons "s" (cons "h" (cons "e" (cons "n" (cons "." ()))))) (explode V1585)))) (concat V1583 V1585)) (true V1585)))

(defun read-from-string (V1586) (let Ns (map (lambda V1298 (string->n V1298)) (explode V1586)) (compile shen.<st_input> Ns shen.read-error)))



