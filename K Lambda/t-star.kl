"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.typecheck (V2848 V2849) (let Curry (shen.curry V2848) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V2849)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2850) (cond ((and (cons? V2850) (shen.special? (hd V2850))) (cons (hd V2850) (map shen.curry (tl V2850)))) ((and (cons? V2850) (and (cons? (tl V2850)) (shen.extraspecial? (hd V2850)))) V2850) ((and (cons? V2850) (and (cons? (tl V2850)) (cons? (tl (tl V2850))))) (shen.curry (cons (cons (hd V2850) (cons (hd (tl V2850)) ())) (tl (tl V2850))))) ((and (cons? V2850) (and (cons? (tl V2850)) (= () (tl (tl V2850))))) (cons (shen.curry (hd V2850)) (cons (shen.curry (hd (tl V2850))) ()))) (true V2850)))

(defun shen.special? (V2851) (element? V2851 (value shen.*special*)))

(defun shen.extraspecial? (V2852) (element? V2852 (value shen.*extraspecial*)))

(defun shen.t* (V2853 V2854 V2855 V2856) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2855) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2855 (freeze (bind Error (shen.errormaxinfs) V2855 V2856))))) (if (= Case false) (let Case (let V2842 (shen.lazyderef V2853 V2855) (if (= fail V2842) (do (shen.incinfs) (cut Throwcontrol V2855 (freeze (shen.prolog-failure V2855 V2856)))) false)) (if (= Case false) (let Case (let V2843 (shen.lazyderef V2853 V2855) (if (cons? V2843) (let X (hd V2843) (let V2844 (shen.lazyderef (tl V2843) V2855) (if (cons? V2844) (let V2845 (shen.lazyderef (hd V2844) V2855) (if (= : V2845) (let V2846 (shen.lazyderef (tl V2844) V2855) (if (cons? V2846) (let A (hd V2846) (let V2847 (shen.lazyderef (tl V2846) V2855) (if (= () V2847) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2855 (freeze (cut Throwcontrol V2855 (freeze (shen.th* X A V2854 V2855 V2856)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2855) (do (shen.incinfs) (shen.show V2853 V2854 V2855 (freeze (bind Datatypes (value shen.*datatypes*) V2855 (freeze (shen.udefs* V2853 V2854 Datatypes V2855 V2856))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2861) (cond ((= + V2861) (set shen.*shen-type-theory-enabled?* true)) ((= - V2861) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2870 V2871) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2872 V2873 V2874 V2875 V2876) (let Case (let V2838 (shen.lazyderef V2874 V2875) (if (cons? V2838) (let D (hd V2838) (do (shen.incinfs) (call (cons D (cons V2872 (cons V2873 ()))) V2875 V2876))) false)) (if (= Case false) (let V2839 (shen.lazyderef V2874 V2875) (if (cons? V2839) (let Ds (tl V2839) (do (shen.incinfs) (shen.udefs* V2872 V2873 Ds V2875 V2876))) false)) Case)))

(defun shen.th* (V2877 V2878 V2879 V2880 V2881) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2877 (cons : (cons V2878 ()))) V2879 V2880 (freeze (fwhen false V2880 V2881)))) (if (= Case false) (let Case (let F (shen.newpv V2880) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2877 V2880)) V2880 (freeze (bind F (shen.sigf (shen.lazyderef V2877 V2880)) V2880 (freeze (call (cons F (cons V2878 ())) V2880 V2881))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2877 V2878 V2880 V2881)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2877 V2878 V2879 V2880 V2881)) (if (= Case false) (let Case (let V2717 (shen.lazyderef V2877 V2880) (if (cons? V2717) (let F (hd V2717) (let V2718 (shen.lazyderef (tl V2717) V2880) (if (= () V2718) (do (shen.incinfs) (shen.th* F (cons --> (cons V2878 ())) V2879 V2880 V2881)) false))) false)) (if (= Case false) (let Case (let V2719 (shen.lazyderef V2877 V2880) (if (cons? V2719) (let F (hd V2719) (let V2720 (shen.lazyderef (tl V2719) V2880) (if (cons? V2720) (let X (hd V2720) (let V2721 (shen.lazyderef (tl V2720) V2880) (if (= () V2721) (let B (shen.newpv V2880) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2878 ()))) V2879 V2880 (freeze (shen.th* X B V2879 V2880 V2881))))) false))) false))) false)) (if (= Case false) (let Case (let V2722 (shen.lazyderef V2877 V2880) (if (cons? V2722) (let V2723 (shen.lazyderef (hd V2722) V2880) (if (= cons V2723) (let V2724 (shen.lazyderef (tl V2722) V2880) (if (cons? V2724) (let X (hd V2724) (let V2725 (shen.lazyderef (tl V2724) V2880) (if (cons? V2725) (let Y (hd V2725) (let V2726 (shen.lazyderef (tl V2725) V2880) (if (= () V2726) (let V2727 (shen.lazyderef V2878 V2880) (if (cons? V2727) (let V2728 (shen.lazyderef (hd V2727) V2880) (if (= list V2728) (let V2729 (shen.lazyderef (tl V2727) V2880) (if (cons? V2729) (let A (hd V2729) (let V2730 (shen.lazyderef (tl V2729) V2880) (if (= () V2730) (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y (cons list (cons A ())) V2879 V2880 V2881)))) (if (shen.pvar? V2730) (do (shen.bindv V2730 () V2880) (let Result (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y (cons list (cons A ())) V2879 V2880 V2881)))) (do (shen.unbindv V2730 V2880) Result))) false)))) (if (shen.pvar? V2729) (let A (shen.newpv V2880) (do (shen.bindv V2729 (cons A ()) V2880) (let Result (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y (cons list (cons A ())) V2879 V2880 V2881)))) (do (shen.unbindv V2729 V2880) Result)))) false))) (if (shen.pvar? V2728) (do (shen.bindv V2728 list V2880) (let Result (let V2731 (shen.lazyderef (tl V2727) V2880) (if (cons? V2731) (let A (hd V2731) (let V2732 (shen.lazyderef (tl V2731) V2880) (if (= () V2732) (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y (cons list (cons A ())) V2879 V2880 V2881)))) (if (shen.pvar? V2732) (do (shen.bindv V2732 () V2880) (let Result (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y (cons list (cons A ())) V2879 V2880 V2881)))) (do (shen.unbindv V2732 V2880) Result))) false)))) (if (shen.pvar? V2731) (let A (shen.newpv V2880) (do (shen.bindv V2731 (cons A ()) V2880) (let Result (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y (cons list (cons A ())) V2879 V2880 V2881)))) (do (shen.unbindv V2731 V2880) Result)))) false))) (do (shen.unbindv V2728 V2880) Result))) false))) (if (shen.pvar? V2727) (let A (shen.newpv V2880) (do (shen.bindv V2727 (cons list (cons A ())) V2880) (let Result (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y (cons list (cons A ())) V2879 V2880 V2881)))) (do (shen.unbindv V2727 V2880) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2733 (shen.lazyderef V2877 V2880) (if (cons? V2733) (let V2734 (shen.lazyderef (hd V2733) V2880) (if (= @p V2734) (let V2735 (shen.lazyderef (tl V2733) V2880) (if (cons? V2735) (let X (hd V2735) (let V2736 (shen.lazyderef (tl V2735) V2880) (if (cons? V2736) (let Y (hd V2736) (let V2737 (shen.lazyderef (tl V2736) V2880) (if (= () V2737) (let V2738 (shen.lazyderef V2878 V2880) (if (cons? V2738) (let A (hd V2738) (let V2739 (shen.lazyderef (tl V2738) V2880) (if (cons? V2739) (let V2740 (shen.lazyderef (hd V2739) V2880) (if (= * V2740) (let V2741 (shen.lazyderef (tl V2739) V2880) (if (cons? V2741) (let B (hd V2741) (let V2742 (shen.lazyderef (tl V2741) V2880) (if (= () V2742) (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y B V2879 V2880 V2881)))) (if (shen.pvar? V2742) (do (shen.bindv V2742 () V2880) (let Result (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y B V2879 V2880 V2881)))) (do (shen.unbindv V2742 V2880) Result))) false)))) (if (shen.pvar? V2741) (let B (shen.newpv V2880) (do (shen.bindv V2741 (cons B ()) V2880) (let Result (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y B V2879 V2880 V2881)))) (do (shen.unbindv V2741 V2880) Result)))) false))) (if (shen.pvar? V2740) (do (shen.bindv V2740 * V2880) (let Result (let V2743 (shen.lazyderef (tl V2739) V2880) (if (cons? V2743) (let B (hd V2743) (let V2744 (shen.lazyderef (tl V2743) V2880) (if (= () V2744) (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y B V2879 V2880 V2881)))) (if (shen.pvar? V2744) (do (shen.bindv V2744 () V2880) (let Result (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y B V2879 V2880 V2881)))) (do (shen.unbindv V2744 V2880) Result))) false)))) (if (shen.pvar? V2743) (let B (shen.newpv V2880) (do (shen.bindv V2743 (cons B ()) V2880) (let Result (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y B V2879 V2880 V2881)))) (do (shen.unbindv V2743 V2880) Result)))) false))) (do (shen.unbindv V2740 V2880) Result))) false))) (if (shen.pvar? V2739) (let B (shen.newpv V2880) (do (shen.bindv V2739 (cons * (cons B ())) V2880) (let Result (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y B V2879 V2880 V2881)))) (do (shen.unbindv V2739 V2880) Result)))) false)))) (if (shen.pvar? V2738) (let A (shen.newpv V2880) (let B (shen.newpv V2880) (do (shen.bindv V2738 (cons A (cons * (cons B ()))) V2880) (let Result (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y B V2879 V2880 V2881)))) (do (shen.unbindv V2738 V2880) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2745 (shen.lazyderef V2877 V2880) (if (cons? V2745) (let V2746 (shen.lazyderef (hd V2745) V2880) (if (= @v V2746) (let V2747 (shen.lazyderef (tl V2745) V2880) (if (cons? V2747) (let X (hd V2747) (let V2748 (shen.lazyderef (tl V2747) V2880) (if (cons? V2748) (let Y (hd V2748) (let V2749 (shen.lazyderef (tl V2748) V2880) (if (= () V2749) (let V2750 (shen.lazyderef V2878 V2880) (if (cons? V2750) (let V2751 (shen.lazyderef (hd V2750) V2880) (if (= vector V2751) (let V2752 (shen.lazyderef (tl V2750) V2880) (if (cons? V2752) (let A (hd V2752) (let V2753 (shen.lazyderef (tl V2752) V2880) (if (= () V2753) (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y (cons vector (cons A ())) V2879 V2880 V2881)))) (if (shen.pvar? V2753) (do (shen.bindv V2753 () V2880) (let Result (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y (cons vector (cons A ())) V2879 V2880 V2881)))) (do (shen.unbindv V2753 V2880) Result))) false)))) (if (shen.pvar? V2752) (let A (shen.newpv V2880) (do (shen.bindv V2752 (cons A ()) V2880) (let Result (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y (cons vector (cons A ())) V2879 V2880 V2881)))) (do (shen.unbindv V2752 V2880) Result)))) false))) (if (shen.pvar? V2751) (do (shen.bindv V2751 vector V2880) (let Result (let V2754 (shen.lazyderef (tl V2750) V2880) (if (cons? V2754) (let A (hd V2754) (let V2755 (shen.lazyderef (tl V2754) V2880) (if (= () V2755) (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y (cons vector (cons A ())) V2879 V2880 V2881)))) (if (shen.pvar? V2755) (do (shen.bindv V2755 () V2880) (let Result (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y (cons vector (cons A ())) V2879 V2880 V2881)))) (do (shen.unbindv V2755 V2880) Result))) false)))) (if (shen.pvar? V2754) (let A (shen.newpv V2880) (do (shen.bindv V2754 (cons A ()) V2880) (let Result (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y (cons vector (cons A ())) V2879 V2880 V2881)))) (do (shen.unbindv V2754 V2880) Result)))) false))) (do (shen.unbindv V2751 V2880) Result))) false))) (if (shen.pvar? V2750) (let A (shen.newpv V2880) (do (shen.bindv V2750 (cons vector (cons A ())) V2880) (let Result (do (shen.incinfs) (shen.th* X A V2879 V2880 (freeze (shen.th* Y (cons vector (cons A ())) V2879 V2880 V2881)))) (do (shen.unbindv V2750 V2880) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2756 (shen.lazyderef V2877 V2880) (if (cons? V2756) (let V2757 (shen.lazyderef (hd V2756) V2880) (if (= @s V2757) (let V2758 (shen.lazyderef (tl V2756) V2880) (if (cons? V2758) (let X (hd V2758) (let V2759 (shen.lazyderef (tl V2758) V2880) (if (cons? V2759) (let Y (hd V2759) (let V2760 (shen.lazyderef (tl V2759) V2880) (if (= () V2760) (let V2761 (shen.lazyderef V2878 V2880) (if (= string V2761) (do (shen.incinfs) (shen.th* X string V2879 V2880 (freeze (shen.th* Y string V2879 V2880 V2881)))) (if (shen.pvar? V2761) (do (shen.bindv V2761 string V2880) (let Result (do (shen.incinfs) (shen.th* X string V2879 V2880 (freeze (shen.th* Y string V2879 V2880 V2881)))) (do (shen.unbindv V2761 V2880) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2762 (shen.lazyderef V2877 V2880) (if (cons? V2762) (let V2763 (shen.lazyderef (hd V2762) V2880) (if (= lambda V2763) (let V2764 (shen.lazyderef (tl V2762) V2880) (if (cons? V2764) (let X (hd V2764) (let V2765 (shen.lazyderef (tl V2764) V2880) (if (cons? V2765) (let Y (hd V2765) (let V2766 (shen.lazyderef (tl V2765) V2880) (if (= () V2766) (let V2767 (shen.lazyderef V2878 V2880) (if (cons? V2767) (let A (hd V2767) (let V2768 (shen.lazyderef (tl V2767) V2880) (if (cons? V2768) (let V2769 (shen.lazyderef (hd V2768) V2880) (if (= --> V2769) (let V2770 (shen.lazyderef (tl V2768) V2880) (if (cons? V2770) (let B (hd V2770) (let V2771 (shen.lazyderef (tl V2770) V2880) (if (= () V2771) (let Z (shen.newpv V2880) (let X&& (shen.newpv V2880) (do (shen.incinfs) (cut Throwcontrol V2880 (freeze (bind X&& (shen.placeholder) V2880 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2880) (shen.lazyderef X V2880) (shen.lazyderef Y V2880)) V2880 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2879) V2880 V2881)))))))))) (if (shen.pvar? V2771) (do (shen.bindv V2771 () V2880) (let Result (let Z (shen.newpv V2880) (let X&& (shen.newpv V2880) (do (shen.incinfs) (cut Throwcontrol V2880 (freeze (bind X&& (shen.placeholder) V2880 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2880) (shen.lazyderef X V2880) (shen.lazyderef Y V2880)) V2880 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2879) V2880 V2881)))))))))) (do (shen.unbindv V2771 V2880) Result))) false)))) (if (shen.pvar? V2770) (let B (shen.newpv V2880) (do (shen.bindv V2770 (cons B ()) V2880) (let Result (let Z (shen.newpv V2880) (let X&& (shen.newpv V2880) (do (shen.incinfs) (cut Throwcontrol V2880 (freeze (bind X&& (shen.placeholder) V2880 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2880) (shen.lazyderef X V2880) (shen.lazyderef Y V2880)) V2880 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2879) V2880 V2881)))))))))) (do (shen.unbindv V2770 V2880) Result)))) false))) (if (shen.pvar? V2769) (do (shen.bindv V2769 --> V2880) (let Result (let V2772 (shen.lazyderef (tl V2768) V2880) (if (cons? V2772) (let B (hd V2772) (let V2773 (shen.lazyderef (tl V2772) V2880) (if (= () V2773) (let Z (shen.newpv V2880) (let X&& (shen.newpv V2880) (do (shen.incinfs) (cut Throwcontrol V2880 (freeze (bind X&& (shen.placeholder) V2880 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2880) (shen.lazyderef X V2880) (shen.lazyderef Y V2880)) V2880 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2879) V2880 V2881)))))))))) (if (shen.pvar? V2773) (do (shen.bindv V2773 () V2880) (let Result (let Z (shen.newpv V2880) (let X&& (shen.newpv V2880) (do (shen.incinfs) (cut Throwcontrol V2880 (freeze (bind X&& (shen.placeholder) V2880 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2880) (shen.lazyderef X V2880) (shen.lazyderef Y V2880)) V2880 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2879) V2880 V2881)))))))))) (do (shen.unbindv V2773 V2880) Result))) false)))) (if (shen.pvar? V2772) (let B (shen.newpv V2880) (do (shen.bindv V2772 (cons B ()) V2880) (let Result (let Z (shen.newpv V2880) (let X&& (shen.newpv V2880) (do (shen.incinfs) (cut Throwcontrol V2880 (freeze (bind X&& (shen.placeholder) V2880 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2880) (shen.lazyderef X V2880) (shen.lazyderef Y V2880)) V2880 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2879) V2880 V2881)))))))))) (do (shen.unbindv V2772 V2880) Result)))) false))) (do (shen.unbindv V2769 V2880) Result))) false))) (if (shen.pvar? V2768) (let B (shen.newpv V2880) (do (shen.bindv V2768 (cons --> (cons B ())) V2880) (let Result (let Z (shen.newpv V2880) (let X&& (shen.newpv V2880) (do (shen.incinfs) (cut Throwcontrol V2880 (freeze (bind X&& (shen.placeholder) V2880 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2880) (shen.lazyderef X V2880) (shen.lazyderef Y V2880)) V2880 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2879) V2880 V2881)))))))))) (do (shen.unbindv V2768 V2880) Result)))) false)))) (if (shen.pvar? V2767) (let A (shen.newpv V2880) (let B (shen.newpv V2880) (do (shen.bindv V2767 (cons A (cons --> (cons B ()))) V2880) (let Result (let Z (shen.newpv V2880) (let X&& (shen.newpv V2880) (do (shen.incinfs) (cut Throwcontrol V2880 (freeze (bind X&& (shen.placeholder) V2880 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2880) (shen.lazyderef X V2880) (shen.lazyderef Y V2880)) V2880 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2879) V2880 V2881)))))))))) (do (shen.unbindv V2767 V2880) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2774 (shen.lazyderef V2877 V2880) (if (cons? V2774) (let V2775 (shen.lazyderef (hd V2774) V2880) (if (= let V2775) (let V2776 (shen.lazyderef (tl V2774) V2880) (if (cons? V2776) (let X (hd V2776) (let V2777 (shen.lazyderef (tl V2776) V2880) (if (cons? V2777) (let Y (hd V2777) (let V2778 (shen.lazyderef (tl V2777) V2880) (if (cons? V2778) (let Z (hd V2778) (let V2779 (shen.lazyderef (tl V2778) V2880) (if (= () V2779) (let W (shen.newpv V2880) (let X&& (shen.newpv V2880) (let B (shen.newpv V2880) (do (shen.incinfs) (cut Throwcontrol V2880 (freeze (shen.th* Y B V2879 V2880 (freeze (bind X&& (shen.placeholder) V2880 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2880) (shen.lazyderef X V2880) (shen.lazyderef Z V2880)) V2880 (freeze (shen.th* W V2878 (cons (cons X&& (cons : (cons B ()))) V2879) V2880 V2881))))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2780 (shen.lazyderef V2877 V2880) (if (cons? V2780) (let V2781 (shen.lazyderef (hd V2780) V2880) (if (= open V2781) (let V2782 (shen.lazyderef (tl V2780) V2880) (if (cons? V2782) (let V2783 (shen.lazyderef (hd V2782) V2880) (if (= file V2783) (let V2784 (shen.lazyderef (tl V2782) V2880) (if (cons? V2784) (let FileName (hd V2784) (let V2785 (shen.lazyderef (tl V2784) V2880) (if (cons? V2785) (let Direction2713 (hd V2785) (let V2786 (shen.lazyderef (tl V2785) V2880) (if (= () V2786) (let V2787 (shen.lazyderef V2878 V2880) (if (cons? V2787) (let V2788 (shen.lazyderef (hd V2787) V2880) (if (= stream V2788) (let V2789 (shen.lazyderef (tl V2787) V2880) (if (cons? V2789) (let Direction (hd V2789) (let V2790 (shen.lazyderef (tl V2789) V2880) (if (= () V2790) (do (shen.incinfs) (unify! Direction Direction2713 V2880 (freeze (cut Throwcontrol V2880 (freeze (shen.th* FileName string V2879 V2880 V2881)))))) (if (shen.pvar? V2790) (do (shen.bindv V2790 () V2880) (let Result (do (shen.incinfs) (unify! Direction Direction2713 V2880 (freeze (cut Throwcontrol V2880 (freeze (shen.th* FileName string V2879 V2880 V2881)))))) (do (shen.unbindv V2790 V2880) Result))) false)))) (if (shen.pvar? V2789) (let Direction (shen.newpv V2880) (do (shen.bindv V2789 (cons Direction ()) V2880) (let Result (do (shen.incinfs) (unify! Direction Direction2713 V2880 (freeze (cut Throwcontrol V2880 (freeze (shen.th* FileName string V2879 V2880 V2881)))))) (do (shen.unbindv V2789 V2880) Result)))) false))) (if (shen.pvar? V2788) (do (shen.bindv V2788 stream V2880) (let Result (let V2791 (shen.lazyderef (tl V2787) V2880) (if (cons? V2791) (let Direction (hd V2791) (let V2792 (shen.lazyderef (tl V2791) V2880) (if (= () V2792) (do (shen.incinfs) (unify! Direction Direction2713 V2880 (freeze (cut Throwcontrol V2880 (freeze (shen.th* FileName string V2879 V2880 V2881)))))) (if (shen.pvar? V2792) (do (shen.bindv V2792 () V2880) (let Result (do (shen.incinfs) (unify! Direction Direction2713 V2880 (freeze (cut Throwcontrol V2880 (freeze (shen.th* FileName string V2879 V2880 V2881)))))) (do (shen.unbindv V2792 V2880) Result))) false)))) (if (shen.pvar? V2791) (let Direction (shen.newpv V2880) (do (shen.bindv V2791 (cons Direction ()) V2880) (let Result (do (shen.incinfs) (unify! Direction Direction2713 V2880 (freeze (cut Throwcontrol V2880 (freeze (shen.th* FileName string V2879 V2880 V2881)))))) (do (shen.unbindv V2791 V2880) Result)))) false))) (do (shen.unbindv V2788 V2880) Result))) false))) (if (shen.pvar? V2787) (let Direction (shen.newpv V2880) (do (shen.bindv V2787 (cons stream (cons Direction ())) V2880) (let Result (do (shen.incinfs) (unify! Direction Direction2713 V2880 (freeze (cut Throwcontrol V2880 (freeze (shen.th* FileName string V2879 V2880 V2881)))))) (do (shen.unbindv V2787 V2880) Result)))) false))) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2793 (shen.lazyderef V2877 V2880) (if (cons? V2793) (let V2794 (shen.lazyderef (hd V2793) V2880) (if (= type V2794) (let V2795 (shen.lazyderef (tl V2793) V2880) (if (cons? V2795) (let X (hd V2795) (let V2796 (shen.lazyderef (tl V2795) V2880) (if (cons? V2796) (let A (hd V2796) (let V2797 (shen.lazyderef (tl V2796) V2880) (if (= () V2797) (do (shen.incinfs) (cut Throwcontrol V2880 (freeze (unify A V2878 V2880 (freeze (shen.th* X A V2879 V2880 V2881)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2798 (shen.lazyderef V2877 V2880) (if (cons? V2798) (let V2799 (shen.lazyderef (hd V2798) V2880) (if (= input+ V2799) (let V2800 (shen.lazyderef (tl V2798) V2880) (if (cons? V2800) (let V2801 (shen.lazyderef (hd V2800) V2880) (if (= : V2801) (let V2802 (shen.lazyderef (tl V2800) V2880) (if (cons? V2802) (let A (hd V2802) (let V2803 (shen.lazyderef (tl V2802) V2880) (if (= () V2803) (let C (shen.newpv V2880) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2880)) V2880 (freeze (unify V2878 C V2880 V2881))))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2804 (shen.lazyderef V2877 V2880) (if (cons? V2804) (let V2805 (shen.lazyderef (hd V2804) V2880) (if (= read+ V2805) (let V2806 (shen.lazyderef (tl V2804) V2880) (if (cons? V2806) (let V2807 (shen.lazyderef (hd V2806) V2880) (if (= : V2807) (let V2808 (shen.lazyderef (tl V2806) V2880) (if (cons? V2808) (let A (hd V2808) (let V2809 (shen.lazyderef (tl V2808) V2880) (if (= () V2809) (let C (shen.newpv V2880) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2880)) V2880 (freeze (unify V2878 C V2880 V2881))))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2810 (shen.lazyderef V2877 V2880) (if (cons? V2810) (let V2811 (shen.lazyderef (hd V2810) V2880) (if (= set V2811) (let V2812 (shen.lazyderef (tl V2810) V2880) (if (cons? V2812) (let Var (hd V2812) (let V2813 (shen.lazyderef (tl V2812) V2880) (if (cons? V2813) (let Val (hd V2813) (let V2814 (shen.lazyderef (tl V2813) V2880) (if (= () V2814) (do (shen.incinfs) (cut Throwcontrol V2880 (freeze (shen.th* Var symbol V2879 V2880 (freeze (cut Throwcontrol V2880 (freeze (shen.th* (cons value (cons Var ())) V2878 V2879 V2880 (freeze (shen.th* Val V2878 V2879 V2880 V2881)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2815 (shen.lazyderef V2877 V2880) (if (cons? V2815) (let V2816 (shen.lazyderef (hd V2815) V2880) (if (= shen.<-sem V2816) (let V2817 (shen.lazyderef (tl V2815) V2880) (if (cons? V2817) (let F (hd V2817) (let V2818 (shen.lazyderef (tl V2817) V2880) (if (= () V2818) (let A (shen.newpv V2880) (let F&& (shen.newpv V2880) (let B (shen.newpv V2880) (do (shen.incinfs) (cut Throwcontrol V2880 (freeze (shen.th* F (cons A (cons ==> (cons B ()))) V2879 V2880 (freeze (cut Throwcontrol V2880 (freeze (bind F&& (concat && (shen.lazyderef F V2880)) V2880 (freeze (cut Throwcontrol V2880 (freeze (shen.th* F&& V2878 (cons (cons F&& (cons : (cons B ()))) V2879) V2880 V2881))))))))))))))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2819 (shen.lazyderef V2877 V2880) (if (cons? V2819) (let V2820 (shen.lazyderef (hd V2819) V2880) (if (= fail V2820) (let V2821 (shen.lazyderef (tl V2819) V2880) (if (= () V2821) (let V2822 (shen.lazyderef V2878 V2880) (if (= symbol V2822) (do (shen.incinfs) (thaw V2881)) (if (shen.pvar? V2822) (do (shen.bindv V2822 symbol V2880) (let Result (do (shen.incinfs) (thaw V2881)) (do (shen.unbindv V2822 V2880) Result))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2880) (do (shen.incinfs) (shen.t*-hyps V2879 NewHyp V2880 (freeze (shen.th* V2877 V2878 NewHyp V2880 V2881))))) (if (= Case false) (let Case (let V2823 (shen.lazyderef V2877 V2880) (if (cons? V2823) (let V2824 (shen.lazyderef (hd V2823) V2880) (if (= define V2824) (let V2825 (shen.lazyderef (tl V2823) V2880) (if (cons? V2825) (let F (hd V2825) (let X (tl V2825) (do (shen.incinfs) (cut Throwcontrol V2880 (freeze (shen.t*-def (cons define (cons F X)) V2878 V2879 V2880 V2881)))))) false)) false)) false)) (if (= Case false) (let Case (let V2826 (shen.lazyderef V2877 V2880) (if (cons? V2826) (let V2827 (shen.lazyderef (hd V2826) V2880) (if (= defcc V2827) (let V2828 (shen.lazyderef (tl V2826) V2880) (if (cons? V2828) (let F (hd V2828) (let X (tl V2828) (do (shen.incinfs) (cut Throwcontrol V2880 (freeze (shen.t*-defcc (cons defcc (cons F X)) V2878 V2879 V2880 V2881)))))) false)) false)) false)) (if (= Case false) (let Case (let V2829 (shen.lazyderef V2877 V2880) (if (cons? V2829) (let V2830 (shen.lazyderef (hd V2829) V2880) (if (= shen.process-datatype V2830) (let V2831 (shen.lazyderef V2878 V2880) (if (= symbol V2831) (do (shen.incinfs) (thaw V2881)) (if (shen.pvar? V2831) (do (shen.bindv V2831 symbol V2880) (let Result (do (shen.incinfs) (thaw V2881)) (do (shen.unbindv V2831 V2880) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2832 (shen.lazyderef V2877 V2880) (if (cons? V2832) (let V2833 (shen.lazyderef (hd V2832) V2880) (if (= shen.synonyms-help V2833) (let V2834 (shen.lazyderef V2878 V2880) (if (= symbol V2834) (do (shen.incinfs) (thaw V2881)) (if (shen.pvar? V2834) (do (shen.bindv V2834 symbol V2880) (let Result (do (shen.incinfs) (thaw V2881)) (do (shen.unbindv V2834 V2880) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2880) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2880 (freeze (shen.udefs* (cons V2877 (cons : (cons V2878 ()))) V2879 Datatypes V2880 V2881))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2882 V2883 V2884 V2885) (let Case (let V2628 (shen.lazyderef V2882 V2884) (if (cons? V2628) (let V2629 (shen.lazyderef (hd V2628) V2884) (if (cons? V2629) (let V2630 (shen.lazyderef (hd V2629) V2884) (if (cons? V2630) (let V2631 (shen.lazyderef (hd V2630) V2884) (if (= cons V2631) (let V2632 (shen.lazyderef (tl V2630) V2884) (if (cons? V2632) (let X (hd V2632) (let V2633 (shen.lazyderef (tl V2632) V2884) (if (cons? V2633) (let Y (hd V2633) (let V2634 (shen.lazyderef (tl V2633) V2884) (if (= () V2634) (let V2635 (shen.lazyderef (tl V2629) V2884) (if (cons? V2635) (let V2636 (shen.lazyderef (hd V2635) V2884) (if (= : V2636) (let V2637 (shen.lazyderef (tl V2635) V2884) (if (cons? V2637) (let V2638 (shen.lazyderef (hd V2637) V2884) (if (cons? V2638) (let V2639 (shen.lazyderef (hd V2638) V2884) (if (= list V2639) (let V2640 (shen.lazyderef (tl V2638) V2884) (if (cons? V2640) (let A (hd V2640) (let V2641 (shen.lazyderef (tl V2640) V2884) (if (= () V2641) (let V2642 (shen.lazyderef (tl V2637) V2884) (if (= () V2642) (let Hyp (tl V2628) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons list (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2642) (do (shen.bindv V2642 () V2884) (let Result (let Hyp (tl V2628) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons list (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2642 V2884) Result))) false))) (if (shen.pvar? V2641) (do (shen.bindv V2641 () V2884) (let Result (let V2643 (shen.lazyderef (tl V2637) V2884) (if (= () V2643) (let Hyp (tl V2628) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons list (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2643) (do (shen.bindv V2643 () V2884) (let Result (let Hyp (tl V2628) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons list (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2643 V2884) Result))) false))) (do (shen.unbindv V2641 V2884) Result))) false)))) (if (shen.pvar? V2640) (let A (shen.newpv V2884) (do (shen.bindv V2640 (cons A ()) V2884) (let Result (let V2644 (shen.lazyderef (tl V2637) V2884) (if (= () V2644) (let Hyp (tl V2628) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons list (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2644) (do (shen.bindv V2644 () V2884) (let Result (let Hyp (tl V2628) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons list (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2644 V2884) Result))) false))) (do (shen.unbindv V2640 V2884) Result)))) false))) (if (shen.pvar? V2639) (do (shen.bindv V2639 list V2884) (let Result (let V2645 (shen.lazyderef (tl V2638) V2884) (if (cons? V2645) (let A (hd V2645) (let V2646 (shen.lazyderef (tl V2645) V2884) (if (= () V2646) (let V2647 (shen.lazyderef (tl V2637) V2884) (if (= () V2647) (let Hyp (tl V2628) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons list (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2647) (do (shen.bindv V2647 () V2884) (let Result (let Hyp (tl V2628) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons list (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2647 V2884) Result))) false))) (if (shen.pvar? V2646) (do (shen.bindv V2646 () V2884) (let Result (let V2648 (shen.lazyderef (tl V2637) V2884) (if (= () V2648) (let Hyp (tl V2628) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons list (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2648) (do (shen.bindv V2648 () V2884) (let Result (let Hyp (tl V2628) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons list (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2648 V2884) Result))) false))) (do (shen.unbindv V2646 V2884) Result))) false)))) (if (shen.pvar? V2645) (let A (shen.newpv V2884) (do (shen.bindv V2645 (cons A ()) V2884) (let Result (let V2649 (shen.lazyderef (tl V2637) V2884) (if (= () V2649) (let Hyp (tl V2628) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons list (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2649) (do (shen.bindv V2649 () V2884) (let Result (let Hyp (tl V2628) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons list (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2649 V2884) Result))) false))) (do (shen.unbindv V2645 V2884) Result)))) false))) (do (shen.unbindv V2639 V2884) Result))) false))) (if (shen.pvar? V2638) (let A (shen.newpv V2884) (do (shen.bindv V2638 (cons list (cons A ())) V2884) (let Result (let V2650 (shen.lazyderef (tl V2637) V2884) (if (= () V2650) (let Hyp (tl V2628) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons list (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2650) (do (shen.bindv V2650 () V2884) (let Result (let Hyp (tl V2628) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons list (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2650 V2884) Result))) false))) (do (shen.unbindv V2638 V2884) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2651 (shen.lazyderef V2882 V2884) (if (cons? V2651) (let V2652 (shen.lazyderef (hd V2651) V2884) (if (cons? V2652) (let V2653 (shen.lazyderef (hd V2652) V2884) (if (cons? V2653) (let V2654 (shen.lazyderef (hd V2653) V2884) (if (= @p V2654) (let V2655 (shen.lazyderef (tl V2653) V2884) (if (cons? V2655) (let X (hd V2655) (let V2656 (shen.lazyderef (tl V2655) V2884) (if (cons? V2656) (let Y (hd V2656) (let V2657 (shen.lazyderef (tl V2656) V2884) (if (= () V2657) (let V2658 (shen.lazyderef (tl V2652) V2884) (if (cons? V2658) (let V2659 (shen.lazyderef (hd V2658) V2884) (if (= : V2659) (let V2660 (shen.lazyderef (tl V2658) V2884) (if (cons? V2660) (let V2661 (shen.lazyderef (hd V2660) V2884) (if (cons? V2661) (let A (hd V2661) (let V2662 (shen.lazyderef (tl V2661) V2884) (if (cons? V2662) (let V2663 (shen.lazyderef (hd V2662) V2884) (if (= * V2663) (let V2664 (shen.lazyderef (tl V2662) V2884) (if (cons? V2664) (let B (hd V2664) (let V2665 (shen.lazyderef (tl V2664) V2884) (if (= () V2665) (let V2666 (shen.lazyderef (tl V2660) V2884) (if (= () V2666) (let Hyp (tl V2651) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (shen.lazyderef B V2884) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2666) (do (shen.bindv V2666 () V2884) (let Result (let Hyp (tl V2651) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (shen.lazyderef B V2884) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2666 V2884) Result))) false))) (if (shen.pvar? V2665) (do (shen.bindv V2665 () V2884) (let Result (let V2667 (shen.lazyderef (tl V2660) V2884) (if (= () V2667) (let Hyp (tl V2651) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (shen.lazyderef B V2884) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2667) (do (shen.bindv V2667 () V2884) (let Result (let Hyp (tl V2651) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (shen.lazyderef B V2884) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2667 V2884) Result))) false))) (do (shen.unbindv V2665 V2884) Result))) false)))) (if (shen.pvar? V2664) (let B (shen.newpv V2884) (do (shen.bindv V2664 (cons B ()) V2884) (let Result (let V2668 (shen.lazyderef (tl V2660) V2884) (if (= () V2668) (let Hyp (tl V2651) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (shen.lazyderef B V2884) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2668) (do (shen.bindv V2668 () V2884) (let Result (let Hyp (tl V2651) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (shen.lazyderef B V2884) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2668 V2884) Result))) false))) (do (shen.unbindv V2664 V2884) Result)))) false))) (if (shen.pvar? V2663) (do (shen.bindv V2663 * V2884) (let Result (let V2669 (shen.lazyderef (tl V2662) V2884) (if (cons? V2669) (let B (hd V2669) (let V2670 (shen.lazyderef (tl V2669) V2884) (if (= () V2670) (let V2671 (shen.lazyderef (tl V2660) V2884) (if (= () V2671) (let Hyp (tl V2651) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (shen.lazyderef B V2884) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2671) (do (shen.bindv V2671 () V2884) (let Result (let Hyp (tl V2651) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (shen.lazyderef B V2884) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2671 V2884) Result))) false))) (if (shen.pvar? V2670) (do (shen.bindv V2670 () V2884) (let Result (let V2672 (shen.lazyderef (tl V2660) V2884) (if (= () V2672) (let Hyp (tl V2651) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (shen.lazyderef B V2884) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2672) (do (shen.bindv V2672 () V2884) (let Result (let Hyp (tl V2651) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (shen.lazyderef B V2884) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2672 V2884) Result))) false))) (do (shen.unbindv V2670 V2884) Result))) false)))) (if (shen.pvar? V2669) (let B (shen.newpv V2884) (do (shen.bindv V2669 (cons B ()) V2884) (let Result (let V2673 (shen.lazyderef (tl V2660) V2884) (if (= () V2673) (let Hyp (tl V2651) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (shen.lazyderef B V2884) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2673) (do (shen.bindv V2673 () V2884) (let Result (let Hyp (tl V2651) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (shen.lazyderef B V2884) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2673 V2884) Result))) false))) (do (shen.unbindv V2669 V2884) Result)))) false))) (do (shen.unbindv V2663 V2884) Result))) false))) (if (shen.pvar? V2662) (let B (shen.newpv V2884) (do (shen.bindv V2662 (cons * (cons B ())) V2884) (let Result (let V2674 (shen.lazyderef (tl V2660) V2884) (if (= () V2674) (let Hyp (tl V2651) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (shen.lazyderef B V2884) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2674) (do (shen.bindv V2674 () V2884) (let Result (let Hyp (tl V2651) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (shen.lazyderef B V2884) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2674 V2884) Result))) false))) (do (shen.unbindv V2662 V2884) Result)))) false)))) (if (shen.pvar? V2661) (let A (shen.newpv V2884) (let B (shen.newpv V2884) (do (shen.bindv V2661 (cons A (cons * (cons B ()))) V2884) (let Result (let V2675 (shen.lazyderef (tl V2660) V2884) (if (= () V2675) (let Hyp (tl V2651) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (shen.lazyderef B V2884) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2675) (do (shen.bindv V2675 () V2884) (let Result (let Hyp (tl V2651) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (shen.lazyderef B V2884) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2675 V2884) Result))) false))) (do (shen.unbindv V2661 V2884) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2676 (shen.lazyderef V2882 V2884) (if (cons? V2676) (let V2677 (shen.lazyderef (hd V2676) V2884) (if (cons? V2677) (let V2678 (shen.lazyderef (hd V2677) V2884) (if (cons? V2678) (let V2679 (shen.lazyderef (hd V2678) V2884) (if (= @v V2679) (let V2680 (shen.lazyderef (tl V2678) V2884) (if (cons? V2680) (let X (hd V2680) (let V2681 (shen.lazyderef (tl V2680) V2884) (if (cons? V2681) (let Y (hd V2681) (let V2682 (shen.lazyderef (tl V2681) V2884) (if (= () V2682) (let V2683 (shen.lazyderef (tl V2677) V2884) (if (cons? V2683) (let V2684 (shen.lazyderef (hd V2683) V2884) (if (= : V2684) (let V2685 (shen.lazyderef (tl V2683) V2884) (if (cons? V2685) (let V2686 (shen.lazyderef (hd V2685) V2884) (if (cons? V2686) (let V2687 (shen.lazyderef (hd V2686) V2884) (if (= vector V2687) (let V2688 (shen.lazyderef (tl V2686) V2884) (if (cons? V2688) (let A (hd V2688) (let V2689 (shen.lazyderef (tl V2688) V2884) (if (= () V2689) (let V2690 (shen.lazyderef (tl V2685) V2884) (if (= () V2690) (let Hyp (tl V2676) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons vector (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2690) (do (shen.bindv V2690 () V2884) (let Result (let Hyp (tl V2676) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons vector (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2690 V2884) Result))) false))) (if (shen.pvar? V2689) (do (shen.bindv V2689 () V2884) (let Result (let V2691 (shen.lazyderef (tl V2685) V2884) (if (= () V2691) (let Hyp (tl V2676) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons vector (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2691) (do (shen.bindv V2691 () V2884) (let Result (let Hyp (tl V2676) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons vector (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2691 V2884) Result))) false))) (do (shen.unbindv V2689 V2884) Result))) false)))) (if (shen.pvar? V2688) (let A (shen.newpv V2884) (do (shen.bindv V2688 (cons A ()) V2884) (let Result (let V2692 (shen.lazyderef (tl V2685) V2884) (if (= () V2692) (let Hyp (tl V2676) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons vector (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2692) (do (shen.bindv V2692 () V2884) (let Result (let Hyp (tl V2676) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons vector (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2692 V2884) Result))) false))) (do (shen.unbindv V2688 V2884) Result)))) false))) (if (shen.pvar? V2687) (do (shen.bindv V2687 vector V2884) (let Result (let V2693 (shen.lazyderef (tl V2686) V2884) (if (cons? V2693) (let A (hd V2693) (let V2694 (shen.lazyderef (tl V2693) V2884) (if (= () V2694) (let V2695 (shen.lazyderef (tl V2685) V2884) (if (= () V2695) (let Hyp (tl V2676) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons vector (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2695) (do (shen.bindv V2695 () V2884) (let Result (let Hyp (tl V2676) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons vector (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2695 V2884) Result))) false))) (if (shen.pvar? V2694) (do (shen.bindv V2694 () V2884) (let Result (let V2696 (shen.lazyderef (tl V2685) V2884) (if (= () V2696) (let Hyp (tl V2676) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons vector (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2696) (do (shen.bindv V2696 () V2884) (let Result (let Hyp (tl V2676) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons vector (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2696 V2884) Result))) false))) (do (shen.unbindv V2694 V2884) Result))) false)))) (if (shen.pvar? V2693) (let A (shen.newpv V2884) (do (shen.bindv V2693 (cons A ()) V2884) (let Result (let V2697 (shen.lazyderef (tl V2685) V2884) (if (= () V2697) (let Hyp (tl V2676) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons vector (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2697) (do (shen.bindv V2697 () V2884) (let Result (let Hyp (tl V2676) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons vector (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2697 V2884) Result))) false))) (do (shen.unbindv V2693 V2884) Result)))) false))) (do (shen.unbindv V2687 V2884) Result))) false))) (if (shen.pvar? V2686) (let A (shen.newpv V2884) (do (shen.bindv V2686 (cons vector (cons A ())) V2884) (let Result (let V2698 (shen.lazyderef (tl V2685) V2884) (if (= () V2698) (let Hyp (tl V2676) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons vector (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2698) (do (shen.bindv V2698 () V2884) (let Result (let Hyp (tl V2676) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons (shen.lazyderef A V2884) ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons (cons vector (cons (shen.lazyderef A V2884) ())) ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2698 V2884) Result))) false))) (do (shen.unbindv V2686 V2884) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2699 (shen.lazyderef V2882 V2884) (if (cons? V2699) (let V2700 (shen.lazyderef (hd V2699) V2884) (if (cons? V2700) (let V2701 (shen.lazyderef (hd V2700) V2884) (if (cons? V2701) (let V2702 (shen.lazyderef (hd V2701) V2884) (if (= @s V2702) (let V2703 (shen.lazyderef (tl V2701) V2884) (if (cons? V2703) (let X (hd V2703) (let V2704 (shen.lazyderef (tl V2703) V2884) (if (cons? V2704) (let Y (hd V2704) (let V2705 (shen.lazyderef (tl V2704) V2884) (if (= () V2705) (let V2706 (shen.lazyderef (tl V2700) V2884) (if (cons? V2706) (let V2707 (shen.lazyderef (hd V2706) V2884) (if (= : V2707) (let V2708 (shen.lazyderef (tl V2706) V2884) (if (cons? V2708) (let V2709 (shen.lazyderef (hd V2708) V2884) (if (= string V2709) (let V2710 (shen.lazyderef (tl V2708) V2884) (if (= () V2710) (let Hyp (tl V2699) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons string ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2710) (do (shen.bindv V2710 () V2884) (let Result (let Hyp (tl V2699) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons string ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2710 V2884) Result))) false))) (if (shen.pvar? V2709) (do (shen.bindv V2709 string V2884) (let Result (let V2711 (shen.lazyderef (tl V2708) V2884) (if (= () V2711) (let Hyp (tl V2699) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons string ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (if (shen.pvar? V2711) (do (shen.bindv V2711 () V2884) (let Result (let Hyp (tl V2699) (do (shen.incinfs) (bind V2883 (cons (cons (shen.lazyderef X V2884) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2884) (cons : (cons string ()))) (shen.lazyderef Hyp V2884))) V2884 V2885))) (do (shen.unbindv V2711 V2884) Result))) false))) (do (shen.unbindv V2709 V2884) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V2712 (shen.lazyderef V2882 V2884) (if (cons? V2712) (let X (hd V2712) (let Hyp (tl V2712) (let NewHyps (shen.newpv V2884) (do (shen.incinfs) (bind V2883 (cons (shen.lazyderef X V2884) (shen.lazyderef NewHyps V2884)) V2884 (freeze (shen.t*-hyps Hyp NewHyps V2884 V2885))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2898 V2899 V2900 V2901) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2898 V2900)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2899 V2900) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user (value *language*)) (thaw V2901))))))))) (true (thaw V2901))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2902) (cond ((and (cons? V2902) (and (cons? (tl V2902)) (and (= : (hd (tl V2902))) (and (cons? (tl (tl V2902))) (= () (tl (tl (tl V2902)))))))) (shen.prhush (shen.app (hd V2902) (cn " : " (shen.app (hd (tl (tl V2902))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V2902 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2905 V2906) (cond ((= () V2905) shen.skip) ((cons? V2905) (do (shen.prhush (shen.app V2906 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2905)) (do (nl 1) (shen.show-assumptions (tl V2905) (+ V2906 1)))))) (true (shen.sys-error shen.show-assumptions))))

(defun shen.pause-for-user (V2911) (cond ((= "Common Lisp" V2911) (let I (FORMAT () "~C" (READ-CHAR)) (if (= I "a") (simple-error "input aborted
") (nl 1)))) (true (let I (shen.read-char) (if (= I "a") (simple-error "input aborted
") (nl 1))))))

(defun shen.read-char () (shen.read-char-h (read-byte (stinput)) 0))

(defun shen.read-char-h (V2914 V2915) (cond ((and (= -1 V2914) (= 0 V2915)) (shen.read-char-h (read-byte (stinput)) 1)) ((= 0 V2915) (shen.read-char-h (read-byte (stinput)) 0)) ((and (= -1 V2914) (= 1 V2915)) (shen.read-char-h (read-byte (stinput)) 1)) ((= 1 V2915) (n->string V2914)) (true (shen.sys-error shen.read-char-h))))

(defun shen.typedf? (V2916) (cons? (assoc V2916 (value shen.*signedfuncs*))))

(defun shen.sigf (V2917) (concat shen.type-signature-of- V2917))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2918 V2919 V2920 V2921) (let Case (let V2615 (shen.lazyderef V2919 V2920) (if (= number V2615) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2918 V2920)) V2920 V2921)) (if (shen.pvar? V2615) (do (shen.bindv V2615 number V2920) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2918 V2920)) V2920 V2921)) (do (shen.unbindv V2615 V2920) Result))) false))) (if (= Case false) (let Case (let V2616 (shen.lazyderef V2919 V2920) (if (= boolean V2616) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2918 V2920)) V2920 V2921)) (if (shen.pvar? V2616) (do (shen.bindv V2616 boolean V2920) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2918 V2920)) V2920 V2921)) (do (shen.unbindv V2616 V2920) Result))) false))) (if (= Case false) (let Case (let V2617 (shen.lazyderef V2919 V2920) (if (= string V2617) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2918 V2920)) V2920 V2921)) (if (shen.pvar? V2617) (do (shen.bindv V2617 string V2920) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2918 V2920)) V2920 V2921)) (do (shen.unbindv V2617 V2920) Result))) false))) (if (= Case false) (let Case (let V2618 (shen.lazyderef V2919 V2920) (if (= symbol V2618) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2918 V2920)) V2920 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2918 V2920))) V2920 V2921)))) (if (shen.pvar? V2618) (do (shen.bindv V2618 symbol V2920) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2918 V2920)) V2920 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2918 V2920))) V2920 V2921)))) (do (shen.unbindv V2618 V2920) Result))) false))) (if (= Case false) (let V2619 (shen.lazyderef V2918 V2920) (if (= () V2619) (let V2620 (shen.lazyderef V2919 V2920) (if (cons? V2620) (let V2621 (shen.lazyderef (hd V2620) V2920) (if (= list V2621) (let V2622 (shen.lazyderef (tl V2620) V2920) (if (cons? V2622) (let A (hd V2622) (let V2623 (shen.lazyderef (tl V2622) V2920) (if (= () V2623) (do (shen.incinfs) (thaw V2921)) (if (shen.pvar? V2623) (do (shen.bindv V2623 () V2920) (let Result (do (shen.incinfs) (thaw V2921)) (do (shen.unbindv V2623 V2920) Result))) false)))) (if (shen.pvar? V2622) (let A (shen.newpv V2920) (do (shen.bindv V2622 (cons A ()) V2920) (let Result (do (shen.incinfs) (thaw V2921)) (do (shen.unbindv V2622 V2920) Result)))) false))) (if (shen.pvar? V2621) (do (shen.bindv V2621 list V2920) (let Result (let V2624 (shen.lazyderef (tl V2620) V2920) (if (cons? V2624) (let A (hd V2624) (let V2625 (shen.lazyderef (tl V2624) V2920) (if (= () V2625) (do (shen.incinfs) (thaw V2921)) (if (shen.pvar? V2625) (do (shen.bindv V2625 () V2920) (let Result (do (shen.incinfs) (thaw V2921)) (do (shen.unbindv V2625 V2920) Result))) false)))) (if (shen.pvar? V2624) (let A (shen.newpv V2920) (do (shen.bindv V2624 (cons A ()) V2920) (let Result (do (shen.incinfs) (thaw V2921)) (do (shen.unbindv V2624 V2920) Result)))) false))) (do (shen.unbindv V2621 V2920) Result))) false))) (if (shen.pvar? V2620) (let A (shen.newpv V2920) (do (shen.bindv V2620 (cons list (cons A ())) V2920) (let Result (do (shen.incinfs) (thaw V2921)) (do (shen.unbindv V2620 V2920) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V2922 V2923 V2924 V2925 V2926) (let Case (let V2606 (shen.lazyderef V2924 V2925) (if (cons? V2606) (let V2607 (shen.lazyderef (hd V2606) V2925) (if (cons? V2607) (let Y (hd V2607) (let V2608 (shen.lazyderef (tl V2607) V2925) (if (cons? V2608) (let V2609 (shen.lazyderef (hd V2608) V2925) (if (= : V2609) (let V2610 (shen.lazyderef (tl V2608) V2925) (if (cons? V2610) (let B (hd V2610) (let V2611 (shen.lazyderef (tl V2610) V2925) (if (= () V2611) (do (shen.incinfs) (identical V2922 Y V2925 (freeze (unify! V2923 B V2925 V2926)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V2612 (shen.lazyderef V2924 V2925) (if (cons? V2612) (let Hyp (tl V2612) (do (shen.incinfs) (shen.by_hypothesis V2922 V2923 Hyp V2925 V2926))) false)) Case)))

(defun shen.t*-def (V2927 V2928 V2929 V2930 V2931) (let V2600 (shen.lazyderef V2927 V2930) (if (cons? V2600) (let V2601 (shen.lazyderef (hd V2600) V2930) (if (= define V2601) (let V2602 (shen.lazyderef (tl V2600) V2930) (if (cons? V2602) (let F (hd V2602) (let X (tl V2602) (let E (shen.newpv V2930) (do (shen.incinfs) (shen.t*-defh (compile shen.<sig+rules> X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V2928 V2929 V2930 V2931))))) false)) false)) false)))

(defun shen.t*-defh (V2932 V2933 V2934 V2935 V2936 V2937) (let V2596 (shen.lazyderef V2932 V2936) (if (cons? V2596) (let Sig (hd V2596) (let Rules (tl V2596) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue Sig) V2933 V2934 V2935 Rules V2936 V2937)))) false)))

(defun shen.t*-defhh (V2938 V2939 V2940 V2941 V2942 V2943 V2944 V2945) (do (shen.incinfs) (shen.t*-rules V2943 V2939 1 V2940 (cons (cons V2940 (cons : (cons V2939 ()))) V2942) V2944 (freeze (shen.memo V2940 V2938 V2941 V2944 V2945)))))

(defun shen.memo (V2946 V2947 V2948 V2949 V2950) (let Jnk (shen.newpv V2949) (do (shen.incinfs) (unify! V2948 V2947 V2949 (freeze (bind Jnk (declare (shen.lazyderef V2946 V2949) (shen.lazyderef V2948 V2949)) V2949 V2950))))))

(defun shen.<sig+rules> (V2955) (let Result (let Parse_shen.<signature> (shen.<signature> V2955) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.ue (V2956) (cond ((cons? V2956) (map shen.ue V2956)) ((variable? V2956) (concat && V2956)) (true V2956)))

(defun shen.ues (V2961) (cond ((shen.ue? V2961) (cons V2961 ())) ((cons? V2961) (union (shen.ues (hd V2961)) (shen.ues (tl V2961)))) (true ())))

(defun shen.ue? (V2962) (and (symbol? V2962) (shen.ue-h? (str V2962))))

(defun shen.ue-h? (V2969) (cond ((and (shen.+string? V2969) (and (= "&" (pos V2969 0)) (and (shen.+string? (tlstr V2969)) (= "&" (pos (tlstr V2969) 0))))) true) (true false)))

(defun shen.t*-rules (V2970 V2971 V2972 V2973 V2974 V2975 V2976) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2571 (shen.lazyderef V2970 V2975) (if (= () V2571) (do (shen.incinfs) (thaw V2976)) false)) (if (= Case false) (let Case (let V2572 (shen.lazyderef V2970 V2975) (if (cons? V2572) (let V2573 (shen.lazyderef (hd V2572) V2975) (if (cons? V2573) (let V2574 (shen.lazyderef (hd V2573) V2975) (if (= () V2574) (let V2575 (shen.lazyderef (tl V2573) V2975) (if (cons? V2575) (let Action (hd V2575) (let V2576 (shen.lazyderef (tl V2575) V2975) (if (= () V2576) (let Rules (tl V2572) (let V2577 (shen.lazyderef V2971 V2975) (if (cons? V2577) (let V2578 (shen.lazyderef (hd V2577) V2975) (if (= --> V2578) (let V2579 (shen.lazyderef (tl V2577) V2975) (if (cons? V2579) (let A (hd V2579) (let V2580 (shen.lazyderef (tl V2579) V2975) (if (= () V2580) (do (shen.incinfs) (shen.t*-rule (cons () (cons (shen.ue Action) ())) A V2974 V2975 (freeze (cut Throwcontrol V2975 (freeze (shen.t*-rules Rules A (+ V2972 1) V2973 V2974 V2975 V2976)))))) false))) false)) false)) false))) false))) false)) false)) false)) false)) (if (= Case false) (let Case (let V2581 (shen.lazyderef V2970 V2975) (if (cons? V2581) (let Rule (hd V2581) (let Rules (tl V2581) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V2971 V2974 V2975 (freeze (cut Throwcontrol V2975 (freeze (shen.t*-rules Rules V2971 (+ V2972 1) V2973 V2974 V2975 V2976)))))))) false)) (if (= Case false) (let Err (shen.newpv V2975) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2972 V2975) (cn " of " (shen.app (shen.lazyderef V2973 V2975) "" shen.a)) shen.a))) V2975 V2976))) Case)) Case)) Case)))))

(defun shen.t*-rule (V2977 V2978 V2979 V2980 V2981) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2553 (shen.lazyderef V2977 V2980) (if (cons? V2553) (let V2554 (shen.lazyderef (hd V2553) V2980) (if (= () V2554) (let V2555 (shen.lazyderef (tl V2553) V2980) (if (cons? V2555) (let Action (hd V2555) (let V2556 (shen.lazyderef (tl V2555) V2980) (if (= () V2556) (do (shen.incinfs) (cut Throwcontrol V2980 (freeze (shen.t*-action (shen.curry Action) V2978 V2979 V2980 V2981)))) false))) false)) false)) false)) (if (= Case false) (let V2557 (shen.lazyderef V2977 V2980) (if (cons? V2557) (let V2558 (shen.lazyderef (hd V2557) V2980) (if (cons? V2558) (let Pattern (hd V2558) (let Patterns (tl V2558) (let V2559 (shen.lazyderef (tl V2557) V2980) (if (cons? V2559) (let Action (hd V2559) (let V2560 (shen.lazyderef (tl V2559) V2980) (if (= () V2560) (let V2561 (shen.lazyderef V2978 V2980) (if (cons? V2561) (let A (hd V2561) (let V2562 (shen.lazyderef (tl V2561) V2980) (if (cons? V2562) (let V2563 (shen.lazyderef (hd V2562) V2980) (if (= --> V2563) (let V2564 (shen.lazyderef (tl V2562) V2980) (if (cons? V2564) (let B (hd V2564) (let V2565 (shen.lazyderef (tl V2564) V2980) (if (= () V2565) (do (shen.incinfs) (shen.t*-pattern Pattern A V2980 (freeze (cut Throwcontrol V2980 (freeze (shen.t*-rule (cons Patterns (cons Action ())) B (cons (cons Pattern (cons : (cons A ()))) V2979) V2980 V2981)))))) false))) false)) false)) false))) false)) false))) false)))) false)) false)) Case)))))

(defun shen.t*-action (V2982 V2983 V2984 V2985 V2986) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2530 (shen.lazyderef V2982 V2985) (if (cons? V2530) (let V2531 (shen.lazyderef (hd V2530) V2985) (if (= where V2531) (let V2532 (shen.lazyderef (tl V2530) V2985) (if (cons? V2532) (let P (hd V2532) (let V2533 (shen.lazyderef (tl V2532) V2985) (if (cons? V2533) (let Action (hd V2533) (let V2534 (shen.lazyderef (tl V2533) V2985) (if (= () V2534) (do (shen.incinfs) (cut Throwcontrol V2985 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V2984 V2985 (freeze (cut Throwcontrol V2985 (freeze (shen.t*-action Action V2983 (cons (cons P (cons : (cons verified ()))) V2984) V2985 V2986)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2535 (shen.lazyderef V2982 V2985) (if (cons? V2535) (let V2536 (shen.lazyderef (hd V2535) V2985) (if (= shen.choicepoint! V2536) (let V2537 (shen.lazyderef (tl V2535) V2985) (if (cons? V2537) (let V2538 (shen.lazyderef (hd V2537) V2985) (if (cons? V2538) (let V2539 (shen.lazyderef (hd V2538) V2985) (if (cons? V2539) (let V2540 (shen.lazyderef (hd V2539) V2985) (if (= fail-if V2540) (let V2541 (shen.lazyderef (tl V2539) V2985) (if (cons? V2541) (let F (hd V2541) (let V2542 (shen.lazyderef (tl V2541) V2985) (if (= () V2542) (let V2543 (shen.lazyderef (tl V2538) V2985) (if (cons? V2543) (let Action (hd V2543) (let V2544 (shen.lazyderef (tl V2543) V2985) (if (= () V2544) (let V2545 (shen.lazyderef (tl V2537) V2985) (if (= () V2545) (do (shen.incinfs) (cut Throwcontrol V2985 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V2983 V2984 V2985 V2986)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2546 (shen.lazyderef V2982 V2985) (if (cons? V2546) (let V2547 (shen.lazyderef (hd V2546) V2985) (if (= shen.choicepoint! V2547) (let V2548 (shen.lazyderef (tl V2546) V2985) (if (cons? V2548) (let Action (hd V2548) (let V2549 (shen.lazyderef (tl V2548) V2985) (if (= () V2549) (do (shen.incinfs) (cut Throwcontrol V2985 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V2983 V2984 V2985 V2986)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V2982 (cons : (cons V2983 ()))) V2984 V2985 V2986)) Case)) Case)) Case)))))

(defun shen.t*-pattern (V2987 V2988 V2989 V2990) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Hyp (shen.newpv V2989) (do (shen.incinfs) (shen.tms->hyp (shen.ues V2987) Hyp V2989 (freeze (cut Throwcontrol V2989 (freeze (shen.t* (cons V2987 (cons : (cons V2988 ()))) Hyp V2989 V2990))))))))))

(defun shen.tms->hyp (V2991 V2992 V2993 V2994) (let Case (let V2514 (shen.lazyderef V2991 V2993) (if (= () V2514) (let V2515 (shen.lazyderef V2992 V2993) (if (= () V2515) (do (shen.incinfs) (thaw V2994)) (if (shen.pvar? V2515) (do (shen.bindv V2515 () V2993) (let Result (do (shen.incinfs) (thaw V2994)) (do (shen.unbindv V2515 V2993) Result))) false))) false)) (if (= Case false) (let V2516 (shen.lazyderef V2991 V2993) (if (cons? V2516) (let Tm2511 (hd V2516) (let Tms (tl V2516) (let V2517 (shen.lazyderef V2992 V2993) (if (cons? V2517) (let V2518 (shen.lazyderef (hd V2517) V2993) (if (cons? V2518) (let Tm (hd V2518) (let V2519 (shen.lazyderef (tl V2518) V2993) (if (cons? V2519) (let V2520 (shen.lazyderef (hd V2519) V2993) (if (= : V2520) (let V2521 (shen.lazyderef (tl V2519) V2993) (if (cons? V2521) (let A (hd V2521) (let V2522 (shen.lazyderef (tl V2521) V2993) (if (= () V2522) (let Hyp (tl V2517) (do (shen.incinfs) (unify! Tm Tm2511 V2993 (freeze (shen.tms->hyp Tms Hyp V2993 V2994))))) (if (shen.pvar? V2522) (do (shen.bindv V2522 () V2993) (let Result (let Hyp (tl V2517) (do (shen.incinfs) (unify! Tm Tm2511 V2993 (freeze (shen.tms->hyp Tms Hyp V2993 V2994))))) (do (shen.unbindv V2522 V2993) Result))) false)))) (if (shen.pvar? V2521) (let A (shen.newpv V2993) (do (shen.bindv V2521 (cons A ()) V2993) (let Result (let Hyp (tl V2517) (do (shen.incinfs) (unify! Tm Tm2511 V2993 (freeze (shen.tms->hyp Tms Hyp V2993 V2994))))) (do (shen.unbindv V2521 V2993) Result)))) false))) (if (shen.pvar? V2520) (do (shen.bindv V2520 : V2993) (let Result (let V2523 (shen.lazyderef (tl V2519) V2993) (if (cons? V2523) (let A (hd V2523) (let V2524 (shen.lazyderef (tl V2523) V2993) (if (= () V2524) (let Hyp (tl V2517) (do (shen.incinfs) (unify! Tm Tm2511 V2993 (freeze (shen.tms->hyp Tms Hyp V2993 V2994))))) (if (shen.pvar? V2524) (do (shen.bindv V2524 () V2993) (let Result (let Hyp (tl V2517) (do (shen.incinfs) (unify! Tm Tm2511 V2993 (freeze (shen.tms->hyp Tms Hyp V2993 V2994))))) (do (shen.unbindv V2524 V2993) Result))) false)))) (if (shen.pvar? V2523) (let A (shen.newpv V2993) (do (shen.bindv V2523 (cons A ()) V2993) (let Result (let Hyp (tl V2517) (do (shen.incinfs) (unify! Tm Tm2511 V2993 (freeze (shen.tms->hyp Tms Hyp V2993 V2994))))) (do (shen.unbindv V2523 V2993) Result)))) false))) (do (shen.unbindv V2520 V2993) Result))) false))) (if (shen.pvar? V2519) (let A (shen.newpv V2993) (do (shen.bindv V2519 (cons : (cons A ())) V2993) (let Result (let Hyp (tl V2517) (do (shen.incinfs) (unify! Tm Tm2511 V2993 (freeze (shen.tms->hyp Tms Hyp V2993 V2994))))) (do (shen.unbindv V2519 V2993) Result)))) false)))) (if (shen.pvar? V2518) (let Tm (shen.newpv V2993) (let A (shen.newpv V2993) (do (shen.bindv V2518 (cons Tm (cons : (cons A ()))) V2993) (let Result (let Hyp (tl V2517) (do (shen.incinfs) (unify! Tm Tm2511 V2993 (freeze (shen.tms->hyp Tms Hyp V2993 V2994))))) (do (shen.unbindv V2518 V2993) Result))))) false))) (if (shen.pvar? V2517) (let Tm (shen.newpv V2993) (let A (shen.newpv V2993) (let Hyp (shen.newpv V2993) (do (shen.bindv V2517 (cons (cons Tm (cons : (cons A ()))) Hyp) V2993) (let Result (do (shen.incinfs) (unify! Tm Tm2511 V2993 (freeze (shen.tms->hyp Tms Hyp V2993 V2994)))) (do (shen.unbindv V2517 V2993) Result)))))) false))))) false)) Case)))

(defun findall (V2995 V2996 V2997 V2998 V2999) (let B (shen.newpv V2998) (let A (shen.newpv V2998) (do (shen.incinfs) (bind A (gensym shen.a) V2998 (freeze (bind B (set (shen.lazyderef A V2998) ()) V2998 (freeze (shen.findallhelp V2995 V2996 V2997 A V2998 V2999)))))))))

(defun shen.findallhelp (V3000 V3001 V3002 V3003 V3004 V3005) (let Case (do (shen.incinfs) (call V3001 V3004 (freeze (shen.remember V3003 V3000 V3004 (freeze (fwhen false V3004 V3005)))))) (if (= Case false) (do (shen.incinfs) (bind V3002 (value (shen.lazyderef V3003 V3004)) V3004 V3005)) Case)))

(defun shen.remember (V3006 V3007 V3008 V3009) (let B (shen.newpv V3008) (do (shen.incinfs) (bind B (set (shen.deref V3006 V3008) (cons (shen.deref V3007 V3008) (value (shen.deref V3006 V3008)))) V3008 V3009))))

(defun shen.t*-defcc (V3010 V3011 V3012 V3013 V3014) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2487 (shen.lazyderef V3010 V3013) (if (cons? V2487) (let V2488 (shen.lazyderef (hd V2487) V3013) (if (= defcc V2488) (let V2489 (shen.lazyderef (tl V2487) V3013) (if (cons? V2489) (let F (hd V2489) (let V2490 (shen.lazyderef (tl V2489) V3013) (if (cons? V2490) (let V2491 (shen.lazyderef (hd V2490) V3013) (if (= { V2491) (let V2492 (shen.lazyderef (tl V2490) V3013) (if (cons? V2492) (let V2493 (shen.lazyderef (hd V2492) V3013) (if (cons? V2493) (let V2494 (shen.lazyderef (hd V2493) V3013) (if (= list V2494) (let V2495 (shen.lazyderef (tl V2493) V3013) (if (cons? V2495) (let A (hd V2495) (let V2496 (shen.lazyderef (tl V2495) V3013) (if (= () V2496) (let V2497 (shen.lazyderef (tl V2492) V3013) (if (cons? V2497) (let V2498 (shen.lazyderef (hd V2497) V3013) (if (= ==> V2498) (let V2499 (shen.lazyderef (tl V2497) V3013) (if (cons? V2499) (let B (hd V2499) (let V2500 (shen.lazyderef (tl V2499) V3013) (if (cons? V2500) (let V2501 (shen.lazyderef (hd V2500) V3013) (if (= } V2501) (let Rest (tl V2500) (let Rest& (shen.newpv V3013) (let Rest&& (shen.newpv V3013) (let Rules (shen.newpv V3013) (let ListA&& (shen.newpv V3013) (let B&& (shen.newpv V3013) (let Sig (shen.newpv V3013) (let Declare (shen.newpv V3013) (do (shen.incinfs) (bind Sig (shen.ue (cons (cons list (cons (shen.lazyderef A V3013) ())) (cons ==> (cons (shen.lazyderef B V3013) ())))) V3013 (freeze (bind ListA&& (hd (shen.lazyderef Sig V3013)) V3013 (freeze (bind B&& (hd (tl (tl (shen.lazyderef Sig V3013)))) V3013 (freeze (bind Rest& (shen.plug-wildcards (shen.lazyderef Rest V3013)) V3013 (freeze (bind Rest&& (shen.ue (shen.lazyderef Rest& V3013)) V3013 (freeze (shen.get-rules Rules Rest&& V3013 (freeze (cut Throwcontrol V3013 (freeze (shen.tc-rules F Rules ListA&& B&& (cons (cons F (cons : (cons Sig ()))) V3012) 1 V3013 (freeze (unify V3011 (cons (cons list (cons A ())) (cons ==> (cons B ()))) V3013 (freeze (bind Declare (declare (shen.lazyderef F V3013) (cons (cons list (cons (shen.lazyderef A V3013) ())) (cons ==> (cons (shen.lazyderef B V3013) ())))) V3013 V3014)))))))))))))))))))))))))))) false)) false))) false)) false)) false)) false))) false)) false)) false)) false)) false)) false))) false)) false)) false)))))

(defun shen.plug-wildcards (V3015) (cond ((cons? V3015) (map shen.plug-wildcards V3015)) ((= V3015 _) (gensym (intern "X"))) (true V3015)))

(defun shen.get-rules (V3016 V3017 V3018 V3019) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2480 (shen.lazyderef V3016 V3018) (if (= () V2480) (let V2481 (shen.lazyderef V3017 V3018) (if (= () V2481) (do (shen.incinfs) (cut Throwcontrol V3018 V3019)) false)) (if (shen.pvar? V2480) (do (shen.bindv V2480 () V3018) (let Result (let V2482 (shen.lazyderef V3017 V3018) (if (= () V2482) (do (shen.incinfs) (cut Throwcontrol V3018 V3019)) false)) (do (shen.unbindv V2480 V3018) Result))) false))) (if (= Case false) (let V2483 (shen.lazyderef V3016 V3018) (if (cons? V2483) (let Rule (hd V2483) (let Rules (tl V2483) (let Other (shen.newpv V3018) (do (shen.incinfs) (shen.first-rule V3017 Rule Other V3018 (freeze (cut Throwcontrol V3018 (freeze (shen.get-rules Rules Other V3018 V3019))))))))) (if (shen.pvar? V2483) (let Rule (shen.newpv V3018) (let Rules (shen.newpv V3018) (do (shen.bindv V2483 (cons Rule Rules) V3018) (let Result (let Other (shen.newpv V3018) (do (shen.incinfs) (shen.first-rule V3017 Rule Other V3018 (freeze (cut Throwcontrol V3018 (freeze (shen.get-rules Rules Other V3018 V3019))))))) (do (shen.unbindv V2483 V3018) Result))))) false))) Case)))))

(defun shen.first-rule (V3020 V3021 V3022 V3023 V3024) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2473 (shen.lazyderef V3020 V3023) (if (cons? V2473) (let V2474 (shen.lazyderef (hd V2473) V3023) (if (= ; V2474) (let Other2468 (tl V2473) (let V2475 (shen.lazyderef V3021 V3023) (if (= () V2475) (do (shen.incinfs) (unify! V3022 Other2468 V3023 (freeze (cut Throwcontrol V3023 V3024)))) (if (shen.pvar? V2475) (do (shen.bindv V2475 () V3023) (let Result (do (shen.incinfs) (unify! V3022 Other2468 V3023 (freeze (cut Throwcontrol V3023 V3024)))) (do (shen.unbindv V2475 V3023) Result))) false)))) false)) false)) (if (= Case false) (let V2476 (shen.lazyderef V3020 V3023) (if (cons? V2476) (let X2469 (hd V2476) (let Rest (tl V2476) (let V2477 (shen.lazyderef V3021 V3023) (if (cons? V2477) (let X (hd V2477) (let Rule (tl V2477) (do (shen.incinfs) (unify! X X2469 V3023 (freeze (shen.first-rule Rest Rule V3022 V3023 V3024)))))) (if (shen.pvar? V2477) (let X (shen.newpv V3023) (let Rule (shen.newpv V3023) (do (shen.bindv V2477 (cons X Rule) V3023) (let Result (do (shen.incinfs) (unify! X X2469 V3023 (freeze (shen.first-rule Rest Rule V3022 V3023 V3024)))) (do (shen.unbindv V2477 V3023) Result))))) false))))) false)) Case)))))

(defun shen.tc-rules (V3025 V3026 V3027 V3028 V3029 V3030 V3031 V3032) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2462 (shen.lazyderef V3026 V3031) (if (= () V2462) (do (shen.incinfs) (thaw V3032)) false)) (if (= Case false) (let V2463 (shen.lazyderef V3026 V3031) (if (cons? V2463) (let Rule (hd V2463) (let Rules (tl V2463) (let V2464 (shen.lazyderef V3027 V3031) (if (cons? V2464) (let V2465 (shen.lazyderef (hd V2464) V3031) (if (= list V2465) (let V2466 (shen.lazyderef (tl V2464) V3031) (if (cons? V2466) (let A (hd V2466) (let V2467 (shen.lazyderef (tl V2466) V3031) (if (= () V2467) (let M (shen.newpv V3031) (do (shen.incinfs) (shen.tc-rule V3025 Rule A V3028 V3029 V3030 V3031 (freeze (bind M (+ (shen.deref V3030 V3031) 1) V3031 (freeze (cut Throwcontrol V3031 (freeze (shen.tc-rules V3025 Rules (cons list (cons A ())) V3028 V3029 M V3031 V3032))))))))) false))) false)) false)) false)))) false)) Case)))))

(defun shen.tc-rule (V3033 V3034 V3035 V3036 V3037 V3038 V3039 V3040) (let Case (do (shen.incinfs) (shen.check-defcc-rule V3034 V3035 V3036 V3037 V3039 V3040)) (if (= Case false) (let Err (shen.newpv V3039) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3038 V3039) (cn " of " (shen.app (shen.lazyderef V3033 V3039) "" shen.a)) shen.a))) V3039 V3040))) Case)))

(defun shen.check-defcc-rule (V3041 V3042 V3043 V3044 V3045 V3046) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Syntax (shen.newpv V3045) (let Semantics (shen.newpv V3045) (let SynHyps (shen.newpv V3045) (do (shen.incinfs) (shen.get-syntax+semantics Syntax Semantics V3041 V3045 (freeze (cut Throwcontrol V3045 (freeze (shen.syntax-hyps Syntax V3044 SynHyps V3042 V3045 (freeze (cut Throwcontrol V3045 (freeze (shen.syntax-check Syntax V3042 SynHyps V3045 (freeze (cut Throwcontrol V3045 (freeze (shen.semantics-check Semantics V3043 SynHyps V3045 V3046))))))))))))))))))))

(defun shen.syntax-hyps (V3047 V3048 V3049 V3050 V3051 V3052) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2435 (shen.lazyderef V3047 V3051) (if (= () V2435) (do (shen.incinfs) (unify! V3049 V3048 V3051 V3052)) false)) (if (= Case false) (let Case (let V2436 (shen.lazyderef V3047 V3051) (if (cons? V2436) (let X2429 (hd V2436) (let Y (tl V2436) (let V2437 (shen.lazyderef V3049 V3051) (if (cons? V2437) (let V2438 (shen.lazyderef (hd V2437) V3051) (if (cons? V2438) (let X (hd V2438) (let V2439 (shen.lazyderef (tl V2438) V3051) (if (cons? V2439) (let V2440 (shen.lazyderef (hd V2439) V3051) (if (= : V2440) (let V2441 (shen.lazyderef (tl V2439) V3051) (if (cons? V2441) (let A2430 (hd V2441) (let V2442 (shen.lazyderef (tl V2441) V3051) (if (= () V2442) (let SynHyps (tl V2437) (do (shen.incinfs) (unify! V3050 A2430 V3051 (freeze (unify! X X2429 V3051 (freeze (fwhen (shen.ue? (shen.deref X V3051)) V3051 (freeze (cut Throwcontrol V3051 (freeze (shen.syntax-hyps Y V3048 SynHyps V3050 V3051 V3052))))))))))) (if (shen.pvar? V2442) (do (shen.bindv V2442 () V3051) (let Result (let SynHyps (tl V2437) (do (shen.incinfs) (unify! V3050 A2430 V3051 (freeze (unify! X X2429 V3051 (freeze (fwhen (shen.ue? (shen.deref X V3051)) V3051 (freeze (cut Throwcontrol V3051 (freeze (shen.syntax-hyps Y V3048 SynHyps V3050 V3051 V3052))))))))))) (do (shen.unbindv V2442 V3051) Result))) false)))) (if (shen.pvar? V2441) (let A2430 (shen.newpv V3051) (do (shen.bindv V2441 (cons A2430 ()) V3051) (let Result (let SynHyps (tl V2437) (do (shen.incinfs) (unify! V3050 A2430 V3051 (freeze (unify! X X2429 V3051 (freeze (fwhen (shen.ue? (shen.deref X V3051)) V3051 (freeze (cut Throwcontrol V3051 (freeze (shen.syntax-hyps Y V3048 SynHyps V3050 V3051 V3052))))))))))) (do (shen.unbindv V2441 V3051) Result)))) false))) (if (shen.pvar? V2440) (do (shen.bindv V2440 : V3051) (let Result (let V2443 (shen.lazyderef (tl V2439) V3051) (if (cons? V2443) (let A2430 (hd V2443) (let V2444 (shen.lazyderef (tl V2443) V3051) (if (= () V2444) (let SynHyps (tl V2437) (do (shen.incinfs) (unify! V3050 A2430 V3051 (freeze (unify! X X2429 V3051 (freeze (fwhen (shen.ue? (shen.deref X V3051)) V3051 (freeze (cut Throwcontrol V3051 (freeze (shen.syntax-hyps Y V3048 SynHyps V3050 V3051 V3052))))))))))) (if (shen.pvar? V2444) (do (shen.bindv V2444 () V3051) (let Result (let SynHyps (tl V2437) (do (shen.incinfs) (unify! V3050 A2430 V3051 (freeze (unify! X X2429 V3051 (freeze (fwhen (shen.ue? (shen.deref X V3051)) V3051 (freeze (cut Throwcontrol V3051 (freeze (shen.syntax-hyps Y V3048 SynHyps V3050 V3051 V3052))))))))))) (do (shen.unbindv V2444 V3051) Result))) false)))) (if (shen.pvar? V2443) (let A2430 (shen.newpv V3051) (do (shen.bindv V2443 (cons A2430 ()) V3051) (let Result (let SynHyps (tl V2437) (do (shen.incinfs) (unify! V3050 A2430 V3051 (freeze (unify! X X2429 V3051 (freeze (fwhen (shen.ue? (shen.deref X V3051)) V3051 (freeze (cut Throwcontrol V3051 (freeze (shen.syntax-hyps Y V3048 SynHyps V3050 V3051 V3052))))))))))) (do (shen.unbindv V2443 V3051) Result)))) false))) (do (shen.unbindv V2440 V3051) Result))) false))) (if (shen.pvar? V2439) (let A2430 (shen.newpv V3051) (do (shen.bindv V2439 (cons : (cons A2430 ())) V3051) (let Result (let SynHyps (tl V2437) (do (shen.incinfs) (unify! V3050 A2430 V3051 (freeze (unify! X X2429 V3051 (freeze (fwhen (shen.ue? (shen.deref X V3051)) V3051 (freeze (cut Throwcontrol V3051 (freeze (shen.syntax-hyps Y V3048 SynHyps V3050 V3051 V3052))))))))))) (do (shen.unbindv V2439 V3051) Result)))) false)))) (if (shen.pvar? V2438) (let X (shen.newpv V3051) (let A2430 (shen.newpv V3051) (do (shen.bindv V2438 (cons X (cons : (cons A2430 ()))) V3051) (let Result (let SynHyps (tl V2437) (do (shen.incinfs) (unify! V3050 A2430 V3051 (freeze (unify! X X2429 V3051 (freeze (fwhen (shen.ue? (shen.deref X V3051)) V3051 (freeze (cut Throwcontrol V3051 (freeze (shen.syntax-hyps Y V3048 SynHyps V3050 V3051 V3052))))))))))) (do (shen.unbindv V2438 V3051) Result))))) false))) (if (shen.pvar? V2437) (let X (shen.newpv V3051) (let A2430 (shen.newpv V3051) (let SynHyps (shen.newpv V3051) (do (shen.bindv V2437 (cons (cons X (cons : (cons A2430 ()))) SynHyps) V3051) (let Result (do (shen.incinfs) (unify! V3050 A2430 V3051 (freeze (unify! X X2429 V3051 (freeze (fwhen (shen.ue? (shen.deref X V3051)) V3051 (freeze (cut Throwcontrol V3051 (freeze (shen.syntax-hyps Y V3048 SynHyps V3050 V3051 V3052)))))))))) (do (shen.unbindv V2437 V3051) Result)))))) false))))) false)) (if (= Case false) (let V2445 (shen.lazyderef V3047 V3051) (if (cons? V2445) (let Y (tl V2445) (do (shen.incinfs) (shen.syntax-hyps Y V3048 V3049 V3050 V3051 V3052))) false)) Case)) Case)))))

(defun shen.get-syntax+semantics (V3053 V3054 V3055 V3056 V3057) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2401 (shen.lazyderef V3053 V3056) (if (= () V2401) (let V2402 (shen.lazyderef V3055 V3056) (if (cons? V2402) (let V2403 (shen.lazyderef (hd V2402) V3056) (if (= := V2403) (let V2404 (shen.lazyderef (tl V2402) V3056) (if (cons? V2404) (let Semantics (hd V2404) (let V2405 (shen.lazyderef (tl V2404) V3056) (if (= () V2405) (do (shen.incinfs) (cut Throwcontrol V3056 (freeze (bind V3054 (shen.lazyderef Semantics V3056) V3056 V3057)))) false))) false)) false)) false)) (if (shen.pvar? V2401) (do (shen.bindv V2401 () V3056) (let Result (let V2406 (shen.lazyderef V3055 V3056) (if (cons? V2406) (let V2407 (shen.lazyderef (hd V2406) V3056) (if (= := V2407) (let V2408 (shen.lazyderef (tl V2406) V3056) (if (cons? V2408) (let Semantics (hd V2408) (let V2409 (shen.lazyderef (tl V2408) V3056) (if (= () V2409) (do (shen.incinfs) (cut Throwcontrol V3056 (freeze (bind V3054 (shen.lazyderef Semantics V3056) V3056 V3057)))) false))) false)) false)) false)) (do (shen.unbindv V2401 V3056) Result))) false))) (if (= Case false) (let Case (let V2410 (shen.lazyderef V3053 V3056) (if (= () V2410) (let V2411 (shen.lazyderef V3055 V3056) (if (cons? V2411) (let V2412 (shen.lazyderef (hd V2411) V3056) (if (= := V2412) (let V2413 (shen.lazyderef (tl V2411) V3056) (if (cons? V2413) (let Semantics (hd V2413) (let V2414 (shen.lazyderef (tl V2413) V3056) (if (cons? V2414) (let V2415 (shen.lazyderef (hd V2414) V3056) (if (= where V2415) (let V2416 (shen.lazyderef (tl V2414) V3056) (if (cons? V2416) (let G (hd V2416) (let V2417 (shen.lazyderef (tl V2416) V3056) (if (= () V2417) (do (shen.incinfs) (cut Throwcontrol V3056 (freeze (bind V3054 (cons where (cons (shen.lazyderef G V3056) (cons (shen.lazyderef Semantics V3056) ()))) V3056 V3057)))) false))) false)) false)) false))) false)) false)) false)) (if (shen.pvar? V2410) (do (shen.bindv V2410 () V3056) (let Result (let V2418 (shen.lazyderef V3055 V3056) (if (cons? V2418) (let V2419 (shen.lazyderef (hd V2418) V3056) (if (= := V2419) (let V2420 (shen.lazyderef (tl V2418) V3056) (if (cons? V2420) (let Semantics (hd V2420) (let V2421 (shen.lazyderef (tl V2420) V3056) (if (cons? V2421) (let V2422 (shen.lazyderef (hd V2421) V3056) (if (= where V2422) (let V2423 (shen.lazyderef (tl V2421) V3056) (if (cons? V2423) (let G (hd V2423) (let V2424 (shen.lazyderef (tl V2423) V3056) (if (= () V2424) (do (shen.incinfs) (cut Throwcontrol V3056 (freeze (bind V3054 (cons where (cons (shen.lazyderef G V3056) (cons (shen.lazyderef Semantics V3056) ()))) V3056 V3057)))) false))) false)) false)) false))) false)) false)) false)) (do (shen.unbindv V2410 V3056) Result))) false))) (if (= Case false) (let V2425 (shen.lazyderef V3053 V3056) (if (cons? V2425) (let X2397 (hd V2425) (let Syntax (tl V2425) (let V2426 (shen.lazyderef V3055 V3056) (if (cons? V2426) (let X (hd V2426) (let Rule (tl V2426) (do (shen.incinfs) (unify! X X2397 V3056 (freeze (shen.get-syntax+semantics Syntax V3054 Rule V3056 V3057)))))) false)))) (if (shen.pvar? V2425) (let X2397 (shen.newpv V3056) (let Syntax (shen.newpv V3056) (do (shen.bindv V2425 (cons X2397 Syntax) V3056) (let Result (let V2427 (shen.lazyderef V3055 V3056) (if (cons? V2427) (let X (hd V2427) (let Rule (tl V2427) (do (shen.incinfs) (unify! X X2397 V3056 (freeze (shen.get-syntax+semantics Syntax V3054 Rule V3056 V3057)))))) false)) (do (shen.unbindv V2425 V3056) Result))))) false))) Case)) Case)))))

(defun shen.syntax-check (V3058 V3059 V3060 V3061 V3062) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2394 (shen.lazyderef V3058 V3061) (if (= () V2394) (do (shen.incinfs) (thaw V3062)) false)) (if (= Case false) (let Case (let V2395 (shen.lazyderef V3058 V3061) (if (cons? V2395) (let X (hd V2395) (let Syntax (tl V2395) (let C (shen.newpv V3061) (let X&& (shen.newpv V3061) (let B (shen.newpv V3061) (do (shen.incinfs) (fwhen (shen.grammar_symbol? (shen.lazyderef X V3061)) V3061 (freeze (cut Throwcontrol V3061 (freeze (shen.t* (cons X (cons : (cons (cons (cons list (cons B ())) (cons ==> (cons C ()))) ()))) V3060 V3061 (freeze (cut Throwcontrol V3061 (freeze (bind X&& (concat && (shen.lazyderef X V3061)) V3061 (freeze (cut Throwcontrol V3061 (freeze (shen.t* (cons X&& (cons : (cons (cons list (cons V3059 ())) ()))) (cons (cons X&& (cons : (cons (cons list (cons B ())) ()))) V3060) V3061 (freeze (cut Throwcontrol V3061 (freeze (shen.syntax-check Syntax V3059 V3060 V3061 V3062))))))))))))))))))))))) false)) (if (= Case false) (let V2396 (shen.lazyderef V3058 V3061) (if (cons? V2396) (let X (hd V2396) (let Syntax (tl V2396) (do (shen.incinfs) (shen.t* (cons X (cons : (cons V3059 ()))) V3060 V3061 (freeze (cut Throwcontrol V3061 (freeze (shen.syntax-check Syntax V3059 V3060 V3061 V3062)))))))) false)) Case)) Case)))))

(defun shen.semantics-check (V3063 V3064 V3065 V3066 V3067) (let Semantics* (shen.newpv V3066) (do (shen.incinfs) (bind Semantics* (shen.curry (shen.rename-semantics (shen.deref V3063 V3066))) V3066 (freeze (shen.t* (cons Semantics* (cons : (cons V3064 ()))) V3065 V3066 V3067))))))

(defun shen.rename-semantics (V3068) (cond ((cons? V3068) (cons (shen.rename-semantics (hd V3068)) (shen.rename-semantics (tl V3068)))) ((shen.grammar_symbol? V3068) (cons shen.<-sem (cons V3068 ()))) (true V3068)))



