"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.typecheck (V2823 V2824) (let Curry (shen.curry V2823) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V2824)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2825) (cond ((and (cons? V2825) (shen.special? (hd V2825))) (cons (hd V2825) (map shen.curry (tl V2825)))) ((and (cons? V2825) (and (cons? (tl V2825)) (shen.extraspecial? (hd V2825)))) V2825) ((and (cons? V2825) (and (cons? (tl V2825)) (cons? (tl (tl V2825))))) (shen.curry (cons (cons (hd V2825) (cons (hd (tl V2825)) ())) (tl (tl V2825))))) ((and (cons? V2825) (and (cons? (tl V2825)) (= () (tl (tl V2825))))) (cons (shen.curry (hd V2825)) (cons (shen.curry (hd (tl V2825))) ()))) (true V2825)))

(defun shen.special? (V2826) (element? V2826 (value shen.*special*)))

(defun shen.extraspecial? (V2827) (element? V2827 (value shen.*extraspecial*)))

(defun shen.t* (V2828 V2829 V2830 V2831) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2830) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2830 (freeze (bind Error (shen.errormaxinfs) V2830 V2831))))) (if (= Case false) (let Case (let V2817 (shen.lazyderef V2828 V2830) (if (= fail V2817) (do (shen.incinfs) (cut Throwcontrol V2830 (freeze (shen.prolog-failure V2830 V2831)))) false)) (if (= Case false) (let Case (let V2818 (shen.lazyderef V2828 V2830) (if (cons? V2818) (let X (hd V2818) (let V2819 (shen.lazyderef (tl V2818) V2830) (if (cons? V2819) (let V2820 (shen.lazyderef (hd V2819) V2830) (if (= : V2820) (let V2821 (shen.lazyderef (tl V2819) V2830) (if (cons? V2821) (let A (hd V2821) (let V2822 (shen.lazyderef (tl V2821) V2830) (if (= () V2822) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2830 (freeze (cut Throwcontrol V2830 (freeze (shen.th* X A V2829 V2830 V2831)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2830) (do (shen.incinfs) (shen.show V2828 V2829 V2830 (freeze (bind Datatypes (value shen.*datatypes*) V2830 (freeze (shen.udefs* V2828 V2829 Datatypes V2830 V2831))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2836) (cond ((= + V2836) (set shen.*shen-type-theory-enabled?* true)) ((= - V2836) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2845 V2846) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2847 V2848 V2849 V2850 V2851) (let Case (let V2813 (shen.lazyderef V2849 V2850) (if (cons? V2813) (let D (hd V2813) (do (shen.incinfs) (call (cons D (cons V2847 (cons V2848 ()))) V2850 V2851))) false)) (if (= Case false) (let V2814 (shen.lazyderef V2849 V2850) (if (cons? V2814) (let Ds (tl V2814) (do (shen.incinfs) (shen.udefs* V2847 V2848 Ds V2850 V2851))) false)) Case)))

(defun shen.th* (V2852 V2853 V2854 V2855 V2856) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2852 (cons : (cons V2853 ()))) V2854 V2855 (freeze (fwhen false V2855 V2856)))) (if (= Case false) (let Case (let F (shen.newpv V2855) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2852 V2855)) V2855 (freeze (bind F (shen.sigf (shen.lazyderef V2852 V2855)) V2855 (freeze (call (cons F (cons V2853 ())) V2855 V2856))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2852 V2853 V2855 V2856)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2852 V2853 V2854 V2855 V2856)) (if (= Case false) (let Case (let V2689 (shen.lazyderef V2852 V2855) (if (cons? V2689) (let F (hd V2689) (let V2690 (shen.lazyderef (tl V2689) V2855) (if (= () V2690) (do (shen.incinfs) (shen.th* F (cons --> (cons V2853 ())) V2854 V2855 V2856)) false))) false)) (if (= Case false) (let Case (let V2691 (shen.lazyderef V2852 V2855) (if (cons? V2691) (let F (hd V2691) (let V2692 (shen.lazyderef (tl V2691) V2855) (if (cons? V2692) (let X (hd V2692) (let V2693 (shen.lazyderef (tl V2692) V2855) (if (= () V2693) (let B (shen.newpv V2855) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2853 ()))) V2854 V2855 (freeze (shen.th* X B V2854 V2855 V2856))))) false))) false))) false)) (if (= Case false) (let Case (let V2694 (shen.lazyderef V2852 V2855) (if (cons? V2694) (let V2695 (shen.lazyderef (hd V2694) V2855) (if (= cons V2695) (let V2696 (shen.lazyderef (tl V2694) V2855) (if (cons? V2696) (let X (hd V2696) (let V2697 (shen.lazyderef (tl V2696) V2855) (if (cons? V2697) (let Y (hd V2697) (let V2698 (shen.lazyderef (tl V2697) V2855) (if (= () V2698) (let V2699 (shen.lazyderef V2853 V2855) (if (cons? V2699) (let V2700 (shen.lazyderef (hd V2699) V2855) (if (= list V2700) (let V2701 (shen.lazyderef (tl V2699) V2855) (if (cons? V2701) (let A (hd V2701) (let V2702 (shen.lazyderef (tl V2701) V2855) (if (= () V2702) (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y (cons list (cons A ())) V2854 V2855 V2856)))) (if (shen.pvar? V2702) (do (shen.bindv V2702 () V2855) (let Result (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y (cons list (cons A ())) V2854 V2855 V2856)))) (do (shen.unbindv V2702 V2855) Result))) false)))) (if (shen.pvar? V2701) (let A (shen.newpv V2855) (do (shen.bindv V2701 (cons A ()) V2855) (let Result (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y (cons list (cons A ())) V2854 V2855 V2856)))) (do (shen.unbindv V2701 V2855) Result)))) false))) (if (shen.pvar? V2700) (do (shen.bindv V2700 list V2855) (let Result (let V2703 (shen.lazyderef (tl V2699) V2855) (if (cons? V2703) (let A (hd V2703) (let V2704 (shen.lazyderef (tl V2703) V2855) (if (= () V2704) (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y (cons list (cons A ())) V2854 V2855 V2856)))) (if (shen.pvar? V2704) (do (shen.bindv V2704 () V2855) (let Result (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y (cons list (cons A ())) V2854 V2855 V2856)))) (do (shen.unbindv V2704 V2855) Result))) false)))) (if (shen.pvar? V2703) (let A (shen.newpv V2855) (do (shen.bindv V2703 (cons A ()) V2855) (let Result (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y (cons list (cons A ())) V2854 V2855 V2856)))) (do (shen.unbindv V2703 V2855) Result)))) false))) (do (shen.unbindv V2700 V2855) Result))) false))) (if (shen.pvar? V2699) (let A (shen.newpv V2855) (do (shen.bindv V2699 (cons list (cons A ())) V2855) (let Result (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y (cons list (cons A ())) V2854 V2855 V2856)))) (do (shen.unbindv V2699 V2855) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2705 (shen.lazyderef V2852 V2855) (if (cons? V2705) (let V2706 (shen.lazyderef (hd V2705) V2855) (if (= @p V2706) (let V2707 (shen.lazyderef (tl V2705) V2855) (if (cons? V2707) (let X (hd V2707) (let V2708 (shen.lazyderef (tl V2707) V2855) (if (cons? V2708) (let Y (hd V2708) (let V2709 (shen.lazyderef (tl V2708) V2855) (if (= () V2709) (let V2710 (shen.lazyderef V2853 V2855) (if (cons? V2710) (let A (hd V2710) (let V2711 (shen.lazyderef (tl V2710) V2855) (if (cons? V2711) (let V2712 (shen.lazyderef (hd V2711) V2855) (if (= * V2712) (let V2713 (shen.lazyderef (tl V2711) V2855) (if (cons? V2713) (let B (hd V2713) (let V2714 (shen.lazyderef (tl V2713) V2855) (if (= () V2714) (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y B V2854 V2855 V2856)))) (if (shen.pvar? V2714) (do (shen.bindv V2714 () V2855) (let Result (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y B V2854 V2855 V2856)))) (do (shen.unbindv V2714 V2855) Result))) false)))) (if (shen.pvar? V2713) (let B (shen.newpv V2855) (do (shen.bindv V2713 (cons B ()) V2855) (let Result (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y B V2854 V2855 V2856)))) (do (shen.unbindv V2713 V2855) Result)))) false))) (if (shen.pvar? V2712) (do (shen.bindv V2712 * V2855) (let Result (let V2715 (shen.lazyderef (tl V2711) V2855) (if (cons? V2715) (let B (hd V2715) (let V2716 (shen.lazyderef (tl V2715) V2855) (if (= () V2716) (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y B V2854 V2855 V2856)))) (if (shen.pvar? V2716) (do (shen.bindv V2716 () V2855) (let Result (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y B V2854 V2855 V2856)))) (do (shen.unbindv V2716 V2855) Result))) false)))) (if (shen.pvar? V2715) (let B (shen.newpv V2855) (do (shen.bindv V2715 (cons B ()) V2855) (let Result (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y B V2854 V2855 V2856)))) (do (shen.unbindv V2715 V2855) Result)))) false))) (do (shen.unbindv V2712 V2855) Result))) false))) (if (shen.pvar? V2711) (let B (shen.newpv V2855) (do (shen.bindv V2711 (cons * (cons B ())) V2855) (let Result (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y B V2854 V2855 V2856)))) (do (shen.unbindv V2711 V2855) Result)))) false)))) (if (shen.pvar? V2710) (let A (shen.newpv V2855) (let B (shen.newpv V2855) (do (shen.bindv V2710 (cons A (cons * (cons B ()))) V2855) (let Result (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y B V2854 V2855 V2856)))) (do (shen.unbindv V2710 V2855) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2717 (shen.lazyderef V2852 V2855) (if (cons? V2717) (let V2718 (shen.lazyderef (hd V2717) V2855) (if (= @v V2718) (let V2719 (shen.lazyderef (tl V2717) V2855) (if (cons? V2719) (let X (hd V2719) (let V2720 (shen.lazyderef (tl V2719) V2855) (if (cons? V2720) (let Y (hd V2720) (let V2721 (shen.lazyderef (tl V2720) V2855) (if (= () V2721) (let V2722 (shen.lazyderef V2853 V2855) (if (cons? V2722) (let V2723 (shen.lazyderef (hd V2722) V2855) (if (= vector V2723) (let V2724 (shen.lazyderef (tl V2722) V2855) (if (cons? V2724) (let A (hd V2724) (let V2725 (shen.lazyderef (tl V2724) V2855) (if (= () V2725) (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y (cons vector (cons A ())) V2854 V2855 V2856)))) (if (shen.pvar? V2725) (do (shen.bindv V2725 () V2855) (let Result (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y (cons vector (cons A ())) V2854 V2855 V2856)))) (do (shen.unbindv V2725 V2855) Result))) false)))) (if (shen.pvar? V2724) (let A (shen.newpv V2855) (do (shen.bindv V2724 (cons A ()) V2855) (let Result (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y (cons vector (cons A ())) V2854 V2855 V2856)))) (do (shen.unbindv V2724 V2855) Result)))) false))) (if (shen.pvar? V2723) (do (shen.bindv V2723 vector V2855) (let Result (let V2726 (shen.lazyderef (tl V2722) V2855) (if (cons? V2726) (let A (hd V2726) (let V2727 (shen.lazyderef (tl V2726) V2855) (if (= () V2727) (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y (cons vector (cons A ())) V2854 V2855 V2856)))) (if (shen.pvar? V2727) (do (shen.bindv V2727 () V2855) (let Result (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y (cons vector (cons A ())) V2854 V2855 V2856)))) (do (shen.unbindv V2727 V2855) Result))) false)))) (if (shen.pvar? V2726) (let A (shen.newpv V2855) (do (shen.bindv V2726 (cons A ()) V2855) (let Result (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y (cons vector (cons A ())) V2854 V2855 V2856)))) (do (shen.unbindv V2726 V2855) Result)))) false))) (do (shen.unbindv V2723 V2855) Result))) false))) (if (shen.pvar? V2722) (let A (shen.newpv V2855) (do (shen.bindv V2722 (cons vector (cons A ())) V2855) (let Result (do (shen.incinfs) (shen.th* X A V2854 V2855 (freeze (shen.th* Y (cons vector (cons A ())) V2854 V2855 V2856)))) (do (shen.unbindv V2722 V2855) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2728 (shen.lazyderef V2852 V2855) (if (cons? V2728) (let V2729 (shen.lazyderef (hd V2728) V2855) (if (= @s V2729) (let V2730 (shen.lazyderef (tl V2728) V2855) (if (cons? V2730) (let X (hd V2730) (let V2731 (shen.lazyderef (tl V2730) V2855) (if (cons? V2731) (let Y (hd V2731) (let V2732 (shen.lazyderef (tl V2731) V2855) (if (= () V2732) (let V2733 (shen.lazyderef V2853 V2855) (if (= string V2733) (do (shen.incinfs) (shen.th* X string V2854 V2855 (freeze (shen.th* Y string V2854 V2855 V2856)))) (if (shen.pvar? V2733) (do (shen.bindv V2733 string V2855) (let Result (do (shen.incinfs) (shen.th* X string V2854 V2855 (freeze (shen.th* Y string V2854 V2855 V2856)))) (do (shen.unbindv V2733 V2855) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2734 (shen.lazyderef V2852 V2855) (if (cons? V2734) (let V2735 (shen.lazyderef (hd V2734) V2855) (if (= lambda V2735) (let V2736 (shen.lazyderef (tl V2734) V2855) (if (cons? V2736) (let X (hd V2736) (let V2737 (shen.lazyderef (tl V2736) V2855) (if (cons? V2737) (let Y (hd V2737) (let V2738 (shen.lazyderef (tl V2737) V2855) (if (= () V2738) (let V2739 (shen.lazyderef V2853 V2855) (if (cons? V2739) (let A (hd V2739) (let V2740 (shen.lazyderef (tl V2739) V2855) (if (cons? V2740) (let V2741 (shen.lazyderef (hd V2740) V2855) (if (= --> V2741) (let V2742 (shen.lazyderef (tl V2740) V2855) (if (cons? V2742) (let B (hd V2742) (let V2743 (shen.lazyderef (tl V2742) V2855) (if (= () V2743) (let Z (shen.newpv V2855) (let X&& (shen.newpv V2855) (do (shen.incinfs) (cut Throwcontrol V2855 (freeze (bind X&& (shen.placeholder) V2855 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2855) (shen.lazyderef X V2855) (shen.lazyderef Y V2855)) V2855 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2854) V2855 V2856)))))))))) (if (shen.pvar? V2743) (do (shen.bindv V2743 () V2855) (let Result (let Z (shen.newpv V2855) (let X&& (shen.newpv V2855) (do (shen.incinfs) (cut Throwcontrol V2855 (freeze (bind X&& (shen.placeholder) V2855 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2855) (shen.lazyderef X V2855) (shen.lazyderef Y V2855)) V2855 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2854) V2855 V2856)))))))))) (do (shen.unbindv V2743 V2855) Result))) false)))) (if (shen.pvar? V2742) (let B (shen.newpv V2855) (do (shen.bindv V2742 (cons B ()) V2855) (let Result (let Z (shen.newpv V2855) (let X&& (shen.newpv V2855) (do (shen.incinfs) (cut Throwcontrol V2855 (freeze (bind X&& (shen.placeholder) V2855 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2855) (shen.lazyderef X V2855) (shen.lazyderef Y V2855)) V2855 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2854) V2855 V2856)))))))))) (do (shen.unbindv V2742 V2855) Result)))) false))) (if (shen.pvar? V2741) (do (shen.bindv V2741 --> V2855) (let Result (let V2744 (shen.lazyderef (tl V2740) V2855) (if (cons? V2744) (let B (hd V2744) (let V2745 (shen.lazyderef (tl V2744) V2855) (if (= () V2745) (let Z (shen.newpv V2855) (let X&& (shen.newpv V2855) (do (shen.incinfs) (cut Throwcontrol V2855 (freeze (bind X&& (shen.placeholder) V2855 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2855) (shen.lazyderef X V2855) (shen.lazyderef Y V2855)) V2855 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2854) V2855 V2856)))))))))) (if (shen.pvar? V2745) (do (shen.bindv V2745 () V2855) (let Result (let Z (shen.newpv V2855) (let X&& (shen.newpv V2855) (do (shen.incinfs) (cut Throwcontrol V2855 (freeze (bind X&& (shen.placeholder) V2855 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2855) (shen.lazyderef X V2855) (shen.lazyderef Y V2855)) V2855 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2854) V2855 V2856)))))))))) (do (shen.unbindv V2745 V2855) Result))) false)))) (if (shen.pvar? V2744) (let B (shen.newpv V2855) (do (shen.bindv V2744 (cons B ()) V2855) (let Result (let Z (shen.newpv V2855) (let X&& (shen.newpv V2855) (do (shen.incinfs) (cut Throwcontrol V2855 (freeze (bind X&& (shen.placeholder) V2855 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2855) (shen.lazyderef X V2855) (shen.lazyderef Y V2855)) V2855 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2854) V2855 V2856)))))))))) (do (shen.unbindv V2744 V2855) Result)))) false))) (do (shen.unbindv V2741 V2855) Result))) false))) (if (shen.pvar? V2740) (let B (shen.newpv V2855) (do (shen.bindv V2740 (cons --> (cons B ())) V2855) (let Result (let Z (shen.newpv V2855) (let X&& (shen.newpv V2855) (do (shen.incinfs) (cut Throwcontrol V2855 (freeze (bind X&& (shen.placeholder) V2855 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2855) (shen.lazyderef X V2855) (shen.lazyderef Y V2855)) V2855 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2854) V2855 V2856)))))))))) (do (shen.unbindv V2740 V2855) Result)))) false)))) (if (shen.pvar? V2739) (let A (shen.newpv V2855) (let B (shen.newpv V2855) (do (shen.bindv V2739 (cons A (cons --> (cons B ()))) V2855) (let Result (let Z (shen.newpv V2855) (let X&& (shen.newpv V2855) (do (shen.incinfs) (cut Throwcontrol V2855 (freeze (bind X&& (shen.placeholder) V2855 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2855) (shen.lazyderef X V2855) (shen.lazyderef Y V2855)) V2855 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2854) V2855 V2856)))))))))) (do (shen.unbindv V2739 V2855) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2746 (shen.lazyderef V2852 V2855) (if (cons? V2746) (let V2747 (shen.lazyderef (hd V2746) V2855) (if (= let V2747) (let V2748 (shen.lazyderef (tl V2746) V2855) (if (cons? V2748) (let X (hd V2748) (let V2749 (shen.lazyderef (tl V2748) V2855) (if (cons? V2749) (let Y (hd V2749) (let V2750 (shen.lazyderef (tl V2749) V2855) (if (cons? V2750) (let Z (hd V2750) (let V2751 (shen.lazyderef (tl V2750) V2855) (if (= () V2751) (let W (shen.newpv V2855) (let X&& (shen.newpv V2855) (let B (shen.newpv V2855) (do (shen.incinfs) (cut Throwcontrol V2855 (freeze (shen.th* Y B V2854 V2855 (freeze (bind X&& (shen.placeholder) V2855 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2855) (shen.lazyderef X V2855) (shen.lazyderef Z V2855)) V2855 (freeze (shen.th* W V2853 (cons (cons X&& (cons : (cons B ()))) V2854) V2855 V2856))))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2752 (shen.lazyderef V2852 V2855) (if (cons? V2752) (let V2753 (shen.lazyderef (hd V2752) V2855) (if (= open V2753) (let V2754 (shen.lazyderef (tl V2752) V2855) (if (cons? V2754) (let V2755 (shen.lazyderef (hd V2754) V2855) (if (= file V2755) (let V2756 (shen.lazyderef (tl V2754) V2855) (if (cons? V2756) (let FileName (hd V2756) (let V2757 (shen.lazyderef (tl V2756) V2855) (if (cons? V2757) (let Direction2685 (hd V2757) (let V2758 (shen.lazyderef (tl V2757) V2855) (if (= () V2758) (let V2759 (shen.lazyderef V2853 V2855) (if (cons? V2759) (let V2760 (shen.lazyderef (hd V2759) V2855) (if (= stream V2760) (let V2761 (shen.lazyderef (tl V2759) V2855) (if (cons? V2761) (let Direction (hd V2761) (let V2762 (shen.lazyderef (tl V2761) V2855) (if (= () V2762) (do (shen.incinfs) (unify! Direction Direction2685 V2855 (freeze (cut Throwcontrol V2855 (freeze (shen.th* FileName string V2854 V2855 V2856)))))) (if (shen.pvar? V2762) (do (shen.bindv V2762 () V2855) (let Result (do (shen.incinfs) (unify! Direction Direction2685 V2855 (freeze (cut Throwcontrol V2855 (freeze (shen.th* FileName string V2854 V2855 V2856)))))) (do (shen.unbindv V2762 V2855) Result))) false)))) (if (shen.pvar? V2761) (let Direction (shen.newpv V2855) (do (shen.bindv V2761 (cons Direction ()) V2855) (let Result (do (shen.incinfs) (unify! Direction Direction2685 V2855 (freeze (cut Throwcontrol V2855 (freeze (shen.th* FileName string V2854 V2855 V2856)))))) (do (shen.unbindv V2761 V2855) Result)))) false))) (if (shen.pvar? V2760) (do (shen.bindv V2760 stream V2855) (let Result (let V2763 (shen.lazyderef (tl V2759) V2855) (if (cons? V2763) (let Direction (hd V2763) (let V2764 (shen.lazyderef (tl V2763) V2855) (if (= () V2764) (do (shen.incinfs) (unify! Direction Direction2685 V2855 (freeze (cut Throwcontrol V2855 (freeze (shen.th* FileName string V2854 V2855 V2856)))))) (if (shen.pvar? V2764) (do (shen.bindv V2764 () V2855) (let Result (do (shen.incinfs) (unify! Direction Direction2685 V2855 (freeze (cut Throwcontrol V2855 (freeze (shen.th* FileName string V2854 V2855 V2856)))))) (do (shen.unbindv V2764 V2855) Result))) false)))) (if (shen.pvar? V2763) (let Direction (shen.newpv V2855) (do (shen.bindv V2763 (cons Direction ()) V2855) (let Result (do (shen.incinfs) (unify! Direction Direction2685 V2855 (freeze (cut Throwcontrol V2855 (freeze (shen.th* FileName string V2854 V2855 V2856)))))) (do (shen.unbindv V2763 V2855) Result)))) false))) (do (shen.unbindv V2760 V2855) Result))) false))) (if (shen.pvar? V2759) (let Direction (shen.newpv V2855) (do (shen.bindv V2759 (cons stream (cons Direction ())) V2855) (let Result (do (shen.incinfs) (unify! Direction Direction2685 V2855 (freeze (cut Throwcontrol V2855 (freeze (shen.th* FileName string V2854 V2855 V2856)))))) (do (shen.unbindv V2759 V2855) Result)))) false))) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2765 (shen.lazyderef V2852 V2855) (if (cons? V2765) (let V2766 (shen.lazyderef (hd V2765) V2855) (if (= type V2766) (let V2767 (shen.lazyderef (tl V2765) V2855) (if (cons? V2767) (let X (hd V2767) (let V2768 (shen.lazyderef (tl V2767) V2855) (if (cons? V2768) (let A (hd V2768) (let V2769 (shen.lazyderef (tl V2768) V2855) (if (= () V2769) (do (shen.incinfs) (cut Throwcontrol V2855 (freeze (unify A V2853 V2855 (freeze (shen.th* X A V2854 V2855 V2856)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2770 (shen.lazyderef V2852 V2855) (if (cons? V2770) (let V2771 (shen.lazyderef (hd V2770) V2855) (if (= input+ V2771) (let V2772 (shen.lazyderef (tl V2770) V2855) (if (cons? V2772) (let V2773 (shen.lazyderef (hd V2772) V2855) (if (= : V2773) (let V2774 (shen.lazyderef (tl V2772) V2855) (if (cons? V2774) (let A (hd V2774) (let V2775 (shen.lazyderef (tl V2774) V2855) (if (= () V2775) (let C (shen.newpv V2855) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2855)) V2855 (freeze (unify V2853 C V2855 V2856))))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2776 (shen.lazyderef V2852 V2855) (if (cons? V2776) (let V2777 (shen.lazyderef (hd V2776) V2855) (if (= read+ V2777) (let V2778 (shen.lazyderef (tl V2776) V2855) (if (cons? V2778) (let V2779 (shen.lazyderef (hd V2778) V2855) (if (= : V2779) (let V2780 (shen.lazyderef (tl V2778) V2855) (if (cons? V2780) (let A (hd V2780) (let V2781 (shen.lazyderef (tl V2780) V2855) (if (= () V2781) (let C (shen.newpv V2855) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2855)) V2855 (freeze (unify V2853 C V2855 V2856))))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2782 (shen.lazyderef V2852 V2855) (if (cons? V2782) (let V2783 (shen.lazyderef (hd V2782) V2855) (if (= set V2783) (let V2784 (shen.lazyderef (tl V2782) V2855) (if (cons? V2784) (let Var (hd V2784) (let V2785 (shen.lazyderef (tl V2784) V2855) (if (cons? V2785) (let Val (hd V2785) (let V2786 (shen.lazyderef (tl V2785) V2855) (if (= () V2786) (do (shen.incinfs) (cut Throwcontrol V2855 (freeze (shen.th* Var symbol V2854 V2855 (freeze (cut Throwcontrol V2855 (freeze (shen.th* (cons value (cons Var ())) V2853 V2854 V2855 (freeze (shen.th* Val V2853 V2854 V2855 V2856)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2787 (shen.lazyderef V2852 V2855) (if (cons? V2787) (let V2788 (shen.lazyderef (hd V2787) V2855) (if (= shen.<-sem V2788) (let V2789 (shen.lazyderef (tl V2787) V2855) (if (cons? V2789) (let F (hd V2789) (let V2790 (shen.lazyderef (tl V2789) V2855) (if (= () V2790) (let A (shen.newpv V2855) (let F&& (shen.newpv V2855) (let B (shen.newpv V2855) (do (shen.incinfs) (cut Throwcontrol V2855 (freeze (shen.th* F (cons A (cons ==> (cons B ()))) V2854 V2855 (freeze (cut Throwcontrol V2855 (freeze (bind F&& (concat && (shen.lazyderef F V2855)) V2855 (freeze (cut Throwcontrol V2855 (freeze (shen.th* F&& V2853 (cons (cons F&& (cons : (cons B ()))) V2854) V2855 V2856))))))))))))))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2791 (shen.lazyderef V2852 V2855) (if (cons? V2791) (let V2792 (shen.lazyderef (hd V2791) V2855) (if (= fail V2792) (let V2793 (shen.lazyderef (tl V2791) V2855) (if (= () V2793) (let V2794 (shen.lazyderef V2853 V2855) (if (= symbol V2794) (do (shen.incinfs) (thaw V2856)) (if (shen.pvar? V2794) (do (shen.bindv V2794 symbol V2855) (let Result (do (shen.incinfs) (thaw V2856)) (do (shen.unbindv V2794 V2855) Result))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2855) (do (shen.incinfs) (shen.t*-hyps V2854 NewHyp V2855 (freeze (shen.th* V2852 V2853 NewHyp V2855 V2856))))) (if (= Case false) (let Case (let V2795 (shen.lazyderef V2852 V2855) (if (cons? V2795) (let V2796 (shen.lazyderef (hd V2795) V2855) (if (= define V2796) (let V2797 (shen.lazyderef (tl V2795) V2855) (if (cons? V2797) (let F (hd V2797) (let X (tl V2797) (do (shen.incinfs) (cut Throwcontrol V2855 (freeze (shen.t*-def (cons define (cons F X)) V2853 V2854 V2855 V2856)))))) false)) false)) false)) (if (= Case false) (let Case (let V2798 (shen.lazyderef V2852 V2855) (if (cons? V2798) (let V2799 (shen.lazyderef (hd V2798) V2855) (if (= defcc V2799) (let V2800 (shen.lazyderef (tl V2798) V2855) (if (cons? V2800) (let F (hd V2800) (let X (tl V2800) (do (shen.incinfs) (cut Throwcontrol V2855 (freeze (shen.t*-defcc (cons defcc (cons F X)) V2853 V2854 V2855 V2856)))))) false)) false)) false)) (if (= Case false) (let Case (let V2801 (shen.lazyderef V2852 V2855) (if (cons? V2801) (let V2802 (shen.lazyderef (hd V2801) V2855) (if (= defmacro V2802) (let V2803 (shen.lazyderef V2853 V2855) (if (= unit V2803) (do (shen.incinfs) (cut Throwcontrol V2855 V2856)) (if (shen.pvar? V2803) (do (shen.bindv V2803 unit V2855) (let Result (do (shen.incinfs) (cut Throwcontrol V2855 V2856)) (do (shen.unbindv V2803 V2855) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2804 (shen.lazyderef V2852 V2855) (if (cons? V2804) (let V2805 (shen.lazyderef (hd V2804) V2855) (if (= shen.process-datatype V2805) (let V2806 (shen.lazyderef V2853 V2855) (if (= symbol V2806) (do (shen.incinfs) (thaw V2856)) (if (shen.pvar? V2806) (do (shen.bindv V2806 symbol V2855) (let Result (do (shen.incinfs) (thaw V2856)) (do (shen.unbindv V2806 V2855) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2807 (shen.lazyderef V2852 V2855) (if (cons? V2807) (let V2808 (shen.lazyderef (hd V2807) V2855) (if (= shen.synonyms-help V2808) (let V2809 (shen.lazyderef V2853 V2855) (if (= symbol V2809) (do (shen.incinfs) (thaw V2856)) (if (shen.pvar? V2809) (do (shen.bindv V2809 symbol V2855) (let Result (do (shen.incinfs) (thaw V2856)) (do (shen.unbindv V2809 V2855) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2855) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2855 (freeze (shen.udefs* (cons V2852 (cons : (cons V2853 ()))) V2854 Datatypes V2855 V2856))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2857 V2858 V2859 V2860) (let Case (let V2600 (shen.lazyderef V2857 V2859) (if (cons? V2600) (let V2601 (shen.lazyderef (hd V2600) V2859) (if (cons? V2601) (let V2602 (shen.lazyderef (hd V2601) V2859) (if (cons? V2602) (let V2603 (shen.lazyderef (hd V2602) V2859) (if (= cons V2603) (let V2604 (shen.lazyderef (tl V2602) V2859) (if (cons? V2604) (let X (hd V2604) (let V2605 (shen.lazyderef (tl V2604) V2859) (if (cons? V2605) (let Y (hd V2605) (let V2606 (shen.lazyderef (tl V2605) V2859) (if (= () V2606) (let V2607 (shen.lazyderef (tl V2601) V2859) (if (cons? V2607) (let V2608 (shen.lazyderef (hd V2607) V2859) (if (= : V2608) (let V2609 (shen.lazyderef (tl V2607) V2859) (if (cons? V2609) (let V2610 (shen.lazyderef (hd V2609) V2859) (if (cons? V2610) (let V2611 (shen.lazyderef (hd V2610) V2859) (if (= list V2611) (let V2612 (shen.lazyderef (tl V2610) V2859) (if (cons? V2612) (let A (hd V2612) (let V2613 (shen.lazyderef (tl V2612) V2859) (if (= () V2613) (let V2614 (shen.lazyderef (tl V2609) V2859) (if (= () V2614) (let Hyp (tl V2600) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons list (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2614) (do (shen.bindv V2614 () V2859) (let Result (let Hyp (tl V2600) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons list (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2614 V2859) Result))) false))) (if (shen.pvar? V2613) (do (shen.bindv V2613 () V2859) (let Result (let V2615 (shen.lazyderef (tl V2609) V2859) (if (= () V2615) (let Hyp (tl V2600) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons list (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2615) (do (shen.bindv V2615 () V2859) (let Result (let Hyp (tl V2600) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons list (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2615 V2859) Result))) false))) (do (shen.unbindv V2613 V2859) Result))) false)))) (if (shen.pvar? V2612) (let A (shen.newpv V2859) (do (shen.bindv V2612 (cons A ()) V2859) (let Result (let V2616 (shen.lazyderef (tl V2609) V2859) (if (= () V2616) (let Hyp (tl V2600) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons list (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2616) (do (shen.bindv V2616 () V2859) (let Result (let Hyp (tl V2600) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons list (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2616 V2859) Result))) false))) (do (shen.unbindv V2612 V2859) Result)))) false))) (if (shen.pvar? V2611) (do (shen.bindv V2611 list V2859) (let Result (let V2617 (shen.lazyderef (tl V2610) V2859) (if (cons? V2617) (let A (hd V2617) (let V2618 (shen.lazyderef (tl V2617) V2859) (if (= () V2618) (let V2619 (shen.lazyderef (tl V2609) V2859) (if (= () V2619) (let Hyp (tl V2600) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons list (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2619) (do (shen.bindv V2619 () V2859) (let Result (let Hyp (tl V2600) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons list (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2619 V2859) Result))) false))) (if (shen.pvar? V2618) (do (shen.bindv V2618 () V2859) (let Result (let V2620 (shen.lazyderef (tl V2609) V2859) (if (= () V2620) (let Hyp (tl V2600) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons list (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2620) (do (shen.bindv V2620 () V2859) (let Result (let Hyp (tl V2600) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons list (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2620 V2859) Result))) false))) (do (shen.unbindv V2618 V2859) Result))) false)))) (if (shen.pvar? V2617) (let A (shen.newpv V2859) (do (shen.bindv V2617 (cons A ()) V2859) (let Result (let V2621 (shen.lazyderef (tl V2609) V2859) (if (= () V2621) (let Hyp (tl V2600) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons list (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2621) (do (shen.bindv V2621 () V2859) (let Result (let Hyp (tl V2600) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons list (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2621 V2859) Result))) false))) (do (shen.unbindv V2617 V2859) Result)))) false))) (do (shen.unbindv V2611 V2859) Result))) false))) (if (shen.pvar? V2610) (let A (shen.newpv V2859) (do (shen.bindv V2610 (cons list (cons A ())) V2859) (let Result (let V2622 (shen.lazyderef (tl V2609) V2859) (if (= () V2622) (let Hyp (tl V2600) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons list (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2622) (do (shen.bindv V2622 () V2859) (let Result (let Hyp (tl V2600) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons list (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2622 V2859) Result))) false))) (do (shen.unbindv V2610 V2859) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2623 (shen.lazyderef V2857 V2859) (if (cons? V2623) (let V2624 (shen.lazyderef (hd V2623) V2859) (if (cons? V2624) (let V2625 (shen.lazyderef (hd V2624) V2859) (if (cons? V2625) (let V2626 (shen.lazyderef (hd V2625) V2859) (if (= @p V2626) (let V2627 (shen.lazyderef (tl V2625) V2859) (if (cons? V2627) (let X (hd V2627) (let V2628 (shen.lazyderef (tl V2627) V2859) (if (cons? V2628) (let Y (hd V2628) (let V2629 (shen.lazyderef (tl V2628) V2859) (if (= () V2629) (let V2630 (shen.lazyderef (tl V2624) V2859) (if (cons? V2630) (let V2631 (shen.lazyderef (hd V2630) V2859) (if (= : V2631) (let V2632 (shen.lazyderef (tl V2630) V2859) (if (cons? V2632) (let V2633 (shen.lazyderef (hd V2632) V2859) (if (cons? V2633) (let A (hd V2633) (let V2634 (shen.lazyderef (tl V2633) V2859) (if (cons? V2634) (let V2635 (shen.lazyderef (hd V2634) V2859) (if (= * V2635) (let V2636 (shen.lazyderef (tl V2634) V2859) (if (cons? V2636) (let B (hd V2636) (let V2637 (shen.lazyderef (tl V2636) V2859) (if (= () V2637) (let V2638 (shen.lazyderef (tl V2632) V2859) (if (= () V2638) (let Hyp (tl V2623) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (shen.lazyderef B V2859) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2638) (do (shen.bindv V2638 () V2859) (let Result (let Hyp (tl V2623) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (shen.lazyderef B V2859) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2638 V2859) Result))) false))) (if (shen.pvar? V2637) (do (shen.bindv V2637 () V2859) (let Result (let V2639 (shen.lazyderef (tl V2632) V2859) (if (= () V2639) (let Hyp (tl V2623) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (shen.lazyderef B V2859) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2639) (do (shen.bindv V2639 () V2859) (let Result (let Hyp (tl V2623) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (shen.lazyderef B V2859) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2639 V2859) Result))) false))) (do (shen.unbindv V2637 V2859) Result))) false)))) (if (shen.pvar? V2636) (let B (shen.newpv V2859) (do (shen.bindv V2636 (cons B ()) V2859) (let Result (let V2640 (shen.lazyderef (tl V2632) V2859) (if (= () V2640) (let Hyp (tl V2623) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (shen.lazyderef B V2859) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2640) (do (shen.bindv V2640 () V2859) (let Result (let Hyp (tl V2623) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (shen.lazyderef B V2859) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2640 V2859) Result))) false))) (do (shen.unbindv V2636 V2859) Result)))) false))) (if (shen.pvar? V2635) (do (shen.bindv V2635 * V2859) (let Result (let V2641 (shen.lazyderef (tl V2634) V2859) (if (cons? V2641) (let B (hd V2641) (let V2642 (shen.lazyderef (tl V2641) V2859) (if (= () V2642) (let V2643 (shen.lazyderef (tl V2632) V2859) (if (= () V2643) (let Hyp (tl V2623) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (shen.lazyderef B V2859) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2643) (do (shen.bindv V2643 () V2859) (let Result (let Hyp (tl V2623) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (shen.lazyderef B V2859) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2643 V2859) Result))) false))) (if (shen.pvar? V2642) (do (shen.bindv V2642 () V2859) (let Result (let V2644 (shen.lazyderef (tl V2632) V2859) (if (= () V2644) (let Hyp (tl V2623) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (shen.lazyderef B V2859) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2644) (do (shen.bindv V2644 () V2859) (let Result (let Hyp (tl V2623) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (shen.lazyderef B V2859) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2644 V2859) Result))) false))) (do (shen.unbindv V2642 V2859) Result))) false)))) (if (shen.pvar? V2641) (let B (shen.newpv V2859) (do (shen.bindv V2641 (cons B ()) V2859) (let Result (let V2645 (shen.lazyderef (tl V2632) V2859) (if (= () V2645) (let Hyp (tl V2623) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (shen.lazyderef B V2859) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2645) (do (shen.bindv V2645 () V2859) (let Result (let Hyp (tl V2623) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (shen.lazyderef B V2859) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2645 V2859) Result))) false))) (do (shen.unbindv V2641 V2859) Result)))) false))) (do (shen.unbindv V2635 V2859) Result))) false))) (if (shen.pvar? V2634) (let B (shen.newpv V2859) (do (shen.bindv V2634 (cons * (cons B ())) V2859) (let Result (let V2646 (shen.lazyderef (tl V2632) V2859) (if (= () V2646) (let Hyp (tl V2623) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (shen.lazyderef B V2859) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2646) (do (shen.bindv V2646 () V2859) (let Result (let Hyp (tl V2623) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (shen.lazyderef B V2859) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2646 V2859) Result))) false))) (do (shen.unbindv V2634 V2859) Result)))) false)))) (if (shen.pvar? V2633) (let A (shen.newpv V2859) (let B (shen.newpv V2859) (do (shen.bindv V2633 (cons A (cons * (cons B ()))) V2859) (let Result (let V2647 (shen.lazyderef (tl V2632) V2859) (if (= () V2647) (let Hyp (tl V2623) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (shen.lazyderef B V2859) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2647) (do (shen.bindv V2647 () V2859) (let Result (let Hyp (tl V2623) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (shen.lazyderef B V2859) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2647 V2859) Result))) false))) (do (shen.unbindv V2633 V2859) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2648 (shen.lazyderef V2857 V2859) (if (cons? V2648) (let V2649 (shen.lazyderef (hd V2648) V2859) (if (cons? V2649) (let V2650 (shen.lazyderef (hd V2649) V2859) (if (cons? V2650) (let V2651 (shen.lazyderef (hd V2650) V2859) (if (= @v V2651) (let V2652 (shen.lazyderef (tl V2650) V2859) (if (cons? V2652) (let X (hd V2652) (let V2653 (shen.lazyderef (tl V2652) V2859) (if (cons? V2653) (let Y (hd V2653) (let V2654 (shen.lazyderef (tl V2653) V2859) (if (= () V2654) (let V2655 (shen.lazyderef (tl V2649) V2859) (if (cons? V2655) (let V2656 (shen.lazyderef (hd V2655) V2859) (if (= : V2656) (let V2657 (shen.lazyderef (tl V2655) V2859) (if (cons? V2657) (let V2658 (shen.lazyderef (hd V2657) V2859) (if (cons? V2658) (let V2659 (shen.lazyderef (hd V2658) V2859) (if (= vector V2659) (let V2660 (shen.lazyderef (tl V2658) V2859) (if (cons? V2660) (let A (hd V2660) (let V2661 (shen.lazyderef (tl V2660) V2859) (if (= () V2661) (let V2662 (shen.lazyderef (tl V2657) V2859) (if (= () V2662) (let Hyp (tl V2648) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons vector (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2662) (do (shen.bindv V2662 () V2859) (let Result (let Hyp (tl V2648) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons vector (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2662 V2859) Result))) false))) (if (shen.pvar? V2661) (do (shen.bindv V2661 () V2859) (let Result (let V2663 (shen.lazyderef (tl V2657) V2859) (if (= () V2663) (let Hyp (tl V2648) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons vector (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2663) (do (shen.bindv V2663 () V2859) (let Result (let Hyp (tl V2648) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons vector (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2663 V2859) Result))) false))) (do (shen.unbindv V2661 V2859) Result))) false)))) (if (shen.pvar? V2660) (let A (shen.newpv V2859) (do (shen.bindv V2660 (cons A ()) V2859) (let Result (let V2664 (shen.lazyderef (tl V2657) V2859) (if (= () V2664) (let Hyp (tl V2648) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons vector (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2664) (do (shen.bindv V2664 () V2859) (let Result (let Hyp (tl V2648) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons vector (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2664 V2859) Result))) false))) (do (shen.unbindv V2660 V2859) Result)))) false))) (if (shen.pvar? V2659) (do (shen.bindv V2659 vector V2859) (let Result (let V2665 (shen.lazyderef (tl V2658) V2859) (if (cons? V2665) (let A (hd V2665) (let V2666 (shen.lazyderef (tl V2665) V2859) (if (= () V2666) (let V2667 (shen.lazyderef (tl V2657) V2859) (if (= () V2667) (let Hyp (tl V2648) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons vector (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2667) (do (shen.bindv V2667 () V2859) (let Result (let Hyp (tl V2648) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons vector (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2667 V2859) Result))) false))) (if (shen.pvar? V2666) (do (shen.bindv V2666 () V2859) (let Result (let V2668 (shen.lazyderef (tl V2657) V2859) (if (= () V2668) (let Hyp (tl V2648) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons vector (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2668) (do (shen.bindv V2668 () V2859) (let Result (let Hyp (tl V2648) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons vector (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2668 V2859) Result))) false))) (do (shen.unbindv V2666 V2859) Result))) false)))) (if (shen.pvar? V2665) (let A (shen.newpv V2859) (do (shen.bindv V2665 (cons A ()) V2859) (let Result (let V2669 (shen.lazyderef (tl V2657) V2859) (if (= () V2669) (let Hyp (tl V2648) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons vector (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2669) (do (shen.bindv V2669 () V2859) (let Result (let Hyp (tl V2648) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons vector (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2669 V2859) Result))) false))) (do (shen.unbindv V2665 V2859) Result)))) false))) (do (shen.unbindv V2659 V2859) Result))) false))) (if (shen.pvar? V2658) (let A (shen.newpv V2859) (do (shen.bindv V2658 (cons vector (cons A ())) V2859) (let Result (let V2670 (shen.lazyderef (tl V2657) V2859) (if (= () V2670) (let Hyp (tl V2648) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons vector (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2670) (do (shen.bindv V2670 () V2859) (let Result (let Hyp (tl V2648) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons (shen.lazyderef A V2859) ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons (cons vector (cons (shen.lazyderef A V2859) ())) ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2670 V2859) Result))) false))) (do (shen.unbindv V2658 V2859) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2671 (shen.lazyderef V2857 V2859) (if (cons? V2671) (let V2672 (shen.lazyderef (hd V2671) V2859) (if (cons? V2672) (let V2673 (shen.lazyderef (hd V2672) V2859) (if (cons? V2673) (let V2674 (shen.lazyderef (hd V2673) V2859) (if (= @s V2674) (let V2675 (shen.lazyderef (tl V2673) V2859) (if (cons? V2675) (let X (hd V2675) (let V2676 (shen.lazyderef (tl V2675) V2859) (if (cons? V2676) (let Y (hd V2676) (let V2677 (shen.lazyderef (tl V2676) V2859) (if (= () V2677) (let V2678 (shen.lazyderef (tl V2672) V2859) (if (cons? V2678) (let V2679 (shen.lazyderef (hd V2678) V2859) (if (= : V2679) (let V2680 (shen.lazyderef (tl V2678) V2859) (if (cons? V2680) (let V2681 (shen.lazyderef (hd V2680) V2859) (if (= string V2681) (let V2682 (shen.lazyderef (tl V2680) V2859) (if (= () V2682) (let Hyp (tl V2671) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons string ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2682) (do (shen.bindv V2682 () V2859) (let Result (let Hyp (tl V2671) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons string ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2682 V2859) Result))) false))) (if (shen.pvar? V2681) (do (shen.bindv V2681 string V2859) (let Result (let V2683 (shen.lazyderef (tl V2680) V2859) (if (= () V2683) (let Hyp (tl V2671) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons string ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (if (shen.pvar? V2683) (do (shen.bindv V2683 () V2859) (let Result (let Hyp (tl V2671) (do (shen.incinfs) (bind V2858 (cons (cons (shen.lazyderef X V2859) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2859) (cons : (cons string ()))) (shen.lazyderef Hyp V2859))) V2859 V2860))) (do (shen.unbindv V2683 V2859) Result))) false))) (do (shen.unbindv V2681 V2859) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V2684 (shen.lazyderef V2857 V2859) (if (cons? V2684) (let X (hd V2684) (let Hyp (tl V2684) (let NewHyps (shen.newpv V2859) (do (shen.incinfs) (bind V2858 (cons (shen.lazyderef X V2859) (shen.lazyderef NewHyps V2859)) V2859 (freeze (shen.t*-hyps Hyp NewHyps V2859 V2860))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2873 V2874 V2875 V2876) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2873 V2875)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2874 V2875) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user (value *language*)) (thaw V2876))))))))) (true (thaw V2876))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2877) (cond ((and (cons? V2877) (and (cons? (tl V2877)) (and (= : (hd (tl V2877))) (and (cons? (tl (tl V2877))) (= () (tl (tl (tl V2877)))))))) (shen.prhush (shen.app (hd V2877) (cn " : " (shen.app (hd (tl (tl V2877))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V2877 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2880 V2881) (cond ((= () V2880) shen.skip) ((cons? V2880) (do (shen.prhush (shen.app V2881 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2880)) (do (nl 1) (shen.show-assumptions (tl V2880) (+ V2881 1)))))) (true (shen.sys-error shen.show-assumptions))))

(defun shen.pause-for-user (V2886) (cond ((= "Common Lisp" V2886) (let I (FORMAT () "~C" (READ-CHAR)) (if (= I "a") (simple-error "input aborted
") (nl 1)))) (true (let I (shen.read-char) (if (= I "a") (simple-error "input aborted
") (nl 1))))))

(defun shen.read-char () (shen.read-char-h (read-byte (stinput)) 0))

(defun shen.read-char-h (V2889 V2890) (cond ((and (= -1 V2889) (= 0 V2890)) (shen.read-char-h (read-byte (stinput)) 1)) ((= 0 V2890) (shen.read-char-h (read-byte (stinput)) 0)) ((and (= -1 V2889) (= 1 V2890)) (shen.read-char-h (read-byte (stinput)) 1)) ((= 1 V2890) (n->string V2889)) (true (shen.sys-error shen.read-char-h))))

(defun shen.typedf? (V2891) (cons? (assoc V2891 (value shen.*signedfuncs*))))

(defun shen.sigf (V2892) (concat shen.type-signature-of- V2892))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2893 V2894 V2895 V2896) (let Case (let V2587 (shen.lazyderef V2894 V2895) (if (= number V2587) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2893 V2895)) V2895 V2896)) (if (shen.pvar? V2587) (do (shen.bindv V2587 number V2895) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2893 V2895)) V2895 V2896)) (do (shen.unbindv V2587 V2895) Result))) false))) (if (= Case false) (let Case (let V2588 (shen.lazyderef V2894 V2895) (if (= boolean V2588) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2893 V2895)) V2895 V2896)) (if (shen.pvar? V2588) (do (shen.bindv V2588 boolean V2895) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2893 V2895)) V2895 V2896)) (do (shen.unbindv V2588 V2895) Result))) false))) (if (= Case false) (let Case (let V2589 (shen.lazyderef V2894 V2895) (if (= string V2589) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2893 V2895)) V2895 V2896)) (if (shen.pvar? V2589) (do (shen.bindv V2589 string V2895) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2893 V2895)) V2895 V2896)) (do (shen.unbindv V2589 V2895) Result))) false))) (if (= Case false) (let Case (let V2590 (shen.lazyderef V2894 V2895) (if (= symbol V2590) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2893 V2895)) V2895 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2893 V2895))) V2895 V2896)))) (if (shen.pvar? V2590) (do (shen.bindv V2590 symbol V2895) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2893 V2895)) V2895 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2893 V2895))) V2895 V2896)))) (do (shen.unbindv V2590 V2895) Result))) false))) (if (= Case false) (let V2591 (shen.lazyderef V2893 V2895) (if (= () V2591) (let V2592 (shen.lazyderef V2894 V2895) (if (cons? V2592) (let V2593 (shen.lazyderef (hd V2592) V2895) (if (= list V2593) (let V2594 (shen.lazyderef (tl V2592) V2895) (if (cons? V2594) (let A (hd V2594) (let V2595 (shen.lazyderef (tl V2594) V2895) (if (= () V2595) (do (shen.incinfs) (thaw V2896)) (if (shen.pvar? V2595) (do (shen.bindv V2595 () V2895) (let Result (do (shen.incinfs) (thaw V2896)) (do (shen.unbindv V2595 V2895) Result))) false)))) (if (shen.pvar? V2594) (let A (shen.newpv V2895) (do (shen.bindv V2594 (cons A ()) V2895) (let Result (do (shen.incinfs) (thaw V2896)) (do (shen.unbindv V2594 V2895) Result)))) false))) (if (shen.pvar? V2593) (do (shen.bindv V2593 list V2895) (let Result (let V2596 (shen.lazyderef (tl V2592) V2895) (if (cons? V2596) (let A (hd V2596) (let V2597 (shen.lazyderef (tl V2596) V2895) (if (= () V2597) (do (shen.incinfs) (thaw V2896)) (if (shen.pvar? V2597) (do (shen.bindv V2597 () V2895) (let Result (do (shen.incinfs) (thaw V2896)) (do (shen.unbindv V2597 V2895) Result))) false)))) (if (shen.pvar? V2596) (let A (shen.newpv V2895) (do (shen.bindv V2596 (cons A ()) V2895) (let Result (do (shen.incinfs) (thaw V2896)) (do (shen.unbindv V2596 V2895) Result)))) false))) (do (shen.unbindv V2593 V2895) Result))) false))) (if (shen.pvar? V2592) (let A (shen.newpv V2895) (do (shen.bindv V2592 (cons list (cons A ())) V2895) (let Result (do (shen.incinfs) (thaw V2896)) (do (shen.unbindv V2592 V2895) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V2897 V2898 V2899 V2900 V2901) (let Case (let V2578 (shen.lazyderef V2899 V2900) (if (cons? V2578) (let V2579 (shen.lazyderef (hd V2578) V2900) (if (cons? V2579) (let Y (hd V2579) (let V2580 (shen.lazyderef (tl V2579) V2900) (if (cons? V2580) (let V2581 (shen.lazyderef (hd V2580) V2900) (if (= : V2581) (let V2582 (shen.lazyderef (tl V2580) V2900) (if (cons? V2582) (let B (hd V2582) (let V2583 (shen.lazyderef (tl V2582) V2900) (if (= () V2583) (do (shen.incinfs) (identical V2897 Y V2900 (freeze (unify! V2898 B V2900 V2901)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V2584 (shen.lazyderef V2899 V2900) (if (cons? V2584) (let Hyp (tl V2584) (do (shen.incinfs) (shen.by_hypothesis V2897 V2898 Hyp V2900 V2901))) false)) Case)))

(defun shen.t*-def (V2902 V2903 V2904 V2905 V2906) (let V2572 (shen.lazyderef V2902 V2905) (if (cons? V2572) (let V2573 (shen.lazyderef (hd V2572) V2905) (if (= define V2573) (let V2574 (shen.lazyderef (tl V2572) V2905) (if (cons? V2574) (let F (hd V2574) (let X (tl V2574) (let E (shen.newpv V2905) (do (shen.incinfs) (shen.t*-defh (compile shen.<sig+rules> X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V2903 V2904 V2905 V2906))))) false)) false)) false)))

(defun shen.t*-defh (V2907 V2908 V2909 V2910 V2911 V2912) (let V2568 (shen.lazyderef V2907 V2911) (if (cons? V2568) (let Sig (hd V2568) (let Rules (tl V2568) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue Sig) V2908 V2909 V2910 Rules V2911 V2912)))) false)))

(defun shen.t*-defhh (V2913 V2914 V2915 V2916 V2917 V2918 V2919 V2920) (do (shen.incinfs) (shen.t*-rules V2918 V2914 1 V2915 (cons (cons V2915 (cons : (cons V2914 ()))) V2917) V2919 (freeze (shen.memo V2915 V2913 V2916 V2919 V2920)))))

(defun shen.memo (V2921 V2922 V2923 V2924 V2925) (let Jnk (shen.newpv V2924) (do (shen.incinfs) (unify! V2923 V2922 V2924 (freeze (bind Jnk (declare (shen.lazyderef V2921 V2924) (shen.lazyderef V2923 V2924)) V2924 V2925))))))

(defun shen.<sig+rules> (V2930) (let Result (let Parse_shen.<signature> (shen.<signature> V2930) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.ue (V2931) (cond ((cons? V2931) (map shen.ue V2931)) ((variable? V2931) (concat && V2931)) (true V2931)))

(defun shen.ues (V2936) (cond ((shen.ue? V2936) (cons V2936 ())) ((cons? V2936) (union (shen.ues (hd V2936)) (shen.ues (tl V2936)))) (true ())))

(defun shen.ue? (V2937) (and (symbol? V2937) (shen.ue-h? (str V2937))))

(defun shen.ue-h? (V2944) (cond ((and (shen.+string? V2944) (and (= "&" (pos V2944 0)) (and (shen.+string? (tlstr V2944)) (= "&" (pos (tlstr V2944) 0))))) true) (true false)))

(defun shen.t*-rules (V2945 V2946 V2947 V2948 V2949 V2950 V2951) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2543 (shen.lazyderef V2945 V2950) (if (= () V2543) (do (shen.incinfs) (thaw V2951)) false)) (if (= Case false) (let Case (let V2544 (shen.lazyderef V2945 V2950) (if (cons? V2544) (let V2545 (shen.lazyderef (hd V2544) V2950) (if (cons? V2545) (let V2546 (shen.lazyderef (hd V2545) V2950) (if (= () V2546) (let V2547 (shen.lazyderef (tl V2545) V2950) (if (cons? V2547) (let Action (hd V2547) (let V2548 (shen.lazyderef (tl V2547) V2950) (if (= () V2548) (let Rules (tl V2544) (let V2549 (shen.lazyderef V2946 V2950) (if (cons? V2549) (let V2550 (shen.lazyderef (hd V2549) V2950) (if (= --> V2550) (let V2551 (shen.lazyderef (tl V2549) V2950) (if (cons? V2551) (let A (hd V2551) (let V2552 (shen.lazyderef (tl V2551) V2950) (if (= () V2552) (do (shen.incinfs) (shen.t*-rule (cons () (cons (shen.ue Action) ())) A V2949 V2950 (freeze (cut Throwcontrol V2950 (freeze (shen.t*-rules Rules A (+ V2947 1) V2948 V2949 V2950 V2951)))))) false))) false)) false)) false))) false))) false)) false)) false)) false)) (if (= Case false) (let Case (let V2553 (shen.lazyderef V2945 V2950) (if (cons? V2553) (let Rule (hd V2553) (let Rules (tl V2553) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V2946 V2949 V2950 (freeze (cut Throwcontrol V2950 (freeze (shen.t*-rules Rules V2946 (+ V2947 1) V2948 V2949 V2950 V2951)))))))) false)) (if (= Case false) (let Err (shen.newpv V2950) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2947 V2950) (cn " of " (shen.app (shen.lazyderef V2948 V2950) "" shen.a)) shen.a))) V2950 V2951))) Case)) Case)) Case)))))

(defun shen.t*-rule (V2952 V2953 V2954 V2955 V2956) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2525 (shen.lazyderef V2952 V2955) (if (cons? V2525) (let V2526 (shen.lazyderef (hd V2525) V2955) (if (= () V2526) (let V2527 (shen.lazyderef (tl V2525) V2955) (if (cons? V2527) (let Action (hd V2527) (let V2528 (shen.lazyderef (tl V2527) V2955) (if (= () V2528) (do (shen.incinfs) (cut Throwcontrol V2955 (freeze (shen.t*-action (shen.curry Action) V2953 V2954 V2955 V2956)))) false))) false)) false)) false)) (if (= Case false) (let V2529 (shen.lazyderef V2952 V2955) (if (cons? V2529) (let V2530 (shen.lazyderef (hd V2529) V2955) (if (cons? V2530) (let Pattern (hd V2530) (let Patterns (tl V2530) (let V2531 (shen.lazyderef (tl V2529) V2955) (if (cons? V2531) (let Action (hd V2531) (let V2532 (shen.lazyderef (tl V2531) V2955) (if (= () V2532) (let V2533 (shen.lazyderef V2953 V2955) (if (cons? V2533) (let A (hd V2533) (let V2534 (shen.lazyderef (tl V2533) V2955) (if (cons? V2534) (let V2535 (shen.lazyderef (hd V2534) V2955) (if (= --> V2535) (let V2536 (shen.lazyderef (tl V2534) V2955) (if (cons? V2536) (let B (hd V2536) (let V2537 (shen.lazyderef (tl V2536) V2955) (if (= () V2537) (do (shen.incinfs) (shen.t*-pattern Pattern A V2955 (freeze (cut Throwcontrol V2955 (freeze (shen.t*-rule (cons Patterns (cons Action ())) B (cons (cons Pattern (cons : (cons A ()))) V2954) V2955 V2956)))))) false))) false)) false)) false))) false)) false))) false)))) false)) false)) Case)))))

(defun shen.t*-action (V2957 V2958 V2959 V2960 V2961) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2502 (shen.lazyderef V2957 V2960) (if (cons? V2502) (let V2503 (shen.lazyderef (hd V2502) V2960) (if (= where V2503) (let V2504 (shen.lazyderef (tl V2502) V2960) (if (cons? V2504) (let P (hd V2504) (let V2505 (shen.lazyderef (tl V2504) V2960) (if (cons? V2505) (let Action (hd V2505) (let V2506 (shen.lazyderef (tl V2505) V2960) (if (= () V2506) (do (shen.incinfs) (cut Throwcontrol V2960 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V2959 V2960 (freeze (cut Throwcontrol V2960 (freeze (shen.t*-action Action V2958 (cons (cons P (cons : (cons verified ()))) V2959) V2960 V2961)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2507 (shen.lazyderef V2957 V2960) (if (cons? V2507) (let V2508 (shen.lazyderef (hd V2507) V2960) (if (= shen.choicepoint! V2508) (let V2509 (shen.lazyderef (tl V2507) V2960) (if (cons? V2509) (let V2510 (shen.lazyderef (hd V2509) V2960) (if (cons? V2510) (let V2511 (shen.lazyderef (hd V2510) V2960) (if (cons? V2511) (let V2512 (shen.lazyderef (hd V2511) V2960) (if (= fail-if V2512) (let V2513 (shen.lazyderef (tl V2511) V2960) (if (cons? V2513) (let F (hd V2513) (let V2514 (shen.lazyderef (tl V2513) V2960) (if (= () V2514) (let V2515 (shen.lazyderef (tl V2510) V2960) (if (cons? V2515) (let Action (hd V2515) (let V2516 (shen.lazyderef (tl V2515) V2960) (if (= () V2516) (let V2517 (shen.lazyderef (tl V2509) V2960) (if (= () V2517) (do (shen.incinfs) (cut Throwcontrol V2960 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V2958 V2959 V2960 V2961)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2518 (shen.lazyderef V2957 V2960) (if (cons? V2518) (let V2519 (shen.lazyderef (hd V2518) V2960) (if (= shen.choicepoint! V2519) (let V2520 (shen.lazyderef (tl V2518) V2960) (if (cons? V2520) (let Action (hd V2520) (let V2521 (shen.lazyderef (tl V2520) V2960) (if (= () V2521) (do (shen.incinfs) (cut Throwcontrol V2960 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V2958 V2959 V2960 V2961)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V2957 (cons : (cons V2958 ()))) V2959 V2960 V2961)) Case)) Case)) Case)))))

(defun shen.t*-pattern (V2962 V2963 V2964 V2965) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Hyp (shen.newpv V2964) (do (shen.incinfs) (shen.tms->hyp (shen.ues V2962) Hyp V2964 (freeze (cut Throwcontrol V2964 (freeze (shen.t* (cons V2962 (cons : (cons V2963 ()))) Hyp V2964 V2965))))))))))

(defun shen.tms->hyp (V2966 V2967 V2968 V2969) (let Case (let V2486 (shen.lazyderef V2966 V2968) (if (= () V2486) (let V2487 (shen.lazyderef V2967 V2968) (if (= () V2487) (do (shen.incinfs) (thaw V2969)) (if (shen.pvar? V2487) (do (shen.bindv V2487 () V2968) (let Result (do (shen.incinfs) (thaw V2969)) (do (shen.unbindv V2487 V2968) Result))) false))) false)) (if (= Case false) (let V2488 (shen.lazyderef V2966 V2968) (if (cons? V2488) (let Tm2483 (hd V2488) (let Tms (tl V2488) (let V2489 (shen.lazyderef V2967 V2968) (if (cons? V2489) (let V2490 (shen.lazyderef (hd V2489) V2968) (if (cons? V2490) (let Tm (hd V2490) (let V2491 (shen.lazyderef (tl V2490) V2968) (if (cons? V2491) (let V2492 (shen.lazyderef (hd V2491) V2968) (if (= : V2492) (let V2493 (shen.lazyderef (tl V2491) V2968) (if (cons? V2493) (let A (hd V2493) (let V2494 (shen.lazyderef (tl V2493) V2968) (if (= () V2494) (let Hyp (tl V2489) (do (shen.incinfs) (unify! Tm Tm2483 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969))))) (if (shen.pvar? V2494) (do (shen.bindv V2494 () V2968) (let Result (let Hyp (tl V2489) (do (shen.incinfs) (unify! Tm Tm2483 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969))))) (do (shen.unbindv V2494 V2968) Result))) false)))) (if (shen.pvar? V2493) (let A (shen.newpv V2968) (do (shen.bindv V2493 (cons A ()) V2968) (let Result (let Hyp (tl V2489) (do (shen.incinfs) (unify! Tm Tm2483 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969))))) (do (shen.unbindv V2493 V2968) Result)))) false))) (if (shen.pvar? V2492) (do (shen.bindv V2492 : V2968) (let Result (let V2495 (shen.lazyderef (tl V2491) V2968) (if (cons? V2495) (let A (hd V2495) (let V2496 (shen.lazyderef (tl V2495) V2968) (if (= () V2496) (let Hyp (tl V2489) (do (shen.incinfs) (unify! Tm Tm2483 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969))))) (if (shen.pvar? V2496) (do (shen.bindv V2496 () V2968) (let Result (let Hyp (tl V2489) (do (shen.incinfs) (unify! Tm Tm2483 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969))))) (do (shen.unbindv V2496 V2968) Result))) false)))) (if (shen.pvar? V2495) (let A (shen.newpv V2968) (do (shen.bindv V2495 (cons A ()) V2968) (let Result (let Hyp (tl V2489) (do (shen.incinfs) (unify! Tm Tm2483 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969))))) (do (shen.unbindv V2495 V2968) Result)))) false))) (do (shen.unbindv V2492 V2968) Result))) false))) (if (shen.pvar? V2491) (let A (shen.newpv V2968) (do (shen.bindv V2491 (cons : (cons A ())) V2968) (let Result (let Hyp (tl V2489) (do (shen.incinfs) (unify! Tm Tm2483 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969))))) (do (shen.unbindv V2491 V2968) Result)))) false)))) (if (shen.pvar? V2490) (let Tm (shen.newpv V2968) (let A (shen.newpv V2968) (do (shen.bindv V2490 (cons Tm (cons : (cons A ()))) V2968) (let Result (let Hyp (tl V2489) (do (shen.incinfs) (unify! Tm Tm2483 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969))))) (do (shen.unbindv V2490 V2968) Result))))) false))) (if (shen.pvar? V2489) (let Tm (shen.newpv V2968) (let A (shen.newpv V2968) (let Hyp (shen.newpv V2968) (do (shen.bindv V2489 (cons (cons Tm (cons : (cons A ()))) Hyp) V2968) (let Result (do (shen.incinfs) (unify! Tm Tm2483 V2968 (freeze (shen.tms->hyp Tms Hyp V2968 V2969)))) (do (shen.unbindv V2489 V2968) Result)))))) false))))) false)) Case)))

(defun findall (V2970 V2971 V2972 V2973 V2974) (let B (shen.newpv V2973) (let A (shen.newpv V2973) (do (shen.incinfs) (bind A (gensym shen.a) V2973 (freeze (bind B (set (shen.lazyderef A V2973) ()) V2973 (freeze (shen.findallhelp V2970 V2971 V2972 A V2973 V2974)))))))))

(defun shen.findallhelp (V2975 V2976 V2977 V2978 V2979 V2980) (let Case (do (shen.incinfs) (call V2976 V2979 (freeze (shen.remember V2978 V2975 V2979 (freeze (fwhen false V2979 V2980)))))) (if (= Case false) (do (shen.incinfs) (bind V2977 (value (shen.lazyderef V2978 V2979)) V2979 V2980)) Case)))

(defun shen.remember (V2981 V2982 V2983 V2984) (let B (shen.newpv V2983) (do (shen.incinfs) (bind B (set (shen.deref V2981 V2983) (cons (shen.deref V2982 V2983) (value (shen.deref V2981 V2983)))) V2983 V2984))))

(defun shen.t*-defcc (V2985 V2986 V2987 V2988 V2989) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2459 (shen.lazyderef V2985 V2988) (if (cons? V2459) (let V2460 (shen.lazyderef (hd V2459) V2988) (if (= defcc V2460) (let V2461 (shen.lazyderef (tl V2459) V2988) (if (cons? V2461) (let F (hd V2461) (let V2462 (shen.lazyderef (tl V2461) V2988) (if (cons? V2462) (let V2463 (shen.lazyderef (hd V2462) V2988) (if (= { V2463) (let V2464 (shen.lazyderef (tl V2462) V2988) (if (cons? V2464) (let V2465 (shen.lazyderef (hd V2464) V2988) (if (cons? V2465) (let V2466 (shen.lazyderef (hd V2465) V2988) (if (= list V2466) (let V2467 (shen.lazyderef (tl V2465) V2988) (if (cons? V2467) (let A (hd V2467) (let V2468 (shen.lazyderef (tl V2467) V2988) (if (= () V2468) (let V2469 (shen.lazyderef (tl V2464) V2988) (if (cons? V2469) (let V2470 (shen.lazyderef (hd V2469) V2988) (if (= ==> V2470) (let V2471 (shen.lazyderef (tl V2469) V2988) (if (cons? V2471) (let B (hd V2471) (let V2472 (shen.lazyderef (tl V2471) V2988) (if (cons? V2472) (let V2473 (shen.lazyderef (hd V2472) V2988) (if (= } V2473) (let Rest (tl V2472) (let Rest& (shen.newpv V2988) (let Rest&& (shen.newpv V2988) (let Rules (shen.newpv V2988) (let ListA&& (shen.newpv V2988) (let B&& (shen.newpv V2988) (let Sig (shen.newpv V2988) (let Declare (shen.newpv V2988) (do (shen.incinfs) (bind Sig (shen.ue (cons (cons list (cons (shen.lazyderef A V2988) ())) (cons ==> (cons (shen.lazyderef B V2988) ())))) V2988 (freeze (bind ListA&& (hd (shen.lazyderef Sig V2988)) V2988 (freeze (bind B&& (hd (tl (tl (shen.lazyderef Sig V2988)))) V2988 (freeze (bind Rest& (shen.plug-wildcards (shen.lazyderef Rest V2988)) V2988 (freeze (bind Rest&& (shen.ue (shen.lazyderef Rest& V2988)) V2988 (freeze (shen.get-rules Rules Rest&& V2988 (freeze (cut Throwcontrol V2988 (freeze (shen.tc-rules F Rules ListA&& B&& (cons (cons F (cons : (cons Sig ()))) V2987) 1 V2988 (freeze (unify V2986 (cons (cons list (cons A ())) (cons ==> (cons B ()))) V2988 (freeze (bind Declare (declare (shen.lazyderef F V2988) (cons (cons list (cons (shen.lazyderef A V2988) ())) (cons ==> (cons (shen.lazyderef B V2988) ())))) V2988 V2989)))))))))))))))))))))))))))) false)) false))) false)) false)) false)) false))) false)) false)) false)) false)) false)) false))) false)) false)) false)))))

(defun shen.plug-wildcards (V2990) (cond ((cons? V2990) (map shen.plug-wildcards V2990)) ((= V2990 _) (gensym (intern "X"))) (true V2990)))

(defun shen.get-rules (V2991 V2992 V2993 V2994) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2452 (shen.lazyderef V2991 V2993) (if (= () V2452) (let V2453 (shen.lazyderef V2992 V2993) (if (= () V2453) (do (shen.incinfs) (cut Throwcontrol V2993 V2994)) false)) (if (shen.pvar? V2452) (do (shen.bindv V2452 () V2993) (let Result (let V2454 (shen.lazyderef V2992 V2993) (if (= () V2454) (do (shen.incinfs) (cut Throwcontrol V2993 V2994)) false)) (do (shen.unbindv V2452 V2993) Result))) false))) (if (= Case false) (let V2455 (shen.lazyderef V2991 V2993) (if (cons? V2455) (let Rule (hd V2455) (let Rules (tl V2455) (let Other (shen.newpv V2993) (do (shen.incinfs) (shen.first-rule V2992 Rule Other V2993 (freeze (cut Throwcontrol V2993 (freeze (shen.get-rules Rules Other V2993 V2994))))))))) (if (shen.pvar? V2455) (let Rule (shen.newpv V2993) (let Rules (shen.newpv V2993) (do (shen.bindv V2455 (cons Rule Rules) V2993) (let Result (let Other (shen.newpv V2993) (do (shen.incinfs) (shen.first-rule V2992 Rule Other V2993 (freeze (cut Throwcontrol V2993 (freeze (shen.get-rules Rules Other V2993 V2994))))))) (do (shen.unbindv V2455 V2993) Result))))) false))) Case)))))

(defun shen.first-rule (V2995 V2996 V2997 V2998 V2999) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2445 (shen.lazyderef V2995 V2998) (if (cons? V2445) (let V2446 (shen.lazyderef (hd V2445) V2998) (if (= ; V2446) (let Other2440 (tl V2445) (let V2447 (shen.lazyderef V2996 V2998) (if (= () V2447) (do (shen.incinfs) (unify! V2997 Other2440 V2998 (freeze (cut Throwcontrol V2998 V2999)))) (if (shen.pvar? V2447) (do (shen.bindv V2447 () V2998) (let Result (do (shen.incinfs) (unify! V2997 Other2440 V2998 (freeze (cut Throwcontrol V2998 V2999)))) (do (shen.unbindv V2447 V2998) Result))) false)))) false)) false)) (if (= Case false) (let V2448 (shen.lazyderef V2995 V2998) (if (cons? V2448) (let X2441 (hd V2448) (let Rest (tl V2448) (let V2449 (shen.lazyderef V2996 V2998) (if (cons? V2449) (let X (hd V2449) (let Rule (tl V2449) (do (shen.incinfs) (unify! X X2441 V2998 (freeze (shen.first-rule Rest Rule V2997 V2998 V2999)))))) (if (shen.pvar? V2449) (let X (shen.newpv V2998) (let Rule (shen.newpv V2998) (do (shen.bindv V2449 (cons X Rule) V2998) (let Result (do (shen.incinfs) (unify! X X2441 V2998 (freeze (shen.first-rule Rest Rule V2997 V2998 V2999)))) (do (shen.unbindv V2449 V2998) Result))))) false))))) false)) Case)))))

(defun shen.tc-rules (V3000 V3001 V3002 V3003 V3004 V3005 V3006 V3007) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2434 (shen.lazyderef V3001 V3006) (if (= () V2434) (do (shen.incinfs) (thaw V3007)) false)) (if (= Case false) (let V2435 (shen.lazyderef V3001 V3006) (if (cons? V2435) (let Rule (hd V2435) (let Rules (tl V2435) (let V2436 (shen.lazyderef V3002 V3006) (if (cons? V2436) (let V2437 (shen.lazyderef (hd V2436) V3006) (if (= list V2437) (let V2438 (shen.lazyderef (tl V2436) V3006) (if (cons? V2438) (let A (hd V2438) (let V2439 (shen.lazyderef (tl V2438) V3006) (if (= () V2439) (let M (shen.newpv V3006) (do (shen.incinfs) (shen.tc-rule V3000 Rule A V3003 V3004 V3005 V3006 (freeze (bind M (+ (shen.deref V3005 V3006) 1) V3006 (freeze (cut Throwcontrol V3006 (freeze (shen.tc-rules V3000 Rules (cons list (cons A ())) V3003 V3004 M V3006 V3007))))))))) false))) false)) false)) false)))) false)) Case)))))

(defun shen.tc-rule (V3008 V3009 V3010 V3011 V3012 V3013 V3014 V3015) (let Case (do (shen.incinfs) (shen.check-defcc-rule V3009 V3010 V3011 V3012 V3014 V3015)) (if (= Case false) (let Err (shen.newpv V3014) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3013 V3014) (cn " of " (shen.app (shen.lazyderef V3008 V3014) "" shen.a)) shen.a))) V3014 V3015))) Case)))

(defun shen.check-defcc-rule (V3016 V3017 V3018 V3019 V3020 V3021) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Syntax (shen.newpv V3020) (let Semantics (shen.newpv V3020) (let SynHyps (shen.newpv V3020) (do (shen.incinfs) (shen.get-syntax+semantics Syntax Semantics V3016 V3020 (freeze (cut Throwcontrol V3020 (freeze (shen.syntax-hyps Syntax V3019 SynHyps V3017 V3020 (freeze (cut Throwcontrol V3020 (freeze (shen.syntax-check Syntax V3017 SynHyps V3020 (freeze (cut Throwcontrol V3020 (freeze (shen.semantics-check Semantics V3018 SynHyps V3020 V3021))))))))))))))))))))

(defun shen.syntax-hyps (V3022 V3023 V3024 V3025 V3026 V3027) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2407 (shen.lazyderef V3022 V3026) (if (= () V2407) (do (shen.incinfs) (unify! V3024 V3023 V3026 V3027)) false)) (if (= Case false) (let Case (let V2408 (shen.lazyderef V3022 V3026) (if (cons? V2408) (let X2401 (hd V2408) (let Y (tl V2408) (let V2409 (shen.lazyderef V3024 V3026) (if (cons? V2409) (let V2410 (shen.lazyderef (hd V2409) V3026) (if (cons? V2410) (let X (hd V2410) (let V2411 (shen.lazyderef (tl V2410) V3026) (if (cons? V2411) (let V2412 (shen.lazyderef (hd V2411) V3026) (if (= : V2412) (let V2413 (shen.lazyderef (tl V2411) V3026) (if (cons? V2413) (let A2402 (hd V2413) (let V2414 (shen.lazyderef (tl V2413) V3026) (if (= () V2414) (let SynHyps (tl V2409) (do (shen.incinfs) (unify! V3025 A2402 V3026 (freeze (unify! X X2401 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027))))))))))) (if (shen.pvar? V2414) (do (shen.bindv V2414 () V3026) (let Result (let SynHyps (tl V2409) (do (shen.incinfs) (unify! V3025 A2402 V3026 (freeze (unify! X X2401 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027))))))))))) (do (shen.unbindv V2414 V3026) Result))) false)))) (if (shen.pvar? V2413) (let A2402 (shen.newpv V3026) (do (shen.bindv V2413 (cons A2402 ()) V3026) (let Result (let SynHyps (tl V2409) (do (shen.incinfs) (unify! V3025 A2402 V3026 (freeze (unify! X X2401 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027))))))))))) (do (shen.unbindv V2413 V3026) Result)))) false))) (if (shen.pvar? V2412) (do (shen.bindv V2412 : V3026) (let Result (let V2415 (shen.lazyderef (tl V2411) V3026) (if (cons? V2415) (let A2402 (hd V2415) (let V2416 (shen.lazyderef (tl V2415) V3026) (if (= () V2416) (let SynHyps (tl V2409) (do (shen.incinfs) (unify! V3025 A2402 V3026 (freeze (unify! X X2401 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027))))))))))) (if (shen.pvar? V2416) (do (shen.bindv V2416 () V3026) (let Result (let SynHyps (tl V2409) (do (shen.incinfs) (unify! V3025 A2402 V3026 (freeze (unify! X X2401 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027))))))))))) (do (shen.unbindv V2416 V3026) Result))) false)))) (if (shen.pvar? V2415) (let A2402 (shen.newpv V3026) (do (shen.bindv V2415 (cons A2402 ()) V3026) (let Result (let SynHyps (tl V2409) (do (shen.incinfs) (unify! V3025 A2402 V3026 (freeze (unify! X X2401 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027))))))))))) (do (shen.unbindv V2415 V3026) Result)))) false))) (do (shen.unbindv V2412 V3026) Result))) false))) (if (shen.pvar? V2411) (let A2402 (shen.newpv V3026) (do (shen.bindv V2411 (cons : (cons A2402 ())) V3026) (let Result (let SynHyps (tl V2409) (do (shen.incinfs) (unify! V3025 A2402 V3026 (freeze (unify! X X2401 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027))))))))))) (do (shen.unbindv V2411 V3026) Result)))) false)))) (if (shen.pvar? V2410) (let X (shen.newpv V3026) (let A2402 (shen.newpv V3026) (do (shen.bindv V2410 (cons X (cons : (cons A2402 ()))) V3026) (let Result (let SynHyps (tl V2409) (do (shen.incinfs) (unify! V3025 A2402 V3026 (freeze (unify! X X2401 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027))))))))))) (do (shen.unbindv V2410 V3026) Result))))) false))) (if (shen.pvar? V2409) (let X (shen.newpv V3026) (let A2402 (shen.newpv V3026) (let SynHyps (shen.newpv V3026) (do (shen.bindv V2409 (cons (cons X (cons : (cons A2402 ()))) SynHyps) V3026) (let Result (do (shen.incinfs) (unify! V3025 A2402 V3026 (freeze (unify! X X2401 V3026 (freeze (fwhen (shen.ue? (shen.deref X V3026)) V3026 (freeze (cut Throwcontrol V3026 (freeze (shen.syntax-hyps Y V3023 SynHyps V3025 V3026 V3027)))))))))) (do (shen.unbindv V2409 V3026) Result)))))) false))))) false)) (if (= Case false) (let V2417 (shen.lazyderef V3022 V3026) (if (cons? V2417) (let Y (tl V2417) (do (shen.incinfs) (shen.syntax-hyps Y V3023 V3024 V3025 V3026 V3027))) false)) Case)) Case)))))

(defun shen.get-syntax+semantics (V3028 V3029 V3030 V3031 V3032) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2373 (shen.lazyderef V3028 V3031) (if (= () V2373) (let V2374 (shen.lazyderef V3030 V3031) (if (cons? V2374) (let V2375 (shen.lazyderef (hd V2374) V3031) (if (= := V2375) (let V2376 (shen.lazyderef (tl V2374) V3031) (if (cons? V2376) (let Semantics (hd V2376) (let V2377 (shen.lazyderef (tl V2376) V3031) (if (= () V2377) (do (shen.incinfs) (cut Throwcontrol V3031 (freeze (bind V3029 (shen.lazyderef Semantics V3031) V3031 V3032)))) false))) false)) false)) false)) (if (shen.pvar? V2373) (do (shen.bindv V2373 () V3031) (let Result (let V2378 (shen.lazyderef V3030 V3031) (if (cons? V2378) (let V2379 (shen.lazyderef (hd V2378) V3031) (if (= := V2379) (let V2380 (shen.lazyderef (tl V2378) V3031) (if (cons? V2380) (let Semantics (hd V2380) (let V2381 (shen.lazyderef (tl V2380) V3031) (if (= () V2381) (do (shen.incinfs) (cut Throwcontrol V3031 (freeze (bind V3029 (shen.lazyderef Semantics V3031) V3031 V3032)))) false))) false)) false)) false)) (do (shen.unbindv V2373 V3031) Result))) false))) (if (= Case false) (let Case (let V2382 (shen.lazyderef V3028 V3031) (if (= () V2382) (let V2383 (shen.lazyderef V3030 V3031) (if (cons? V2383) (let V2384 (shen.lazyderef (hd V2383) V3031) (if (= := V2384) (let V2385 (shen.lazyderef (tl V2383) V3031) (if (cons? V2385) (let Semantics (hd V2385) (let V2386 (shen.lazyderef (tl V2385) V3031) (if (cons? V2386) (let V2387 (shen.lazyderef (hd V2386) V3031) (if (= where V2387) (let V2388 (shen.lazyderef (tl V2386) V3031) (if (cons? V2388) (let G (hd V2388) (let V2389 (shen.lazyderef (tl V2388) V3031) (if (= () V2389) (do (shen.incinfs) (cut Throwcontrol V3031 (freeze (bind V3029 (cons where (cons (shen.lazyderef G V3031) (cons (shen.lazyderef Semantics V3031) ()))) V3031 V3032)))) false))) false)) false)) false))) false)) false)) false)) (if (shen.pvar? V2382) (do (shen.bindv V2382 () V3031) (let Result (let V2390 (shen.lazyderef V3030 V3031) (if (cons? V2390) (let V2391 (shen.lazyderef (hd V2390) V3031) (if (= := V2391) (let V2392 (shen.lazyderef (tl V2390) V3031) (if (cons? V2392) (let Semantics (hd V2392) (let V2393 (shen.lazyderef (tl V2392) V3031) (if (cons? V2393) (let V2394 (shen.lazyderef (hd V2393) V3031) (if (= where V2394) (let V2395 (shen.lazyderef (tl V2393) V3031) (if (cons? V2395) (let G (hd V2395) (let V2396 (shen.lazyderef (tl V2395) V3031) (if (= () V2396) (do (shen.incinfs) (cut Throwcontrol V3031 (freeze (bind V3029 (cons where (cons (shen.lazyderef G V3031) (cons (shen.lazyderef Semantics V3031) ()))) V3031 V3032)))) false))) false)) false)) false))) false)) false)) false)) (do (shen.unbindv V2382 V3031) Result))) false))) (if (= Case false) (let V2397 (shen.lazyderef V3028 V3031) (if (cons? V2397) (let X2369 (hd V2397) (let Syntax (tl V2397) (let V2398 (shen.lazyderef V3030 V3031) (if (cons? V2398) (let X (hd V2398) (let Rule (tl V2398) (do (shen.incinfs) (unify! X X2369 V3031 (freeze (shen.get-syntax+semantics Syntax V3029 Rule V3031 V3032)))))) false)))) (if (shen.pvar? V2397) (let X2369 (shen.newpv V3031) (let Syntax (shen.newpv V3031) (do (shen.bindv V2397 (cons X2369 Syntax) V3031) (let Result (let V2399 (shen.lazyderef V3030 V3031) (if (cons? V2399) (let X (hd V2399) (let Rule (tl V2399) (do (shen.incinfs) (unify! X X2369 V3031 (freeze (shen.get-syntax+semantics Syntax V3029 Rule V3031 V3032)))))) false)) (do (shen.unbindv V2397 V3031) Result))))) false))) Case)) Case)))))

(defun shen.syntax-check (V3033 V3034 V3035 V3036 V3037) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2366 (shen.lazyderef V3033 V3036) (if (= () V2366) (do (shen.incinfs) (thaw V3037)) false)) (if (= Case false) (let Case (let V2367 (shen.lazyderef V3033 V3036) (if (cons? V2367) (let X (hd V2367) (let Syntax (tl V2367) (let C (shen.newpv V3036) (let X&& (shen.newpv V3036) (let B (shen.newpv V3036) (do (shen.incinfs) (fwhen (shen.grammar_symbol? (shen.lazyderef X V3036)) V3036 (freeze (cut Throwcontrol V3036 (freeze (shen.t* (cons X (cons : (cons (cons (cons list (cons B ())) (cons ==> (cons C ()))) ()))) V3035 V3036 (freeze (cut Throwcontrol V3036 (freeze (bind X&& (concat && (shen.lazyderef X V3036)) V3036 (freeze (cut Throwcontrol V3036 (freeze (shen.t* (cons X&& (cons : (cons (cons list (cons V3034 ())) ()))) (cons (cons X&& (cons : (cons (cons list (cons B ())) ()))) V3035) V3036 (freeze (cut Throwcontrol V3036 (freeze (shen.syntax-check Syntax V3034 V3035 V3036 V3037))))))))))))))))))))))) false)) (if (= Case false) (let V2368 (shen.lazyderef V3033 V3036) (if (cons? V2368) (let X (hd V2368) (let Syntax (tl V2368) (do (shen.incinfs) (shen.t* (cons X (cons : (cons V3034 ()))) V3035 V3036 (freeze (cut Throwcontrol V3036 (freeze (shen.syntax-check Syntax V3034 V3035 V3036 V3037)))))))) false)) Case)) Case)))))

(defun shen.semantics-check (V3038 V3039 V3040 V3041 V3042) (let Semantics* (shen.newpv V3041) (do (shen.incinfs) (bind Semantics* (shen.curry (shen.rename-semantics (shen.deref V3038 V3041))) V3041 (freeze (shen.t* (cons Semantics* (cons : (cons V3039 ()))) V3040 V3041 V3042))))))

(defun shen.rename-semantics (V3043) (cond ((cons? V3043) (cons (shen.rename-semantics (hd V3043)) (shen.rename-semantics (tl V3043)))) ((shen.grammar_symbol? V3043) (cons shen.<-sem (cons V3043 ()))) (true V3043)))



