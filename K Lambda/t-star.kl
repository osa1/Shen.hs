"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.typecheck (V2786 V2787) (let Curry (shen.curry V2786) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V2787)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2788) (cond ((and (cons? V2788) (shen.special? (hd V2788))) (cons (hd V2788) (map shen.curry (tl V2788)))) ((and (cons? V2788) (and (cons? (tl V2788)) (shen.extraspecial? (hd V2788)))) V2788) ((and (cons? V2788) (and (cons? (tl V2788)) (cons? (tl (tl V2788))))) (shen.curry (cons (cons (hd V2788) (cons (hd (tl V2788)) ())) (tl (tl V2788))))) ((and (cons? V2788) (and (cons? (tl V2788)) (= () (tl (tl V2788))))) (cons (shen.curry (hd V2788)) (cons (shen.curry (hd (tl V2788))) ()))) (true V2788)))

(defun shen.special? (V2789) (element? V2789 (value shen.*special*)))

(defun shen.extraspecial? (V2790) (element? V2790 (value shen.*extraspecial*)))

(defun shen.t* (V2791 V2792 V2793 V2794) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2793) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2793 (freeze (bind Error (shen.errormaxinfs) V2793 V2794))))) (if (= Case false) (let Case (let V2780 (shen.lazyderef V2791 V2793) (if (= fail V2780) (do (shen.incinfs) (cut Throwcontrol V2793 (freeze (shen.prolog-failure V2793 V2794)))) false)) (if (= Case false) (let Case (let V2781 (shen.lazyderef V2791 V2793) (if (cons? V2781) (let X (hd V2781) (let V2782 (shen.lazyderef (tl V2781) V2793) (if (cons? V2782) (let V2783 (shen.lazyderef (hd V2782) V2793) (if (= : V2783) (let V2784 (shen.lazyderef (tl V2782) V2793) (if (cons? V2784) (let A (hd V2784) (let V2785 (shen.lazyderef (tl V2784) V2793) (if (= () V2785) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2793 (freeze (cut Throwcontrol V2793 (freeze (shen.th* X A V2792 V2793 V2794)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2793) (do (shen.incinfs) (shen.show V2791 V2792 V2793 (freeze (bind Datatypes (value shen.*datatypes*) V2793 (freeze (shen.udefs* V2791 V2792 Datatypes V2793 V2794))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2799) (cond ((= + V2799) (set shen.*shen-type-theory-enabled?* true)) ((= - V2799) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2808 V2809) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2810 V2811 V2812 V2813 V2814) (let Case (let V2776 (shen.lazyderef V2812 V2813) (if (cons? V2776) (let D (hd V2776) (do (shen.incinfs) (call (cons D (cons V2810 (cons V2811 ()))) V2813 V2814))) false)) (if (= Case false) (let V2777 (shen.lazyderef V2812 V2813) (if (cons? V2777) (let Ds (tl V2777) (do (shen.incinfs) (shen.udefs* V2810 V2811 Ds V2813 V2814))) false)) Case)))

(defun shen.th* (V2815 V2816 V2817 V2818 V2819) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2815 (cons : (cons V2816 ()))) V2817 V2818 (freeze (fwhen false V2818 V2819)))) (if (= Case false) (let Case (let F (shen.newpv V2818) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2815 V2818)) V2818 (freeze (bind F (shen.sigf (shen.lazyderef V2815 V2818)) V2818 (freeze (call (cons F (cons V2816 ())) V2818 V2819))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2815 V2816 V2818 V2819)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2815 V2816 V2817 V2818 V2819)) (if (= Case false) (let Case (let V2656 (shen.lazyderef V2815 V2818) (if (cons? V2656) (let F (hd V2656) (let V2657 (shen.lazyderef (tl V2656) V2818) (if (= () V2657) (do (shen.incinfs) (shen.th* F (cons --> (cons V2816 ())) V2817 V2818 V2819)) false))) false)) (if (= Case false) (let Case (let V2658 (shen.lazyderef V2815 V2818) (if (cons? V2658) (let F (hd V2658) (let V2659 (shen.lazyderef (tl V2658) V2818) (if (cons? V2659) (let X (hd V2659) (let V2660 (shen.lazyderef (tl V2659) V2818) (if (= () V2660) (let B (shen.newpv V2818) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2816 ()))) V2817 V2818 (freeze (shen.th* X B V2817 V2818 V2819))))) false))) false))) false)) (if (= Case false) (let Case (let V2661 (shen.lazyderef V2815 V2818) (if (cons? V2661) (let V2662 (shen.lazyderef (hd V2661) V2818) (if (= cons V2662) (let V2663 (shen.lazyderef (tl V2661) V2818) (if (cons? V2663) (let X (hd V2663) (let V2664 (shen.lazyderef (tl V2663) V2818) (if (cons? V2664) (let Y (hd V2664) (let V2665 (shen.lazyderef (tl V2664) V2818) (if (= () V2665) (let V2666 (shen.lazyderef V2816 V2818) (if (cons? V2666) (let V2667 (shen.lazyderef (hd V2666) V2818) (if (= list V2667) (let V2668 (shen.lazyderef (tl V2666) V2818) (if (cons? V2668) (let A (hd V2668) (let V2669 (shen.lazyderef (tl V2668) V2818) (if (= () V2669) (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y (cons list (cons A ())) V2817 V2818 V2819)))) (if (shen.pvar? V2669) (do (shen.bindv V2669 () V2818) (let Result (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y (cons list (cons A ())) V2817 V2818 V2819)))) (do (shen.unbindv V2669 V2818) Result))) false)))) (if (shen.pvar? V2668) (let A (shen.newpv V2818) (do (shen.bindv V2668 (cons A ()) V2818) (let Result (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y (cons list (cons A ())) V2817 V2818 V2819)))) (do (shen.unbindv V2668 V2818) Result)))) false))) (if (shen.pvar? V2667) (do (shen.bindv V2667 list V2818) (let Result (let V2670 (shen.lazyderef (tl V2666) V2818) (if (cons? V2670) (let A (hd V2670) (let V2671 (shen.lazyderef (tl V2670) V2818) (if (= () V2671) (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y (cons list (cons A ())) V2817 V2818 V2819)))) (if (shen.pvar? V2671) (do (shen.bindv V2671 () V2818) (let Result (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y (cons list (cons A ())) V2817 V2818 V2819)))) (do (shen.unbindv V2671 V2818) Result))) false)))) (if (shen.pvar? V2670) (let A (shen.newpv V2818) (do (shen.bindv V2670 (cons A ()) V2818) (let Result (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y (cons list (cons A ())) V2817 V2818 V2819)))) (do (shen.unbindv V2670 V2818) Result)))) false))) (do (shen.unbindv V2667 V2818) Result))) false))) (if (shen.pvar? V2666) (let A (shen.newpv V2818) (do (shen.bindv V2666 (cons list (cons A ())) V2818) (let Result (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y (cons list (cons A ())) V2817 V2818 V2819)))) (do (shen.unbindv V2666 V2818) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2672 (shen.lazyderef V2815 V2818) (if (cons? V2672) (let V2673 (shen.lazyderef (hd V2672) V2818) (if (= @p V2673) (let V2674 (shen.lazyderef (tl V2672) V2818) (if (cons? V2674) (let X (hd V2674) (let V2675 (shen.lazyderef (tl V2674) V2818) (if (cons? V2675) (let Y (hd V2675) (let V2676 (shen.lazyderef (tl V2675) V2818) (if (= () V2676) (let V2677 (shen.lazyderef V2816 V2818) (if (cons? V2677) (let A (hd V2677) (let V2678 (shen.lazyderef (tl V2677) V2818) (if (cons? V2678) (let V2679 (shen.lazyderef (hd V2678) V2818) (if (= * V2679) (let V2680 (shen.lazyderef (tl V2678) V2818) (if (cons? V2680) (let B (hd V2680) (let V2681 (shen.lazyderef (tl V2680) V2818) (if (= () V2681) (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y B V2817 V2818 V2819)))) (if (shen.pvar? V2681) (do (shen.bindv V2681 () V2818) (let Result (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y B V2817 V2818 V2819)))) (do (shen.unbindv V2681 V2818) Result))) false)))) (if (shen.pvar? V2680) (let B (shen.newpv V2818) (do (shen.bindv V2680 (cons B ()) V2818) (let Result (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y B V2817 V2818 V2819)))) (do (shen.unbindv V2680 V2818) Result)))) false))) (if (shen.pvar? V2679) (do (shen.bindv V2679 * V2818) (let Result (let V2682 (shen.lazyderef (tl V2678) V2818) (if (cons? V2682) (let B (hd V2682) (let V2683 (shen.lazyderef (tl V2682) V2818) (if (= () V2683) (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y B V2817 V2818 V2819)))) (if (shen.pvar? V2683) (do (shen.bindv V2683 () V2818) (let Result (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y B V2817 V2818 V2819)))) (do (shen.unbindv V2683 V2818) Result))) false)))) (if (shen.pvar? V2682) (let B (shen.newpv V2818) (do (shen.bindv V2682 (cons B ()) V2818) (let Result (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y B V2817 V2818 V2819)))) (do (shen.unbindv V2682 V2818) Result)))) false))) (do (shen.unbindv V2679 V2818) Result))) false))) (if (shen.pvar? V2678) (let B (shen.newpv V2818) (do (shen.bindv V2678 (cons * (cons B ())) V2818) (let Result (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y B V2817 V2818 V2819)))) (do (shen.unbindv V2678 V2818) Result)))) false)))) (if (shen.pvar? V2677) (let A (shen.newpv V2818) (let B (shen.newpv V2818) (do (shen.bindv V2677 (cons A (cons * (cons B ()))) V2818) (let Result (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y B V2817 V2818 V2819)))) (do (shen.unbindv V2677 V2818) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2684 (shen.lazyderef V2815 V2818) (if (cons? V2684) (let V2685 (shen.lazyderef (hd V2684) V2818) (if (= @v V2685) (let V2686 (shen.lazyderef (tl V2684) V2818) (if (cons? V2686) (let X (hd V2686) (let V2687 (shen.lazyderef (tl V2686) V2818) (if (cons? V2687) (let Y (hd V2687) (let V2688 (shen.lazyderef (tl V2687) V2818) (if (= () V2688) (let V2689 (shen.lazyderef V2816 V2818) (if (cons? V2689) (let V2690 (shen.lazyderef (hd V2689) V2818) (if (= vector V2690) (let V2691 (shen.lazyderef (tl V2689) V2818) (if (cons? V2691) (let A (hd V2691) (let V2692 (shen.lazyderef (tl V2691) V2818) (if (= () V2692) (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y (cons vector (cons A ())) V2817 V2818 V2819)))) (if (shen.pvar? V2692) (do (shen.bindv V2692 () V2818) (let Result (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y (cons vector (cons A ())) V2817 V2818 V2819)))) (do (shen.unbindv V2692 V2818) Result))) false)))) (if (shen.pvar? V2691) (let A (shen.newpv V2818) (do (shen.bindv V2691 (cons A ()) V2818) (let Result (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y (cons vector (cons A ())) V2817 V2818 V2819)))) (do (shen.unbindv V2691 V2818) Result)))) false))) (if (shen.pvar? V2690) (do (shen.bindv V2690 vector V2818) (let Result (let V2693 (shen.lazyderef (tl V2689) V2818) (if (cons? V2693) (let A (hd V2693) (let V2694 (shen.lazyderef (tl V2693) V2818) (if (= () V2694) (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y (cons vector (cons A ())) V2817 V2818 V2819)))) (if (shen.pvar? V2694) (do (shen.bindv V2694 () V2818) (let Result (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y (cons vector (cons A ())) V2817 V2818 V2819)))) (do (shen.unbindv V2694 V2818) Result))) false)))) (if (shen.pvar? V2693) (let A (shen.newpv V2818) (do (shen.bindv V2693 (cons A ()) V2818) (let Result (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y (cons vector (cons A ())) V2817 V2818 V2819)))) (do (shen.unbindv V2693 V2818) Result)))) false))) (do (shen.unbindv V2690 V2818) Result))) false))) (if (shen.pvar? V2689) (let A (shen.newpv V2818) (do (shen.bindv V2689 (cons vector (cons A ())) V2818) (let Result (do (shen.incinfs) (shen.th* X A V2817 V2818 (freeze (shen.th* Y (cons vector (cons A ())) V2817 V2818 V2819)))) (do (shen.unbindv V2689 V2818) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2695 (shen.lazyderef V2815 V2818) (if (cons? V2695) (let V2696 (shen.lazyderef (hd V2695) V2818) (if (= @s V2696) (let V2697 (shen.lazyderef (tl V2695) V2818) (if (cons? V2697) (let X (hd V2697) (let V2698 (shen.lazyderef (tl V2697) V2818) (if (cons? V2698) (let Y (hd V2698) (let V2699 (shen.lazyderef (tl V2698) V2818) (if (= () V2699) (let V2700 (shen.lazyderef V2816 V2818) (if (= string V2700) (do (shen.incinfs) (shen.th* X string V2817 V2818 (freeze (shen.th* Y string V2817 V2818 V2819)))) (if (shen.pvar? V2700) (do (shen.bindv V2700 string V2818) (let Result (do (shen.incinfs) (shen.th* X string V2817 V2818 (freeze (shen.th* Y string V2817 V2818 V2819)))) (do (shen.unbindv V2700 V2818) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2701 (shen.lazyderef V2815 V2818) (if (cons? V2701) (let V2702 (shen.lazyderef (hd V2701) V2818) (if (= lambda V2702) (let V2703 (shen.lazyderef (tl V2701) V2818) (if (cons? V2703) (let X (hd V2703) (let V2704 (shen.lazyderef (tl V2703) V2818) (if (cons? V2704) (let Y (hd V2704) (let V2705 (shen.lazyderef (tl V2704) V2818) (if (= () V2705) (let V2706 (shen.lazyderef V2816 V2818) (if (cons? V2706) (let A (hd V2706) (let V2707 (shen.lazyderef (tl V2706) V2818) (if (cons? V2707) (let V2708 (shen.lazyderef (hd V2707) V2818) (if (= --> V2708) (let V2709 (shen.lazyderef (tl V2707) V2818) (if (cons? V2709) (let B (hd V2709) (let V2710 (shen.lazyderef (tl V2709) V2818) (if (= () V2710) (let Z (shen.newpv V2818) (let X&& (shen.newpv V2818) (do (shen.incinfs) (cut Throwcontrol V2818 (freeze (bind X&& (shen.placeholder) V2818 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2818) (shen.lazyderef X V2818) (shen.lazyderef Y V2818)) V2818 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2817) V2818 V2819)))))))))) (if (shen.pvar? V2710) (do (shen.bindv V2710 () V2818) (let Result (let Z (shen.newpv V2818) (let X&& (shen.newpv V2818) (do (shen.incinfs) (cut Throwcontrol V2818 (freeze (bind X&& (shen.placeholder) V2818 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2818) (shen.lazyderef X V2818) (shen.lazyderef Y V2818)) V2818 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2817) V2818 V2819)))))))))) (do (shen.unbindv V2710 V2818) Result))) false)))) (if (shen.pvar? V2709) (let B (shen.newpv V2818) (do (shen.bindv V2709 (cons B ()) V2818) (let Result (let Z (shen.newpv V2818) (let X&& (shen.newpv V2818) (do (shen.incinfs) (cut Throwcontrol V2818 (freeze (bind X&& (shen.placeholder) V2818 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2818) (shen.lazyderef X V2818) (shen.lazyderef Y V2818)) V2818 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2817) V2818 V2819)))))))))) (do (shen.unbindv V2709 V2818) Result)))) false))) (if (shen.pvar? V2708) (do (shen.bindv V2708 --> V2818) (let Result (let V2711 (shen.lazyderef (tl V2707) V2818) (if (cons? V2711) (let B (hd V2711) (let V2712 (shen.lazyderef (tl V2711) V2818) (if (= () V2712) (let Z (shen.newpv V2818) (let X&& (shen.newpv V2818) (do (shen.incinfs) (cut Throwcontrol V2818 (freeze (bind X&& (shen.placeholder) V2818 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2818) (shen.lazyderef X V2818) (shen.lazyderef Y V2818)) V2818 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2817) V2818 V2819)))))))))) (if (shen.pvar? V2712) (do (shen.bindv V2712 () V2818) (let Result (let Z (shen.newpv V2818) (let X&& (shen.newpv V2818) (do (shen.incinfs) (cut Throwcontrol V2818 (freeze (bind X&& (shen.placeholder) V2818 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2818) (shen.lazyderef X V2818) (shen.lazyderef Y V2818)) V2818 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2817) V2818 V2819)))))))))) (do (shen.unbindv V2712 V2818) Result))) false)))) (if (shen.pvar? V2711) (let B (shen.newpv V2818) (do (shen.bindv V2711 (cons B ()) V2818) (let Result (let Z (shen.newpv V2818) (let X&& (shen.newpv V2818) (do (shen.incinfs) (cut Throwcontrol V2818 (freeze (bind X&& (shen.placeholder) V2818 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2818) (shen.lazyderef X V2818) (shen.lazyderef Y V2818)) V2818 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2817) V2818 V2819)))))))))) (do (shen.unbindv V2711 V2818) Result)))) false))) (do (shen.unbindv V2708 V2818) Result))) false))) (if (shen.pvar? V2707) (let B (shen.newpv V2818) (do (shen.bindv V2707 (cons --> (cons B ())) V2818) (let Result (let Z (shen.newpv V2818) (let X&& (shen.newpv V2818) (do (shen.incinfs) (cut Throwcontrol V2818 (freeze (bind X&& (shen.placeholder) V2818 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2818) (shen.lazyderef X V2818) (shen.lazyderef Y V2818)) V2818 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2817) V2818 V2819)))))))))) (do (shen.unbindv V2707 V2818) Result)))) false)))) (if (shen.pvar? V2706) (let A (shen.newpv V2818) (let B (shen.newpv V2818) (do (shen.bindv V2706 (cons A (cons --> (cons B ()))) V2818) (let Result (let Z (shen.newpv V2818) (let X&& (shen.newpv V2818) (do (shen.incinfs) (cut Throwcontrol V2818 (freeze (bind X&& (shen.placeholder) V2818 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2818) (shen.lazyderef X V2818) (shen.lazyderef Y V2818)) V2818 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2817) V2818 V2819)))))))))) (do (shen.unbindv V2706 V2818) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2713 (shen.lazyderef V2815 V2818) (if (cons? V2713) (let V2714 (shen.lazyderef (hd V2713) V2818) (if (= let V2714) (let V2715 (shen.lazyderef (tl V2713) V2818) (if (cons? V2715) (let X (hd V2715) (let V2716 (shen.lazyderef (tl V2715) V2818) (if (cons? V2716) (let Y (hd V2716) (let V2717 (shen.lazyderef (tl V2716) V2818) (if (cons? V2717) (let Z (hd V2717) (let V2718 (shen.lazyderef (tl V2717) V2818) (if (= () V2718) (let W (shen.newpv V2818) (let X&& (shen.newpv V2818) (let B (shen.newpv V2818) (do (shen.incinfs) (cut Throwcontrol V2818 (freeze (shen.th* Y B V2817 V2818 (freeze (bind X&& (shen.placeholder) V2818 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2818) (shen.lazyderef X V2818) (shen.lazyderef Z V2818)) V2818 (freeze (shen.th* W V2816 (cons (cons X&& (cons : (cons B ()))) V2817) V2818 V2819))))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2719 (shen.lazyderef V2815 V2818) (if (cons? V2719) (let V2720 (shen.lazyderef (hd V2719) V2818) (if (= open V2720) (let V2721 (shen.lazyderef (tl V2719) V2818) (if (cons? V2721) (let V2722 (shen.lazyderef (hd V2721) V2818) (if (= file V2722) (let V2723 (shen.lazyderef (tl V2721) V2818) (if (cons? V2723) (let FileName (hd V2723) (let V2724 (shen.lazyderef (tl V2723) V2818) (if (cons? V2724) (let Direction2652 (hd V2724) (let V2725 (shen.lazyderef (tl V2724) V2818) (if (= () V2725) (let V2726 (shen.lazyderef V2816 V2818) (if (cons? V2726) (let V2727 (shen.lazyderef (hd V2726) V2818) (if (= stream V2727) (let V2728 (shen.lazyderef (tl V2726) V2818) (if (cons? V2728) (let Direction (hd V2728) (let V2729 (shen.lazyderef (tl V2728) V2818) (if (= () V2729) (do (shen.incinfs) (unify! Direction Direction2652 V2818 (freeze (cut Throwcontrol V2818 (freeze (shen.th* FileName string V2817 V2818 V2819)))))) (if (shen.pvar? V2729) (do (shen.bindv V2729 () V2818) (let Result (do (shen.incinfs) (unify! Direction Direction2652 V2818 (freeze (cut Throwcontrol V2818 (freeze (shen.th* FileName string V2817 V2818 V2819)))))) (do (shen.unbindv V2729 V2818) Result))) false)))) (if (shen.pvar? V2728) (let Direction (shen.newpv V2818) (do (shen.bindv V2728 (cons Direction ()) V2818) (let Result (do (shen.incinfs) (unify! Direction Direction2652 V2818 (freeze (cut Throwcontrol V2818 (freeze (shen.th* FileName string V2817 V2818 V2819)))))) (do (shen.unbindv V2728 V2818) Result)))) false))) (if (shen.pvar? V2727) (do (shen.bindv V2727 stream V2818) (let Result (let V2730 (shen.lazyderef (tl V2726) V2818) (if (cons? V2730) (let Direction (hd V2730) (let V2731 (shen.lazyderef (tl V2730) V2818) (if (= () V2731) (do (shen.incinfs) (unify! Direction Direction2652 V2818 (freeze (cut Throwcontrol V2818 (freeze (shen.th* FileName string V2817 V2818 V2819)))))) (if (shen.pvar? V2731) (do (shen.bindv V2731 () V2818) (let Result (do (shen.incinfs) (unify! Direction Direction2652 V2818 (freeze (cut Throwcontrol V2818 (freeze (shen.th* FileName string V2817 V2818 V2819)))))) (do (shen.unbindv V2731 V2818) Result))) false)))) (if (shen.pvar? V2730) (let Direction (shen.newpv V2818) (do (shen.bindv V2730 (cons Direction ()) V2818) (let Result (do (shen.incinfs) (unify! Direction Direction2652 V2818 (freeze (cut Throwcontrol V2818 (freeze (shen.th* FileName string V2817 V2818 V2819)))))) (do (shen.unbindv V2730 V2818) Result)))) false))) (do (shen.unbindv V2727 V2818) Result))) false))) (if (shen.pvar? V2726) (let Direction (shen.newpv V2818) (do (shen.bindv V2726 (cons stream (cons Direction ())) V2818) (let Result (do (shen.incinfs) (unify! Direction Direction2652 V2818 (freeze (cut Throwcontrol V2818 (freeze (shen.th* FileName string V2817 V2818 V2819)))))) (do (shen.unbindv V2726 V2818) Result)))) false))) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2732 (shen.lazyderef V2815 V2818) (if (cons? V2732) (let V2733 (shen.lazyderef (hd V2732) V2818) (if (= type V2733) (let V2734 (shen.lazyderef (tl V2732) V2818) (if (cons? V2734) (let X (hd V2734) (let V2735 (shen.lazyderef (tl V2734) V2818) (if (cons? V2735) (let A (hd V2735) (let V2736 (shen.lazyderef (tl V2735) V2818) (if (= () V2736) (do (shen.incinfs) (cut Throwcontrol V2818 (freeze (unify A V2816 V2818 (freeze (shen.th* X A V2817 V2818 V2819)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2737 (shen.lazyderef V2815 V2818) (if (cons? V2737) (let V2738 (shen.lazyderef (hd V2737) V2818) (if (= input+ V2738) (let V2739 (shen.lazyderef (tl V2737) V2818) (if (cons? V2739) (let V2740 (shen.lazyderef (hd V2739) V2818) (if (= : V2740) (let V2741 (shen.lazyderef (tl V2739) V2818) (if (cons? V2741) (let A (hd V2741) (let V2742 (shen.lazyderef (tl V2741) V2818) (if (= () V2742) (let C (shen.newpv V2818) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2818)) V2818 (freeze (unify V2816 C V2818 V2819))))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2743 (shen.lazyderef V2815 V2818) (if (cons? V2743) (let V2744 (shen.lazyderef (hd V2743) V2818) (if (= where V2744) (let V2745 (shen.lazyderef (tl V2743) V2818) (if (cons? V2745) (let P (hd V2745) (let V2746 (shen.lazyderef (tl V2745) V2818) (if (cons? V2746) (let X (hd V2746) (let V2747 (shen.lazyderef (tl V2746) V2818) (if (= () V2747) (do (shen.incinfs) (cut Throwcontrol V2818 (freeze (shen.th* P boolean V2817 V2818 (freeze (cut Throwcontrol V2818 (freeze (shen.th* X V2816 (cons (cons P (cons : (cons verified ()))) V2817) V2818 V2819)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2748 (shen.lazyderef V2815 V2818) (if (cons? V2748) (let V2749 (shen.lazyderef (hd V2748) V2818) (if (= set V2749) (let V2750 (shen.lazyderef (tl V2748) V2818) (if (cons? V2750) (let Var (hd V2750) (let V2751 (shen.lazyderef (tl V2750) V2818) (if (cons? V2751) (let Val (hd V2751) (let V2752 (shen.lazyderef (tl V2751) V2818) (if (= () V2752) (do (shen.incinfs) (cut Throwcontrol V2818 (freeze (shen.th* (cons value (cons Var ())) V2816 V2817 V2818 (freeze (shen.th* Val V2816 V2817 V2818 V2819)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2753 (shen.lazyderef V2815 V2818) (if (cons? V2753) (let V2754 (shen.lazyderef (hd V2753) V2818) (if (= shen.<-sem V2754) (let V2755 (shen.lazyderef (tl V2753) V2818) (if (cons? V2755) (let F (hd V2755) (let V2756 (shen.lazyderef (tl V2755) V2818) (if (= () V2756) (let A (shen.newpv V2818) (let F&& (shen.newpv V2818) (let B (shen.newpv V2818) (do (shen.incinfs) (cut Throwcontrol V2818 (freeze (shen.th* F (cons A (cons ==> (cons B ()))) V2817 V2818 (freeze (cut Throwcontrol V2818 (freeze (bind F&& (concat && (shen.lazyderef F V2818)) V2818 (freeze (cut Throwcontrol V2818 (freeze (shen.th* F&& V2816 (cons (cons F&& (cons : (cons B ()))) V2817) V2818 V2819))))))))))))))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2757 (shen.lazyderef V2815 V2818) (if (cons? V2757) (let V2758 (shen.lazyderef (hd V2757) V2818) (if (= fail V2758) (let V2759 (shen.lazyderef (tl V2757) V2818) (if (= () V2759) (let V2760 (shen.lazyderef V2816 V2818) (if (= symbol V2760) (do (shen.incinfs) (thaw V2819)) (if (shen.pvar? V2760) (do (shen.bindv V2760 symbol V2818) (let Result (do (shen.incinfs) (thaw V2819)) (do (shen.unbindv V2760 V2818) Result))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2818) (do (shen.incinfs) (shen.t*-hyps V2817 NewHyp V2818 (freeze (shen.th* V2815 V2816 NewHyp V2818 V2819))))) (if (= Case false) (let Case (let V2761 (shen.lazyderef V2815 V2818) (if (cons? V2761) (let V2762 (shen.lazyderef (hd V2761) V2818) (if (= define V2762) (let V2763 (shen.lazyderef (tl V2761) V2818) (if (cons? V2763) (let F (hd V2763) (let X (tl V2763) (do (shen.incinfs) (cut Throwcontrol V2818 (freeze (shen.t*-def (cons define (cons F X)) V2816 V2817 V2818 V2819)))))) false)) false)) false)) (if (= Case false) (let Case (let V2764 (shen.lazyderef V2815 V2818) (if (cons? V2764) (let V2765 (shen.lazyderef (hd V2764) V2818) (if (= defcc V2765) (let V2766 (shen.lazyderef (tl V2764) V2818) (if (cons? V2766) (let F (hd V2766) (let X (tl V2766) (do (shen.incinfs) (cut Throwcontrol V2818 (freeze (shen.t*-defcc (cons defcc (cons F X)) V2816 V2817 V2818 V2819)))))) false)) false)) false)) (if (= Case false) (let Case (let V2767 (shen.lazyderef V2815 V2818) (if (cons? V2767) (let V2768 (shen.lazyderef (hd V2767) V2818) (if (= shen.process-datatype V2768) (let V2769 (shen.lazyderef V2816 V2818) (if (= symbol V2769) (do (shen.incinfs) (thaw V2819)) (if (shen.pvar? V2769) (do (shen.bindv V2769 symbol V2818) (let Result (do (shen.incinfs) (thaw V2819)) (do (shen.unbindv V2769 V2818) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2770 (shen.lazyderef V2815 V2818) (if (cons? V2770) (let V2771 (shen.lazyderef (hd V2770) V2818) (if (= shen.synonyms-help V2771) (let V2772 (shen.lazyderef V2816 V2818) (if (= symbol V2772) (do (shen.incinfs) (thaw V2819)) (if (shen.pvar? V2772) (do (shen.bindv V2772 symbol V2818) (let Result (do (shen.incinfs) (thaw V2819)) (do (shen.unbindv V2772 V2818) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2818) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2818 (freeze (shen.udefs* (cons V2815 (cons : (cons V2816 ()))) V2817 Datatypes V2818 V2819))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2820 V2821 V2822 V2823) (let Case (let V2567 (shen.lazyderef V2820 V2822) (if (cons? V2567) (let V2568 (shen.lazyderef (hd V2567) V2822) (if (cons? V2568) (let V2569 (shen.lazyderef (hd V2568) V2822) (if (cons? V2569) (let V2570 (shen.lazyderef (hd V2569) V2822) (if (= cons V2570) (let V2571 (shen.lazyderef (tl V2569) V2822) (if (cons? V2571) (let X (hd V2571) (let V2572 (shen.lazyderef (tl V2571) V2822) (if (cons? V2572) (let Y (hd V2572) (let V2573 (shen.lazyderef (tl V2572) V2822) (if (= () V2573) (let V2574 (shen.lazyderef (tl V2568) V2822) (if (cons? V2574) (let V2575 (shen.lazyderef (hd V2574) V2822) (if (= : V2575) (let V2576 (shen.lazyderef (tl V2574) V2822) (if (cons? V2576) (let V2577 (shen.lazyderef (hd V2576) V2822) (if (cons? V2577) (let V2578 (shen.lazyderef (hd V2577) V2822) (if (= list V2578) (let V2579 (shen.lazyderef (tl V2577) V2822) (if (cons? V2579) (let A (hd V2579) (let V2580 (shen.lazyderef (tl V2579) V2822) (if (= () V2580) (let V2581 (shen.lazyderef (tl V2576) V2822) (if (= () V2581) (let Hyp (tl V2567) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons list (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2581) (do (shen.bindv V2581 () V2822) (let Result (let Hyp (tl V2567) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons list (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2581 V2822) Result))) false))) (if (shen.pvar? V2580) (do (shen.bindv V2580 () V2822) (let Result (let V2582 (shen.lazyderef (tl V2576) V2822) (if (= () V2582) (let Hyp (tl V2567) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons list (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2582) (do (shen.bindv V2582 () V2822) (let Result (let Hyp (tl V2567) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons list (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2582 V2822) Result))) false))) (do (shen.unbindv V2580 V2822) Result))) false)))) (if (shen.pvar? V2579) (let A (shen.newpv V2822) (do (shen.bindv V2579 (cons A ()) V2822) (let Result (let V2583 (shen.lazyderef (tl V2576) V2822) (if (= () V2583) (let Hyp (tl V2567) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons list (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2583) (do (shen.bindv V2583 () V2822) (let Result (let Hyp (tl V2567) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons list (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2583 V2822) Result))) false))) (do (shen.unbindv V2579 V2822) Result)))) false))) (if (shen.pvar? V2578) (do (shen.bindv V2578 list V2822) (let Result (let V2584 (shen.lazyderef (tl V2577) V2822) (if (cons? V2584) (let A (hd V2584) (let V2585 (shen.lazyderef (tl V2584) V2822) (if (= () V2585) (let V2586 (shen.lazyderef (tl V2576) V2822) (if (= () V2586) (let Hyp (tl V2567) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons list (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2586) (do (shen.bindv V2586 () V2822) (let Result (let Hyp (tl V2567) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons list (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2586 V2822) Result))) false))) (if (shen.pvar? V2585) (do (shen.bindv V2585 () V2822) (let Result (let V2587 (shen.lazyderef (tl V2576) V2822) (if (= () V2587) (let Hyp (tl V2567) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons list (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2587) (do (shen.bindv V2587 () V2822) (let Result (let Hyp (tl V2567) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons list (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2587 V2822) Result))) false))) (do (shen.unbindv V2585 V2822) Result))) false)))) (if (shen.pvar? V2584) (let A (shen.newpv V2822) (do (shen.bindv V2584 (cons A ()) V2822) (let Result (let V2588 (shen.lazyderef (tl V2576) V2822) (if (= () V2588) (let Hyp (tl V2567) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons list (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2588) (do (shen.bindv V2588 () V2822) (let Result (let Hyp (tl V2567) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons list (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2588 V2822) Result))) false))) (do (shen.unbindv V2584 V2822) Result)))) false))) (do (shen.unbindv V2578 V2822) Result))) false))) (if (shen.pvar? V2577) (let A (shen.newpv V2822) (do (shen.bindv V2577 (cons list (cons A ())) V2822) (let Result (let V2589 (shen.lazyderef (tl V2576) V2822) (if (= () V2589) (let Hyp (tl V2567) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons list (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2589) (do (shen.bindv V2589 () V2822) (let Result (let Hyp (tl V2567) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons list (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2589 V2822) Result))) false))) (do (shen.unbindv V2577 V2822) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2590 (shen.lazyderef V2820 V2822) (if (cons? V2590) (let V2591 (shen.lazyderef (hd V2590) V2822) (if (cons? V2591) (let V2592 (shen.lazyderef (hd V2591) V2822) (if (cons? V2592) (let V2593 (shen.lazyderef (hd V2592) V2822) (if (= @p V2593) (let V2594 (shen.lazyderef (tl V2592) V2822) (if (cons? V2594) (let X (hd V2594) (let V2595 (shen.lazyderef (tl V2594) V2822) (if (cons? V2595) (let Y (hd V2595) (let V2596 (shen.lazyderef (tl V2595) V2822) (if (= () V2596) (let V2597 (shen.lazyderef (tl V2591) V2822) (if (cons? V2597) (let V2598 (shen.lazyderef (hd V2597) V2822) (if (= : V2598) (let V2599 (shen.lazyderef (tl V2597) V2822) (if (cons? V2599) (let V2600 (shen.lazyderef (hd V2599) V2822) (if (cons? V2600) (let A (hd V2600) (let V2601 (shen.lazyderef (tl V2600) V2822) (if (cons? V2601) (let V2602 (shen.lazyderef (hd V2601) V2822) (if (= * V2602) (let V2603 (shen.lazyderef (tl V2601) V2822) (if (cons? V2603) (let B (hd V2603) (let V2604 (shen.lazyderef (tl V2603) V2822) (if (= () V2604) (let V2605 (shen.lazyderef (tl V2599) V2822) (if (= () V2605) (let Hyp (tl V2590) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (shen.lazyderef B V2822) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2605) (do (shen.bindv V2605 () V2822) (let Result (let Hyp (tl V2590) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (shen.lazyderef B V2822) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2605 V2822) Result))) false))) (if (shen.pvar? V2604) (do (shen.bindv V2604 () V2822) (let Result (let V2606 (shen.lazyderef (tl V2599) V2822) (if (= () V2606) (let Hyp (tl V2590) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (shen.lazyderef B V2822) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2606) (do (shen.bindv V2606 () V2822) (let Result (let Hyp (tl V2590) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (shen.lazyderef B V2822) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2606 V2822) Result))) false))) (do (shen.unbindv V2604 V2822) Result))) false)))) (if (shen.pvar? V2603) (let B (shen.newpv V2822) (do (shen.bindv V2603 (cons B ()) V2822) (let Result (let V2607 (shen.lazyderef (tl V2599) V2822) (if (= () V2607) (let Hyp (tl V2590) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (shen.lazyderef B V2822) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2607) (do (shen.bindv V2607 () V2822) (let Result (let Hyp (tl V2590) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (shen.lazyderef B V2822) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2607 V2822) Result))) false))) (do (shen.unbindv V2603 V2822) Result)))) false))) (if (shen.pvar? V2602) (do (shen.bindv V2602 * V2822) (let Result (let V2608 (shen.lazyderef (tl V2601) V2822) (if (cons? V2608) (let B (hd V2608) (let V2609 (shen.lazyderef (tl V2608) V2822) (if (= () V2609) (let V2610 (shen.lazyderef (tl V2599) V2822) (if (= () V2610) (let Hyp (tl V2590) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (shen.lazyderef B V2822) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2610) (do (shen.bindv V2610 () V2822) (let Result (let Hyp (tl V2590) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (shen.lazyderef B V2822) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2610 V2822) Result))) false))) (if (shen.pvar? V2609) (do (shen.bindv V2609 () V2822) (let Result (let V2611 (shen.lazyderef (tl V2599) V2822) (if (= () V2611) (let Hyp (tl V2590) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (shen.lazyderef B V2822) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2611) (do (shen.bindv V2611 () V2822) (let Result (let Hyp (tl V2590) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (shen.lazyderef B V2822) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2611 V2822) Result))) false))) (do (shen.unbindv V2609 V2822) Result))) false)))) (if (shen.pvar? V2608) (let B (shen.newpv V2822) (do (shen.bindv V2608 (cons B ()) V2822) (let Result (let V2612 (shen.lazyderef (tl V2599) V2822) (if (= () V2612) (let Hyp (tl V2590) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (shen.lazyderef B V2822) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2612) (do (shen.bindv V2612 () V2822) (let Result (let Hyp (tl V2590) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (shen.lazyderef B V2822) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2612 V2822) Result))) false))) (do (shen.unbindv V2608 V2822) Result)))) false))) (do (shen.unbindv V2602 V2822) Result))) false))) (if (shen.pvar? V2601) (let B (shen.newpv V2822) (do (shen.bindv V2601 (cons * (cons B ())) V2822) (let Result (let V2613 (shen.lazyderef (tl V2599) V2822) (if (= () V2613) (let Hyp (tl V2590) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (shen.lazyderef B V2822) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2613) (do (shen.bindv V2613 () V2822) (let Result (let Hyp (tl V2590) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (shen.lazyderef B V2822) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2613 V2822) Result))) false))) (do (shen.unbindv V2601 V2822) Result)))) false)))) (if (shen.pvar? V2600) (let A (shen.newpv V2822) (let B (shen.newpv V2822) (do (shen.bindv V2600 (cons A (cons * (cons B ()))) V2822) (let Result (let V2614 (shen.lazyderef (tl V2599) V2822) (if (= () V2614) (let Hyp (tl V2590) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (shen.lazyderef B V2822) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2614) (do (shen.bindv V2614 () V2822) (let Result (let Hyp (tl V2590) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (shen.lazyderef B V2822) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2614 V2822) Result))) false))) (do (shen.unbindv V2600 V2822) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2615 (shen.lazyderef V2820 V2822) (if (cons? V2615) (let V2616 (shen.lazyderef (hd V2615) V2822) (if (cons? V2616) (let V2617 (shen.lazyderef (hd V2616) V2822) (if (cons? V2617) (let V2618 (shen.lazyderef (hd V2617) V2822) (if (= @v V2618) (let V2619 (shen.lazyderef (tl V2617) V2822) (if (cons? V2619) (let X (hd V2619) (let V2620 (shen.lazyderef (tl V2619) V2822) (if (cons? V2620) (let Y (hd V2620) (let V2621 (shen.lazyderef (tl V2620) V2822) (if (= () V2621) (let V2622 (shen.lazyderef (tl V2616) V2822) (if (cons? V2622) (let V2623 (shen.lazyderef (hd V2622) V2822) (if (= : V2623) (let V2624 (shen.lazyderef (tl V2622) V2822) (if (cons? V2624) (let V2625 (shen.lazyderef (hd V2624) V2822) (if (cons? V2625) (let V2626 (shen.lazyderef (hd V2625) V2822) (if (= vector V2626) (let V2627 (shen.lazyderef (tl V2625) V2822) (if (cons? V2627) (let A (hd V2627) (let V2628 (shen.lazyderef (tl V2627) V2822) (if (= () V2628) (let V2629 (shen.lazyderef (tl V2624) V2822) (if (= () V2629) (let Hyp (tl V2615) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons vector (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2629) (do (shen.bindv V2629 () V2822) (let Result (let Hyp (tl V2615) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons vector (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2629 V2822) Result))) false))) (if (shen.pvar? V2628) (do (shen.bindv V2628 () V2822) (let Result (let V2630 (shen.lazyderef (tl V2624) V2822) (if (= () V2630) (let Hyp (tl V2615) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons vector (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2630) (do (shen.bindv V2630 () V2822) (let Result (let Hyp (tl V2615) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons vector (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2630 V2822) Result))) false))) (do (shen.unbindv V2628 V2822) Result))) false)))) (if (shen.pvar? V2627) (let A (shen.newpv V2822) (do (shen.bindv V2627 (cons A ()) V2822) (let Result (let V2631 (shen.lazyderef (tl V2624) V2822) (if (= () V2631) (let Hyp (tl V2615) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons vector (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2631) (do (shen.bindv V2631 () V2822) (let Result (let Hyp (tl V2615) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons vector (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2631 V2822) Result))) false))) (do (shen.unbindv V2627 V2822) Result)))) false))) (if (shen.pvar? V2626) (do (shen.bindv V2626 vector V2822) (let Result (let V2632 (shen.lazyderef (tl V2625) V2822) (if (cons? V2632) (let A (hd V2632) (let V2633 (shen.lazyderef (tl V2632) V2822) (if (= () V2633) (let V2634 (shen.lazyderef (tl V2624) V2822) (if (= () V2634) (let Hyp (tl V2615) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons vector (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2634) (do (shen.bindv V2634 () V2822) (let Result (let Hyp (tl V2615) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons vector (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2634 V2822) Result))) false))) (if (shen.pvar? V2633) (do (shen.bindv V2633 () V2822) (let Result (let V2635 (shen.lazyderef (tl V2624) V2822) (if (= () V2635) (let Hyp (tl V2615) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons vector (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2635) (do (shen.bindv V2635 () V2822) (let Result (let Hyp (tl V2615) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons vector (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2635 V2822) Result))) false))) (do (shen.unbindv V2633 V2822) Result))) false)))) (if (shen.pvar? V2632) (let A (shen.newpv V2822) (do (shen.bindv V2632 (cons A ()) V2822) (let Result (let V2636 (shen.lazyderef (tl V2624) V2822) (if (= () V2636) (let Hyp (tl V2615) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons vector (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2636) (do (shen.bindv V2636 () V2822) (let Result (let Hyp (tl V2615) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons vector (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2636 V2822) Result))) false))) (do (shen.unbindv V2632 V2822) Result)))) false))) (do (shen.unbindv V2626 V2822) Result))) false))) (if (shen.pvar? V2625) (let A (shen.newpv V2822) (do (shen.bindv V2625 (cons vector (cons A ())) V2822) (let Result (let V2637 (shen.lazyderef (tl V2624) V2822) (if (= () V2637) (let Hyp (tl V2615) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons vector (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2637) (do (shen.bindv V2637 () V2822) (let Result (let Hyp (tl V2615) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons (shen.lazyderef A V2822) ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons (cons vector (cons (shen.lazyderef A V2822) ())) ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2637 V2822) Result))) false))) (do (shen.unbindv V2625 V2822) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2638 (shen.lazyderef V2820 V2822) (if (cons? V2638) (let V2639 (shen.lazyderef (hd V2638) V2822) (if (cons? V2639) (let V2640 (shen.lazyderef (hd V2639) V2822) (if (cons? V2640) (let V2641 (shen.lazyderef (hd V2640) V2822) (if (= @s V2641) (let V2642 (shen.lazyderef (tl V2640) V2822) (if (cons? V2642) (let X (hd V2642) (let V2643 (shen.lazyderef (tl V2642) V2822) (if (cons? V2643) (let Y (hd V2643) (let V2644 (shen.lazyderef (tl V2643) V2822) (if (= () V2644) (let V2645 (shen.lazyderef (tl V2639) V2822) (if (cons? V2645) (let V2646 (shen.lazyderef (hd V2645) V2822) (if (= : V2646) (let V2647 (shen.lazyderef (tl V2645) V2822) (if (cons? V2647) (let V2648 (shen.lazyderef (hd V2647) V2822) (if (= string V2648) (let V2649 (shen.lazyderef (tl V2647) V2822) (if (= () V2649) (let Hyp (tl V2638) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons string ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2649) (do (shen.bindv V2649 () V2822) (let Result (let Hyp (tl V2638) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons string ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2649 V2822) Result))) false))) (if (shen.pvar? V2648) (do (shen.bindv V2648 string V2822) (let Result (let V2650 (shen.lazyderef (tl V2647) V2822) (if (= () V2650) (let Hyp (tl V2638) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons string ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (if (shen.pvar? V2650) (do (shen.bindv V2650 () V2822) (let Result (let Hyp (tl V2638) (do (shen.incinfs) (bind V2821 (cons (cons (shen.lazyderef X V2822) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2822) (cons : (cons string ()))) (shen.lazyderef Hyp V2822))) V2822 V2823))) (do (shen.unbindv V2650 V2822) Result))) false))) (do (shen.unbindv V2648 V2822) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V2651 (shen.lazyderef V2820 V2822) (if (cons? V2651) (let X (hd V2651) (let Hyp (tl V2651) (let NewHyps (shen.newpv V2822) (do (shen.incinfs) (bind V2821 (cons (shen.lazyderef X V2822) (shen.lazyderef NewHyps V2822)) V2822 (freeze (shen.t*-hyps Hyp NewHyps V2822 V2823))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2836 V2837 V2838 V2839) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2836 V2838)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2837 V2838) 1) (do (pr "
> " (stoutput)) (do (shen.pause-for-user (value *language*)) (thaw V2839))))))))) (true (thaw V2839))))

(defun shen.line () (let Infs (inferences) (pr (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2840) (cond ((and (cons? V2840) (and (cons? (tl V2840)) (and (= : (hd (tl V2840))) (and (cons? (tl (tl V2840))) (= () (tl (tl (tl V2840)))))))) (pr (shen.app (hd V2840) (cn " : " (shen.app (hd (tl (tl V2840))) "" shen.r)) shen.r) (stoutput))) (true (pr (shen.app V2840 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2843 V2844) (cond ((= () V2843) shen.skip) ((cons? V2843) (do (pr (shen.app V2844 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2843)) (do (nl 1) (shen.show-assumptions (tl V2843) (+ V2844 1)))))) (true (shen.sys-error shen.show-assumptions))))

(defun shen.pause-for-user (V2849) (cond ((= "Common Lisp" V2849) (let I (FORMAT () "~C" (READ-CHAR)) (if (= I "a") (simple-error "input aborted
") (nl 1)))) (true (let I (shen.read-char) (if (= I "a") (simple-error "input aborted
") (nl 1))))))

(defun shen.read-char () (shen.read-char-h (read-byte (stinput)) 0))

(defun shen.read-char-h (V2852 V2853) (cond ((and (= -1 V2852) (= 0 V2853)) (shen.read-char-h (read-byte (stinput)) 1)) ((= 0 V2853) (shen.read-char-h (read-byte (stinput)) 0)) ((and (= -1 V2852) (= 1 V2853)) (shen.read-char-h (read-byte (stinput)) 1)) ((= 1 V2853) (n->string V2852)) (true (shen.sys-error shen.read-char-h))))

(defun shen.typedf? (V2854) (element? V2854 (value shen.*signedfuncs*)))

(defun shen.sigf (V2855) (concat shen.type-signature-of- V2855))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2856 V2857 V2858 V2859) (let Case (let V2554 (shen.lazyderef V2857 V2858) (if (= number V2554) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2856 V2858)) V2858 V2859)) (if (shen.pvar? V2554) (do (shen.bindv V2554 number V2858) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2856 V2858)) V2858 V2859)) (do (shen.unbindv V2554 V2858) Result))) false))) (if (= Case false) (let Case (let V2555 (shen.lazyderef V2857 V2858) (if (= boolean V2555) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2856 V2858)) V2858 V2859)) (if (shen.pvar? V2555) (do (shen.bindv V2555 boolean V2858) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2856 V2858)) V2858 V2859)) (do (shen.unbindv V2555 V2858) Result))) false))) (if (= Case false) (let Case (let V2556 (shen.lazyderef V2857 V2858) (if (= string V2556) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2856 V2858)) V2858 V2859)) (if (shen.pvar? V2556) (do (shen.bindv V2556 string V2858) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2856 V2858)) V2858 V2859)) (do (shen.unbindv V2556 V2858) Result))) false))) (if (= Case false) (let Case (let V2557 (shen.lazyderef V2857 V2858) (if (= symbol V2557) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2856 V2858)) V2858 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2856 V2858))) V2858 V2859)))) (if (shen.pvar? V2557) (do (shen.bindv V2557 symbol V2858) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2856 V2858)) V2858 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2856 V2858))) V2858 V2859)))) (do (shen.unbindv V2557 V2858) Result))) false))) (if (= Case false) (let V2558 (shen.lazyderef V2856 V2858) (if (= () V2558) (let V2559 (shen.lazyderef V2857 V2858) (if (cons? V2559) (let V2560 (shen.lazyderef (hd V2559) V2858) (if (= list V2560) (let V2561 (shen.lazyderef (tl V2559) V2858) (if (cons? V2561) (let A (hd V2561) (let V2562 (shen.lazyderef (tl V2561) V2858) (if (= () V2562) (do (shen.incinfs) (thaw V2859)) (if (shen.pvar? V2562) (do (shen.bindv V2562 () V2858) (let Result (do (shen.incinfs) (thaw V2859)) (do (shen.unbindv V2562 V2858) Result))) false)))) (if (shen.pvar? V2561) (let A (shen.newpv V2858) (do (shen.bindv V2561 (cons A ()) V2858) (let Result (do (shen.incinfs) (thaw V2859)) (do (shen.unbindv V2561 V2858) Result)))) false))) (if (shen.pvar? V2560) (do (shen.bindv V2560 list V2858) (let Result (let V2563 (shen.lazyderef (tl V2559) V2858) (if (cons? V2563) (let A (hd V2563) (let V2564 (shen.lazyderef (tl V2563) V2858) (if (= () V2564) (do (shen.incinfs) (thaw V2859)) (if (shen.pvar? V2564) (do (shen.bindv V2564 () V2858) (let Result (do (shen.incinfs) (thaw V2859)) (do (shen.unbindv V2564 V2858) Result))) false)))) (if (shen.pvar? V2563) (let A (shen.newpv V2858) (do (shen.bindv V2563 (cons A ()) V2858) (let Result (do (shen.incinfs) (thaw V2859)) (do (shen.unbindv V2563 V2858) Result)))) false))) (do (shen.unbindv V2560 V2858) Result))) false))) (if (shen.pvar? V2559) (let A (shen.newpv V2858) (do (shen.bindv V2559 (cons list (cons A ())) V2858) (let Result (do (shen.incinfs) (thaw V2859)) (do (shen.unbindv V2559 V2858) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V2860 V2861 V2862 V2863 V2864) (let Case (let V2545 (shen.lazyderef V2862 V2863) (if (cons? V2545) (let V2546 (shen.lazyderef (hd V2545) V2863) (if (cons? V2546) (let Y (hd V2546) (let V2547 (shen.lazyderef (tl V2546) V2863) (if (cons? V2547) (let V2548 (shen.lazyderef (hd V2547) V2863) (if (= : V2548) (let V2549 (shen.lazyderef (tl V2547) V2863) (if (cons? V2549) (let B (hd V2549) (let V2550 (shen.lazyderef (tl V2549) V2863) (if (= () V2550) (do (shen.incinfs) (identical V2860 Y V2863 (freeze (unify! V2861 B V2863 V2864)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V2551 (shen.lazyderef V2862 V2863) (if (cons? V2551) (let Hyp (tl V2551) (do (shen.incinfs) (shen.by_hypothesis V2860 V2861 Hyp V2863 V2864))) false)) Case)))

(defun shen.t*-def (V2865 V2866 V2867 V2868 V2869) (let V2539 (shen.lazyderef V2865 V2868) (if (cons? V2539) (let V2540 (shen.lazyderef (hd V2539) V2868) (if (= define V2540) (let V2541 (shen.lazyderef (tl V2539) V2868) (if (cons? V2541) (let F (hd V2541) (let X (tl V2541) (let E (shen.newpv V2868) (do (shen.incinfs) (shen.t*-defh (compile shen.<sig+rules> X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V2866 V2867 V2868 V2869))))) false)) false)) false)))

(defun shen.t*-defh (V2870 V2871 V2872 V2873 V2874 V2875) (let V2535 (shen.lazyderef V2870 V2874) (if (cons? V2535) (let Sig (hd V2535) (let Rules (tl V2535) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue Sig) V2871 V2872 V2873 Rules V2874 V2875)))) false)))

(defun shen.t*-defhh (V2876 V2877 V2878 V2879 V2880 V2881 V2882 V2883) (do (shen.incinfs) (shen.t*-rules V2881 V2877 1 V2878 (cons (cons V2878 (cons : (cons V2877 ()))) V2880) V2882 (freeze (shen.memo V2878 V2876 V2879 V2882 V2883)))))

(defun shen.memo (V2884 V2885 V2886 V2887 V2888) (let Jnk (shen.newpv V2887) (do (shen.incinfs) (unify! V2886 V2885 V2887 (freeze (bind Jnk (declare (shen.lazyderef V2884 V2887) (shen.lazyderef V2886 V2887)) V2887 V2888))))))

(defun shen.<sig+rules> (V2893) (let Result (let Parse_shen.<signature> (shen.<signature> V2893) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.ue (V2894) (cond ((cons? V2894) (map shen.ue V2894)) ((variable? V2894) (concat && V2894)) (true V2894)))

(defun shen.ues (V2899) (cond ((shen.ue? V2899) (cons V2899 ())) ((cons? V2899) (union (shen.ues (hd V2899)) (shen.ues (tl V2899)))) (true ())))

(defun shen.ue? (V2900) (and (symbol? V2900) (shen.ue-h? (str V2900))))

(defun shen.ue-h? (V2907) (cond ((and (shen.+string? V2907) (and (= "&" (pos V2907 0)) (and (shen.+string? (tlstr V2907)) (= "&" (pos (tlstr V2907) 0))))) true) (true false)))

(defun shen.t*-rules (V2908 V2909 V2910 V2911 V2912 V2913 V2914) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2510 (shen.lazyderef V2908 V2913) (if (= () V2510) (do (shen.incinfs) (thaw V2914)) false)) (if (= Case false) (let Case (let V2511 (shen.lazyderef V2908 V2913) (if (cons? V2511) (let V2512 (shen.lazyderef (hd V2511) V2913) (if (cons? V2512) (let V2513 (shen.lazyderef (hd V2512) V2913) (if (= () V2513) (let V2514 (shen.lazyderef (tl V2512) V2913) (if (cons? V2514) (let Action (hd V2514) (let V2515 (shen.lazyderef (tl V2514) V2913) (if (= () V2515) (let Rules (tl V2511) (let V2516 (shen.lazyderef V2909 V2913) (if (cons? V2516) (let V2517 (shen.lazyderef (hd V2516) V2913) (if (= --> V2517) (let V2518 (shen.lazyderef (tl V2516) V2913) (if (cons? V2518) (let A (hd V2518) (let V2519 (shen.lazyderef (tl V2518) V2913) (if (= () V2519) (do (shen.incinfs) (shen.t*-rule (cons () (cons (shen.ue Action) ())) A V2912 V2913 (freeze (cut Throwcontrol V2913 (freeze (shen.t*-rules Rules A (+ V2910 1) V2911 V2912 V2913 V2914)))))) false))) false)) false)) false))) false))) false)) false)) false)) false)) (if (= Case false) (let Case (let V2520 (shen.lazyderef V2908 V2913) (if (cons? V2520) (let Rule (hd V2520) (let Rules (tl V2520) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V2909 V2912 V2913 (freeze (cut Throwcontrol V2913 (freeze (shen.t*-rules Rules V2909 (+ V2910 1) V2911 V2912 V2913 V2914)))))))) false)) (if (= Case false) (let Err (shen.newpv V2913) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2910 V2913) (cn " of " (shen.app (shen.lazyderef V2911 V2913) "" shen.a)) shen.a))) V2913 V2914))) Case)) Case)) Case)))))

(defun shen.t*-rule (V2915 V2916 V2917 V2918 V2919) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2492 (shen.lazyderef V2915 V2918) (if (cons? V2492) (let V2493 (shen.lazyderef (hd V2492) V2918) (if (= () V2493) (let V2494 (shen.lazyderef (tl V2492) V2918) (if (cons? V2494) (let Action (hd V2494) (let V2495 (shen.lazyderef (tl V2494) V2918) (if (= () V2495) (do (shen.incinfs) (cut Throwcontrol V2918 (freeze (shen.t*-action (shen.curry Action) V2916 V2917 V2918 V2919)))) false))) false)) false)) false)) (if (= Case false) (let V2496 (shen.lazyderef V2915 V2918) (if (cons? V2496) (let V2497 (shen.lazyderef (hd V2496) V2918) (if (cons? V2497) (let Pattern (hd V2497) (let Patterns (tl V2497) (let V2498 (shen.lazyderef (tl V2496) V2918) (if (cons? V2498) (let Action (hd V2498) (let V2499 (shen.lazyderef (tl V2498) V2918) (if (= () V2499) (let V2500 (shen.lazyderef V2916 V2918) (if (cons? V2500) (let A (hd V2500) (let V2501 (shen.lazyderef (tl V2500) V2918) (if (cons? V2501) (let V2502 (shen.lazyderef (hd V2501) V2918) (if (= --> V2502) (let V2503 (shen.lazyderef (tl V2501) V2918) (if (cons? V2503) (let B (hd V2503) (let V2504 (shen.lazyderef (tl V2503) V2918) (if (= () V2504) (do (shen.incinfs) (shen.t*-pattern Pattern A V2918 (freeze (cut Throwcontrol V2918 (freeze (shen.t*-rule (cons Patterns (cons Action ())) B (cons (cons Pattern (cons : (cons A ()))) V2917) V2918 V2919)))))) false))) false)) false)) false))) false)) false))) false)))) false)) false)) Case)))))

(defun shen.t*-action (V2920 V2921 V2922 V2923 V2924) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2469 (shen.lazyderef V2920 V2923) (if (cons? V2469) (let V2470 (shen.lazyderef (hd V2469) V2923) (if (= where V2470) (let V2471 (shen.lazyderef (tl V2469) V2923) (if (cons? V2471) (let P (hd V2471) (let V2472 (shen.lazyderef (tl V2471) V2923) (if (cons? V2472) (let Action (hd V2472) (let V2473 (shen.lazyderef (tl V2472) V2923) (if (= () V2473) (do (shen.incinfs) (cut Throwcontrol V2923 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V2922 V2923 (freeze (cut Throwcontrol V2923 (freeze (shen.t*-action Action V2921 (cons (cons P (cons : (cons verified ()))) V2922) V2923 V2924)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2474 (shen.lazyderef V2920 V2923) (if (cons? V2474) (let V2475 (shen.lazyderef (hd V2474) V2923) (if (= shen.choicepoint! V2475) (let V2476 (shen.lazyderef (tl V2474) V2923) (if (cons? V2476) (let V2477 (shen.lazyderef (hd V2476) V2923) (if (cons? V2477) (let V2478 (shen.lazyderef (hd V2477) V2923) (if (cons? V2478) (let V2479 (shen.lazyderef (hd V2478) V2923) (if (= fail-if V2479) (let V2480 (shen.lazyderef (tl V2478) V2923) (if (cons? V2480) (let F (hd V2480) (let V2481 (shen.lazyderef (tl V2480) V2923) (if (= () V2481) (let V2482 (shen.lazyderef (tl V2477) V2923) (if (cons? V2482) (let Action (hd V2482) (let V2483 (shen.lazyderef (tl V2482) V2923) (if (= () V2483) (let V2484 (shen.lazyderef (tl V2476) V2923) (if (= () V2484) (do (shen.incinfs) (cut Throwcontrol V2923 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V2921 V2922 V2923 V2924)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2485 (shen.lazyderef V2920 V2923) (if (cons? V2485) (let V2486 (shen.lazyderef (hd V2485) V2923) (if (= shen.choicepoint! V2486) (let V2487 (shen.lazyderef (tl V2485) V2923) (if (cons? V2487) (let Action (hd V2487) (let V2488 (shen.lazyderef (tl V2487) V2923) (if (= () V2488) (do (shen.incinfs) (cut Throwcontrol V2923 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V2921 V2922 V2923 V2924)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V2920 (cons : (cons V2921 ()))) V2922 V2923 V2924)) Case)) Case)) Case)))))

(defun shen.t*-pattern (V2925 V2926 V2927 V2928) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Hyp (shen.newpv V2927) (do (shen.incinfs) (shen.tms->hyp (shen.ues V2925) Hyp V2927 (freeze (cut Throwcontrol V2927 (freeze (shen.t* (cons V2925 (cons : (cons V2926 ()))) Hyp V2927 V2928))))))))))

(defun shen.tms->hyp (V2929 V2930 V2931 V2932) (let Case (let V2453 (shen.lazyderef V2929 V2931) (if (= () V2453) (let V2454 (shen.lazyderef V2930 V2931) (if (= () V2454) (do (shen.incinfs) (thaw V2932)) (if (shen.pvar? V2454) (do (shen.bindv V2454 () V2931) (let Result (do (shen.incinfs) (thaw V2932)) (do (shen.unbindv V2454 V2931) Result))) false))) false)) (if (= Case false) (let V2455 (shen.lazyderef V2929 V2931) (if (cons? V2455) (let Tm2450 (hd V2455) (let Tms (tl V2455) (let V2456 (shen.lazyderef V2930 V2931) (if (cons? V2456) (let V2457 (shen.lazyderef (hd V2456) V2931) (if (cons? V2457) (let Tm (hd V2457) (let V2458 (shen.lazyderef (tl V2457) V2931) (if (cons? V2458) (let V2459 (shen.lazyderef (hd V2458) V2931) (if (= : V2459) (let V2460 (shen.lazyderef (tl V2458) V2931) (if (cons? V2460) (let A (hd V2460) (let V2461 (shen.lazyderef (tl V2460) V2931) (if (= () V2461) (let Hyp (tl V2456) (do (shen.incinfs) (unify! Tm Tm2450 V2931 (freeze (shen.tms->hyp Tms Hyp V2931 V2932))))) (if (shen.pvar? V2461) (do (shen.bindv V2461 () V2931) (let Result (let Hyp (tl V2456) (do (shen.incinfs) (unify! Tm Tm2450 V2931 (freeze (shen.tms->hyp Tms Hyp V2931 V2932))))) (do (shen.unbindv V2461 V2931) Result))) false)))) (if (shen.pvar? V2460) (let A (shen.newpv V2931) (do (shen.bindv V2460 (cons A ()) V2931) (let Result (let Hyp (tl V2456) (do (shen.incinfs) (unify! Tm Tm2450 V2931 (freeze (shen.tms->hyp Tms Hyp V2931 V2932))))) (do (shen.unbindv V2460 V2931) Result)))) false))) (if (shen.pvar? V2459) (do (shen.bindv V2459 : V2931) (let Result (let V2462 (shen.lazyderef (tl V2458) V2931) (if (cons? V2462) (let A (hd V2462) (let V2463 (shen.lazyderef (tl V2462) V2931) (if (= () V2463) (let Hyp (tl V2456) (do (shen.incinfs) (unify! Tm Tm2450 V2931 (freeze (shen.tms->hyp Tms Hyp V2931 V2932))))) (if (shen.pvar? V2463) (do (shen.bindv V2463 () V2931) (let Result (let Hyp (tl V2456) (do (shen.incinfs) (unify! Tm Tm2450 V2931 (freeze (shen.tms->hyp Tms Hyp V2931 V2932))))) (do (shen.unbindv V2463 V2931) Result))) false)))) (if (shen.pvar? V2462) (let A (shen.newpv V2931) (do (shen.bindv V2462 (cons A ()) V2931) (let Result (let Hyp (tl V2456) (do (shen.incinfs) (unify! Tm Tm2450 V2931 (freeze (shen.tms->hyp Tms Hyp V2931 V2932))))) (do (shen.unbindv V2462 V2931) Result)))) false))) (do (shen.unbindv V2459 V2931) Result))) false))) (if (shen.pvar? V2458) (let A (shen.newpv V2931) (do (shen.bindv V2458 (cons : (cons A ())) V2931) (let Result (let Hyp (tl V2456) (do (shen.incinfs) (unify! Tm Tm2450 V2931 (freeze (shen.tms->hyp Tms Hyp V2931 V2932))))) (do (shen.unbindv V2458 V2931) Result)))) false)))) (if (shen.pvar? V2457) (let Tm (shen.newpv V2931) (let A (shen.newpv V2931) (do (shen.bindv V2457 (cons Tm (cons : (cons A ()))) V2931) (let Result (let Hyp (tl V2456) (do (shen.incinfs) (unify! Tm Tm2450 V2931 (freeze (shen.tms->hyp Tms Hyp V2931 V2932))))) (do (shen.unbindv V2457 V2931) Result))))) false))) (if (shen.pvar? V2456) (let Tm (shen.newpv V2931) (let A (shen.newpv V2931) (let Hyp (shen.newpv V2931) (do (shen.bindv V2456 (cons (cons Tm (cons : (cons A ()))) Hyp) V2931) (let Result (do (shen.incinfs) (unify! Tm Tm2450 V2931 (freeze (shen.tms->hyp Tms Hyp V2931 V2932)))) (do (shen.unbindv V2456 V2931) Result)))))) false))))) false)) Case)))

(defun findall (V2933 V2934 V2935 V2936 V2937) (let B (shen.newpv V2936) (let A (shen.newpv V2936) (do (shen.incinfs) (bind A (gensym shen.a) V2936 (freeze (bind B (set (shen.lazyderef A V2936) ()) V2936 (freeze (shen.findallhelp V2933 V2934 V2935 A V2936 V2937)))))))))

(defun shen.findallhelp (V2938 V2939 V2940 V2941 V2942 V2943) (let Case (do (shen.incinfs) (call V2939 V2942 (freeze (shen.remember V2941 V2938 V2942 (freeze (fwhen false V2942 V2943)))))) (if (= Case false) (do (shen.incinfs) (bind V2940 (value (shen.lazyderef V2941 V2942)) V2942 V2943)) Case)))

(defun shen.remember (V2944 V2945 V2946 V2947) (let B (shen.newpv V2946) (do (shen.incinfs) (bind B (set (shen.deref V2944 V2946) (cons (shen.deref V2945 V2946) (value (shen.deref V2944 V2946)))) V2946 V2947))))

(defun shen.t*-defcc (V2948 V2949 V2950 V2951 V2952) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2426 (shen.lazyderef V2948 V2951) (if (cons? V2426) (let V2427 (shen.lazyderef (hd V2426) V2951) (if (= defcc V2427) (let V2428 (shen.lazyderef (tl V2426) V2951) (if (cons? V2428) (let F (hd V2428) (let V2429 (shen.lazyderef (tl V2428) V2951) (if (cons? V2429) (let V2430 (shen.lazyderef (hd V2429) V2951) (if (= { V2430) (let V2431 (shen.lazyderef (tl V2429) V2951) (if (cons? V2431) (let V2432 (shen.lazyderef (hd V2431) V2951) (if (cons? V2432) (let V2433 (shen.lazyderef (hd V2432) V2951) (if (= list V2433) (let V2434 (shen.lazyderef (tl V2432) V2951) (if (cons? V2434) (let A (hd V2434) (let V2435 (shen.lazyderef (tl V2434) V2951) (if (= () V2435) (let V2436 (shen.lazyderef (tl V2431) V2951) (if (cons? V2436) (let V2437 (shen.lazyderef (hd V2436) V2951) (if (= ==> V2437) (let V2438 (shen.lazyderef (tl V2436) V2951) (if (cons? V2438) (let B (hd V2438) (let V2439 (shen.lazyderef (tl V2438) V2951) (if (cons? V2439) (let V2440 (shen.lazyderef (hd V2439) V2951) (if (= } V2440) (let Rest (tl V2439) (let Rest& (shen.newpv V2951) (let Rest&& (shen.newpv V2951) (let Rules (shen.newpv V2951) (let ListA&& (shen.newpv V2951) (let B&& (shen.newpv V2951) (let Sig (shen.newpv V2951) (let Declare (shen.newpv V2951) (do (shen.incinfs) (bind Sig (shen.ue (cons (cons list (cons (shen.lazyderef A V2951) ())) (cons ==> (cons (shen.lazyderef B V2951) ())))) V2951 (freeze (bind ListA&& (hd (shen.lazyderef Sig V2951)) V2951 (freeze (bind B&& (hd (tl (tl (shen.lazyderef Sig V2951)))) V2951 (freeze (bind Rest& (shen.plug-wildcards (shen.lazyderef Rest V2951)) V2951 (freeze (bind Rest&& (shen.ue (shen.lazyderef Rest& V2951)) V2951 (freeze (shen.get-rules Rules Rest&& V2951 (freeze (cut Throwcontrol V2951 (freeze (shen.tc-rules F Rules ListA&& B&& (cons (cons F (cons : (cons Sig ()))) V2950) 1 V2951 (freeze (unify V2949 (cons (cons list (cons A ())) (cons ==> (cons B ()))) V2951 (freeze (bind Declare (declare (shen.lazyderef F V2951) (cons (cons list (cons (shen.lazyderef A V2951) ())) (cons ==> (cons (shen.lazyderef B V2951) ())))) V2951 V2952)))))))))))))))))))))))))))) false)) false))) false)) false)) false)) false))) false)) false)) false)) false)) false)) false))) false)) false)) false)))))

(defun shen.plug-wildcards (V2953) (cond ((cons? V2953) (map shen.plug-wildcards V2953)) ((= V2953 _) (gensym (intern "X"))) (true V2953)))

(defun shen.get-rules (V2954 V2955 V2956 V2957) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2419 (shen.lazyderef V2954 V2956) (if (= () V2419) (let V2420 (shen.lazyderef V2955 V2956) (if (= () V2420) (do (shen.incinfs) (cut Throwcontrol V2956 V2957)) false)) (if (shen.pvar? V2419) (do (shen.bindv V2419 () V2956) (let Result (let V2421 (shen.lazyderef V2955 V2956) (if (= () V2421) (do (shen.incinfs) (cut Throwcontrol V2956 V2957)) false)) (do (shen.unbindv V2419 V2956) Result))) false))) (if (= Case false) (let V2422 (shen.lazyderef V2954 V2956) (if (cons? V2422) (let Rule (hd V2422) (let Rules (tl V2422) (let Other (shen.newpv V2956) (do (shen.incinfs) (shen.first-rule V2955 Rule Other V2956 (freeze (cut Throwcontrol V2956 (freeze (shen.get-rules Rules Other V2956 V2957))))))))) (if (shen.pvar? V2422) (let Rule (shen.newpv V2956) (let Rules (shen.newpv V2956) (do (shen.bindv V2422 (cons Rule Rules) V2956) (let Result (let Other (shen.newpv V2956) (do (shen.incinfs) (shen.first-rule V2955 Rule Other V2956 (freeze (cut Throwcontrol V2956 (freeze (shen.get-rules Rules Other V2956 V2957))))))) (do (shen.unbindv V2422 V2956) Result))))) false))) Case)))))

(defun shen.first-rule (V2958 V2959 V2960 V2961 V2962) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2412 (shen.lazyderef V2958 V2961) (if (cons? V2412) (let V2413 (shen.lazyderef (hd V2412) V2961) (if (= ; V2413) (let Other2407 (tl V2412) (let V2414 (shen.lazyderef V2959 V2961) (if (= () V2414) (do (shen.incinfs) (unify! V2960 Other2407 V2961 (freeze (cut Throwcontrol V2961 V2962)))) (if (shen.pvar? V2414) (do (shen.bindv V2414 () V2961) (let Result (do (shen.incinfs) (unify! V2960 Other2407 V2961 (freeze (cut Throwcontrol V2961 V2962)))) (do (shen.unbindv V2414 V2961) Result))) false)))) false)) false)) (if (= Case false) (let V2415 (shen.lazyderef V2958 V2961) (if (cons? V2415) (let X2408 (hd V2415) (let Rest (tl V2415) (let V2416 (shen.lazyderef V2959 V2961) (if (cons? V2416) (let X (hd V2416) (let Rule (tl V2416) (do (shen.incinfs) (unify! X X2408 V2961 (freeze (shen.first-rule Rest Rule V2960 V2961 V2962)))))) (if (shen.pvar? V2416) (let X (shen.newpv V2961) (let Rule (shen.newpv V2961) (do (shen.bindv V2416 (cons X Rule) V2961) (let Result (do (shen.incinfs) (unify! X X2408 V2961 (freeze (shen.first-rule Rest Rule V2960 V2961 V2962)))) (do (shen.unbindv V2416 V2961) Result))))) false))))) false)) Case)))))

(defun shen.tc-rules (V2963 V2964 V2965 V2966 V2967 V2968 V2969 V2970) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2401 (shen.lazyderef V2964 V2969) (if (= () V2401) (do (shen.incinfs) (thaw V2970)) false)) (if (= Case false) (let V2402 (shen.lazyderef V2964 V2969) (if (cons? V2402) (let Rule (hd V2402) (let Rules (tl V2402) (let V2403 (shen.lazyderef V2965 V2969) (if (cons? V2403) (let V2404 (shen.lazyderef (hd V2403) V2969) (if (= list V2404) (let V2405 (shen.lazyderef (tl V2403) V2969) (if (cons? V2405) (let A (hd V2405) (let V2406 (shen.lazyderef (tl V2405) V2969) (if (= () V2406) (let M (shen.newpv V2969) (do (shen.incinfs) (shen.tc-rule V2963 Rule A V2966 V2967 V2968 V2969 (freeze (bind M (+ (shen.deref V2968 V2969) 1) V2969 (freeze (cut Throwcontrol V2969 (freeze (shen.tc-rules V2963 Rules (cons list (cons A ())) V2966 V2967 M V2969 V2970))))))))) false))) false)) false)) false)))) false)) Case)))))

(defun shen.tc-rule (V2971 V2972 V2973 V2974 V2975 V2976 V2977 V2978) (let Case (do (shen.incinfs) (shen.check-defcc-rule V2972 V2973 V2974 V2975 V2977 V2978)) (if (= Case false) (let Err (shen.newpv V2977) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2976 V2977) (cn " of " (shen.app (shen.lazyderef V2971 V2977) "" shen.a)) shen.a))) V2977 V2978))) Case)))

(defun shen.check-defcc-rule (V2979 V2980 V2981 V2982 V2983 V2984) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Syntax (shen.newpv V2983) (let Semantics (shen.newpv V2983) (let SynHyps (shen.newpv V2983) (do (shen.incinfs) (shen.get-syntax+semantics Syntax Semantics V2979 V2983 (freeze (cut Throwcontrol V2983 (freeze (shen.syntax-hyps Syntax V2982 SynHyps V2980 V2983 (freeze (cut Throwcontrol V2983 (freeze (shen.syntax-check Syntax V2980 SynHyps V2983 (freeze (cut Throwcontrol V2983 (freeze (shen.semantics-check Semantics V2981 SynHyps V2983 V2984))))))))))))))))))))

(defun shen.syntax-hyps (V2985 V2986 V2987 V2988 V2989 V2990) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2374 (shen.lazyderef V2985 V2989) (if (= () V2374) (do (shen.incinfs) (unify! V2987 V2986 V2989 V2990)) false)) (if (= Case false) (let Case (let V2375 (shen.lazyderef V2985 V2989) (if (cons? V2375) (let X2368 (hd V2375) (let Y (tl V2375) (let V2376 (shen.lazyderef V2987 V2989) (if (cons? V2376) (let V2377 (shen.lazyderef (hd V2376) V2989) (if (cons? V2377) (let X (hd V2377) (let V2378 (shen.lazyderef (tl V2377) V2989) (if (cons? V2378) (let V2379 (shen.lazyderef (hd V2378) V2989) (if (= : V2379) (let V2380 (shen.lazyderef (tl V2378) V2989) (if (cons? V2380) (let A2369 (hd V2380) (let V2381 (shen.lazyderef (tl V2380) V2989) (if (= () V2381) (let SynHyps (tl V2376) (do (shen.incinfs) (unify! V2988 A2369 V2989 (freeze (unify! X X2368 V2989 (freeze (fwhen (shen.ue? (shen.deref X V2989)) V2989 (freeze (cut Throwcontrol V2989 (freeze (shen.syntax-hyps Y V2986 SynHyps V2988 V2989 V2990))))))))))) (if (shen.pvar? V2381) (do (shen.bindv V2381 () V2989) (let Result (let SynHyps (tl V2376) (do (shen.incinfs) (unify! V2988 A2369 V2989 (freeze (unify! X X2368 V2989 (freeze (fwhen (shen.ue? (shen.deref X V2989)) V2989 (freeze (cut Throwcontrol V2989 (freeze (shen.syntax-hyps Y V2986 SynHyps V2988 V2989 V2990))))))))))) (do (shen.unbindv V2381 V2989) Result))) false)))) (if (shen.pvar? V2380) (let A2369 (shen.newpv V2989) (do (shen.bindv V2380 (cons A2369 ()) V2989) (let Result (let SynHyps (tl V2376) (do (shen.incinfs) (unify! V2988 A2369 V2989 (freeze (unify! X X2368 V2989 (freeze (fwhen (shen.ue? (shen.deref X V2989)) V2989 (freeze (cut Throwcontrol V2989 (freeze (shen.syntax-hyps Y V2986 SynHyps V2988 V2989 V2990))))))))))) (do (shen.unbindv V2380 V2989) Result)))) false))) (if (shen.pvar? V2379) (do (shen.bindv V2379 : V2989) (let Result (let V2382 (shen.lazyderef (tl V2378) V2989) (if (cons? V2382) (let A2369 (hd V2382) (let V2383 (shen.lazyderef (tl V2382) V2989) (if (= () V2383) (let SynHyps (tl V2376) (do (shen.incinfs) (unify! V2988 A2369 V2989 (freeze (unify! X X2368 V2989 (freeze (fwhen (shen.ue? (shen.deref X V2989)) V2989 (freeze (cut Throwcontrol V2989 (freeze (shen.syntax-hyps Y V2986 SynHyps V2988 V2989 V2990))))))))))) (if (shen.pvar? V2383) (do (shen.bindv V2383 () V2989) (let Result (let SynHyps (tl V2376) (do (shen.incinfs) (unify! V2988 A2369 V2989 (freeze (unify! X X2368 V2989 (freeze (fwhen (shen.ue? (shen.deref X V2989)) V2989 (freeze (cut Throwcontrol V2989 (freeze (shen.syntax-hyps Y V2986 SynHyps V2988 V2989 V2990))))))))))) (do (shen.unbindv V2383 V2989) Result))) false)))) (if (shen.pvar? V2382) (let A2369 (shen.newpv V2989) (do (shen.bindv V2382 (cons A2369 ()) V2989) (let Result (let SynHyps (tl V2376) (do (shen.incinfs) (unify! V2988 A2369 V2989 (freeze (unify! X X2368 V2989 (freeze (fwhen (shen.ue? (shen.deref X V2989)) V2989 (freeze (cut Throwcontrol V2989 (freeze (shen.syntax-hyps Y V2986 SynHyps V2988 V2989 V2990))))))))))) (do (shen.unbindv V2382 V2989) Result)))) false))) (do (shen.unbindv V2379 V2989) Result))) false))) (if (shen.pvar? V2378) (let A2369 (shen.newpv V2989) (do (shen.bindv V2378 (cons : (cons A2369 ())) V2989) (let Result (let SynHyps (tl V2376) (do (shen.incinfs) (unify! V2988 A2369 V2989 (freeze (unify! X X2368 V2989 (freeze (fwhen (shen.ue? (shen.deref X V2989)) V2989 (freeze (cut Throwcontrol V2989 (freeze (shen.syntax-hyps Y V2986 SynHyps V2988 V2989 V2990))))))))))) (do (shen.unbindv V2378 V2989) Result)))) false)))) (if (shen.pvar? V2377) (let X (shen.newpv V2989) (let A2369 (shen.newpv V2989) (do (shen.bindv V2377 (cons X (cons : (cons A2369 ()))) V2989) (let Result (let SynHyps (tl V2376) (do (shen.incinfs) (unify! V2988 A2369 V2989 (freeze (unify! X X2368 V2989 (freeze (fwhen (shen.ue? (shen.deref X V2989)) V2989 (freeze (cut Throwcontrol V2989 (freeze (shen.syntax-hyps Y V2986 SynHyps V2988 V2989 V2990))))))))))) (do (shen.unbindv V2377 V2989) Result))))) false))) (if (shen.pvar? V2376) (let X (shen.newpv V2989) (let A2369 (shen.newpv V2989) (let SynHyps (shen.newpv V2989) (do (shen.bindv V2376 (cons (cons X (cons : (cons A2369 ()))) SynHyps) V2989) (let Result (do (shen.incinfs) (unify! V2988 A2369 V2989 (freeze (unify! X X2368 V2989 (freeze (fwhen (shen.ue? (shen.deref X V2989)) V2989 (freeze (cut Throwcontrol V2989 (freeze (shen.syntax-hyps Y V2986 SynHyps V2988 V2989 V2990)))))))))) (do (shen.unbindv V2376 V2989) Result)))))) false))))) false)) (if (= Case false) (let V2384 (shen.lazyderef V2985 V2989) (if (cons? V2384) (let Y (tl V2384) (do (shen.incinfs) (shen.syntax-hyps Y V2986 V2987 V2988 V2989 V2990))) false)) Case)) Case)))))

(defun shen.get-syntax+semantics (V2991 V2992 V2993 V2994 V2995) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2340 (shen.lazyderef V2991 V2994) (if (= () V2340) (let V2341 (shen.lazyderef V2993 V2994) (if (cons? V2341) (let V2342 (shen.lazyderef (hd V2341) V2994) (if (= := V2342) (let V2343 (shen.lazyderef (tl V2341) V2994) (if (cons? V2343) (let Semantics (hd V2343) (let V2344 (shen.lazyderef (tl V2343) V2994) (if (= () V2344) (do (shen.incinfs) (cut Throwcontrol V2994 (freeze (bind V2992 (shen.lazyderef Semantics V2994) V2994 V2995)))) false))) false)) false)) false)) (if (shen.pvar? V2340) (do (shen.bindv V2340 () V2994) (let Result (let V2345 (shen.lazyderef V2993 V2994) (if (cons? V2345) (let V2346 (shen.lazyderef (hd V2345) V2994) (if (= := V2346) (let V2347 (shen.lazyderef (tl V2345) V2994) (if (cons? V2347) (let Semantics (hd V2347) (let V2348 (shen.lazyderef (tl V2347) V2994) (if (= () V2348) (do (shen.incinfs) (cut Throwcontrol V2994 (freeze (bind V2992 (shen.lazyderef Semantics V2994) V2994 V2995)))) false))) false)) false)) false)) (do (shen.unbindv V2340 V2994) Result))) false))) (if (= Case false) (let Case (let V2349 (shen.lazyderef V2991 V2994) (if (= () V2349) (let V2350 (shen.lazyderef V2993 V2994) (if (cons? V2350) (let V2351 (shen.lazyderef (hd V2350) V2994) (if (= := V2351) (let V2352 (shen.lazyderef (tl V2350) V2994) (if (cons? V2352) (let Semantics (hd V2352) (let V2353 (shen.lazyderef (tl V2352) V2994) (if (cons? V2353) (let V2354 (shen.lazyderef (hd V2353) V2994) (if (= where V2354) (let V2355 (shen.lazyderef (tl V2353) V2994) (if (cons? V2355) (let G (hd V2355) (let V2356 (shen.lazyderef (tl V2355) V2994) (if (= () V2356) (do (shen.incinfs) (cut Throwcontrol V2994 (freeze (bind V2992 (cons where (cons (shen.lazyderef G V2994) (cons (shen.lazyderef Semantics V2994) ()))) V2994 V2995)))) false))) false)) false)) false))) false)) false)) false)) (if (shen.pvar? V2349) (do (shen.bindv V2349 () V2994) (let Result (let V2357 (shen.lazyderef V2993 V2994) (if (cons? V2357) (let V2358 (shen.lazyderef (hd V2357) V2994) (if (= := V2358) (let V2359 (shen.lazyderef (tl V2357) V2994) (if (cons? V2359) (let Semantics (hd V2359) (let V2360 (shen.lazyderef (tl V2359) V2994) (if (cons? V2360) (let V2361 (shen.lazyderef (hd V2360) V2994) (if (= where V2361) (let V2362 (shen.lazyderef (tl V2360) V2994) (if (cons? V2362) (let G (hd V2362) (let V2363 (shen.lazyderef (tl V2362) V2994) (if (= () V2363) (do (shen.incinfs) (cut Throwcontrol V2994 (freeze (bind V2992 (cons where (cons (shen.lazyderef G V2994) (cons (shen.lazyderef Semantics V2994) ()))) V2994 V2995)))) false))) false)) false)) false))) false)) false)) false)) (do (shen.unbindv V2349 V2994) Result))) false))) (if (= Case false) (let V2364 (shen.lazyderef V2991 V2994) (if (cons? V2364) (let X2336 (hd V2364) (let Syntax (tl V2364) (let V2365 (shen.lazyderef V2993 V2994) (if (cons? V2365) (let X (hd V2365) (let Rule (tl V2365) (do (shen.incinfs) (unify! X X2336 V2994 (freeze (shen.get-syntax+semantics Syntax V2992 Rule V2994 V2995)))))) false)))) (if (shen.pvar? V2364) (let X2336 (shen.newpv V2994) (let Syntax (shen.newpv V2994) (do (shen.bindv V2364 (cons X2336 Syntax) V2994) (let Result (let V2366 (shen.lazyderef V2993 V2994) (if (cons? V2366) (let X (hd V2366) (let Rule (tl V2366) (do (shen.incinfs) (unify! X X2336 V2994 (freeze (shen.get-syntax+semantics Syntax V2992 Rule V2994 V2995)))))) false)) (do (shen.unbindv V2364 V2994) Result))))) false))) Case)) Case)))))

(defun shen.syntax-check (V2996 V2997 V2998 V2999 V3000) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2333 (shen.lazyderef V2996 V2999) (if (= () V2333) (do (shen.incinfs) (thaw V3000)) false)) (if (= Case false) (let Case (let V2334 (shen.lazyderef V2996 V2999) (if (cons? V2334) (let X (hd V2334) (let Syntax (tl V2334) (let C (shen.newpv V2999) (let X&& (shen.newpv V2999) (let B (shen.newpv V2999) (do (shen.incinfs) (fwhen (shen.grammar_symbol? (shen.lazyderef X V2999)) V2999 (freeze (cut Throwcontrol V2999 (freeze (shen.t* (cons X (cons : (cons (cons (cons list (cons B ())) (cons ==> (cons C ()))) ()))) V2998 V2999 (freeze (cut Throwcontrol V2999 (freeze (bind X&& (concat && (shen.lazyderef X V2999)) V2999 (freeze (cut Throwcontrol V2999 (freeze (shen.t* (cons X&& (cons : (cons (cons list (cons V2997 ())) ()))) (cons (cons X&& (cons : (cons (cons list (cons B ())) ()))) V2998) V2999 (freeze (cut Throwcontrol V2999 (freeze (shen.syntax-check Syntax V2997 V2998 V2999 V3000))))))))))))))))))))))) false)) (if (= Case false) (let V2335 (shen.lazyderef V2996 V2999) (if (cons? V2335) (let X (hd V2335) (let Syntax (tl V2335) (do (shen.incinfs) (shen.t* (cons X (cons : (cons V2997 ()))) V2998 V2999 (freeze (cut Throwcontrol V2999 (freeze (shen.syntax-check Syntax V2997 V2998 V2999 V3000)))))))) false)) Case)) Case)))))

(defun shen.semantics-check (V3001 V3002 V3003 V3004 V3005) (let Semantics* (shen.newpv V3004) (do (shen.incinfs) (bind Semantics* (shen.curry (shen.rename-semantics (shen.deref V3001 V3004))) V3004 (freeze (shen.t* (cons Semantics* (cons : (cons V3002 ()))) V3003 V3004 V3005))))))

(defun shen.rename-semantics (V3006) (cond ((cons? V3006) (cons (shen.rename-semantics (hd V3006)) (shen.rename-semantics (tl V3006)))) ((shen.grammar_symbol? V3006) (cons shen.<-sem (cons V3006 ()))) (true V3006)))



