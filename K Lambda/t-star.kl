"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.typecheck (V2822 V2823) (let Curry (shen.curry V2822) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.demodulate (shen.curry-type V2823)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2824) (cond ((and (cons? V2824) (shen.special? (hd V2824))) (cons (hd V2824) (map shen.curry (tl V2824)))) ((and (cons? V2824) (and (cons? (tl V2824)) (shen.extraspecial? (hd V2824)))) V2824) ((and (cons? V2824) (and (cons? (tl V2824)) (cons? (tl (tl V2824))))) (shen.curry (cons (cons (hd V2824) (cons (hd (tl V2824)) ())) (tl (tl V2824))))) ((and (cons? V2824) (and (cons? (tl V2824)) (= () (tl (tl V2824))))) (cons (shen.curry (hd V2824)) (cons (shen.curry (hd (tl V2824))) ()))) (true V2824)))

(defun shen.special? (V2825) (element? V2825 (value shen.*special*)))

(defun shen.extraspecial? (V2826) (element? V2826 (value shen.*extraspecial*)))

(defun shen.t* (V2827 V2828 V2829 V2830) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2829) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2829 (freeze (bind Error (shen.errormaxinfs) V2829 V2830))))) (if (= Case false) (let Case (let V2816 (shen.lazyderef V2827 V2829) (if (= fail V2816) (do (shen.incinfs) (cut Throwcontrol V2829 (freeze (shen.prolog-failure V2829 V2830)))) false)) (if (= Case false) (let Case (let V2817 (shen.lazyderef V2827 V2829) (if (cons? V2817) (let X (hd V2817) (let V2818 (shen.lazyderef (tl V2817) V2829) (if (cons? V2818) (let V2819 (shen.lazyderef (hd V2818) V2829) (if (= : V2819) (let V2820 (shen.lazyderef (tl V2818) V2829) (if (cons? V2820) (let A (hd V2820) (let V2821 (shen.lazyderef (tl V2820) V2829) (if (= () V2821) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2829 (freeze (cut Throwcontrol V2829 (freeze (shen.th* X A V2828 V2829 V2830)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2829) (do (shen.incinfs) (shen.show V2827 V2828 V2829 (freeze (bind Datatypes (value shen.*datatypes*) V2829 (freeze (shen.udefs* V2827 V2828 Datatypes V2829 V2830))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2835) (cond ((= + V2835) (set shen.*shen-type-theory-enabled?* true)) ((= - V2835) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2844 V2845) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2846 V2847 V2848 V2849 V2850) (let Case (let V2812 (shen.lazyderef V2848 V2849) (if (cons? V2812) (let D (hd V2812) (do (shen.incinfs) (call (cons D (cons V2846 (cons V2847 ()))) V2849 V2850))) false)) (if (= Case false) (let V2813 (shen.lazyderef V2848 V2849) (if (cons? V2813) (let Ds (tl V2813) (do (shen.incinfs) (shen.udefs* V2846 V2847 Ds V2849 V2850))) false)) Case)))

(defun shen.th* (V2851 V2852 V2853 V2854 V2855) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2851 (cons : (cons V2852 ()))) V2853 V2854 (freeze (fwhen false V2854 V2855)))) (if (= Case false) (let Case (let F (shen.newpv V2854) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2851 V2854)) V2854 (freeze (bind F (shen.sigf (shen.lazyderef V2851 V2854)) V2854 (freeze (call (cons F (cons V2852 ())) V2854 V2855))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2851 V2852 V2854 V2855)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2851 V2852 V2853 V2854 V2855)) (if (= Case false) (let Case (let V2697 (shen.lazyderef V2851 V2854) (if (cons? V2697) (let F (hd V2697) (let V2698 (shen.lazyderef (tl V2697) V2854) (if (= () V2698) (do (shen.incinfs) (shen.th* F (cons --> (cons V2852 ())) V2853 V2854 V2855)) false))) false)) (if (= Case false) (let Case (let V2699 (shen.lazyderef V2851 V2854) (if (cons? V2699) (let F (hd V2699) (let V2700 (shen.lazyderef (tl V2699) V2854) (if (cons? V2700) (let X (hd V2700) (let V2701 (shen.lazyderef (tl V2700) V2854) (if (= () V2701) (let B (shen.newpv V2854) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2852 ()))) V2853 V2854 (freeze (shen.th* X B V2853 V2854 V2855))))) false))) false))) false)) (if (= Case false) (let Case (let V2702 (shen.lazyderef V2851 V2854) (if (cons? V2702) (let V2703 (shen.lazyderef (hd V2702) V2854) (if (= cons V2703) (let V2704 (shen.lazyderef (tl V2702) V2854) (if (cons? V2704) (let X (hd V2704) (let V2705 (shen.lazyderef (tl V2704) V2854) (if (cons? V2705) (let Y (hd V2705) (let V2706 (shen.lazyderef (tl V2705) V2854) (if (= () V2706) (let V2707 (shen.lazyderef V2852 V2854) (if (cons? V2707) (let V2708 (shen.lazyderef (hd V2707) V2854) (if (= list V2708) (let V2709 (shen.lazyderef (tl V2707) V2854) (if (cons? V2709) (let A (hd V2709) (let V2710 (shen.lazyderef (tl V2709) V2854) (if (= () V2710) (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y (cons list (cons A ())) V2853 V2854 V2855)))) (if (shen.pvar? V2710) (do (shen.bindv V2710 () V2854) (let Result (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y (cons list (cons A ())) V2853 V2854 V2855)))) (do (shen.unbindv V2710 V2854) Result))) false)))) (if (shen.pvar? V2709) (let A (shen.newpv V2854) (do (shen.bindv V2709 (cons A ()) V2854) (let Result (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y (cons list (cons A ())) V2853 V2854 V2855)))) (do (shen.unbindv V2709 V2854) Result)))) false))) (if (shen.pvar? V2708) (do (shen.bindv V2708 list V2854) (let Result (let V2711 (shen.lazyderef (tl V2707) V2854) (if (cons? V2711) (let A (hd V2711) (let V2712 (shen.lazyderef (tl V2711) V2854) (if (= () V2712) (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y (cons list (cons A ())) V2853 V2854 V2855)))) (if (shen.pvar? V2712) (do (shen.bindv V2712 () V2854) (let Result (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y (cons list (cons A ())) V2853 V2854 V2855)))) (do (shen.unbindv V2712 V2854) Result))) false)))) (if (shen.pvar? V2711) (let A (shen.newpv V2854) (do (shen.bindv V2711 (cons A ()) V2854) (let Result (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y (cons list (cons A ())) V2853 V2854 V2855)))) (do (shen.unbindv V2711 V2854) Result)))) false))) (do (shen.unbindv V2708 V2854) Result))) false))) (if (shen.pvar? V2707) (let A (shen.newpv V2854) (do (shen.bindv V2707 (cons list (cons A ())) V2854) (let Result (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y (cons list (cons A ())) V2853 V2854 V2855)))) (do (shen.unbindv V2707 V2854) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2713 (shen.lazyderef V2851 V2854) (if (cons? V2713) (let V2714 (shen.lazyderef (hd V2713) V2854) (if (= @p V2714) (let V2715 (shen.lazyderef (tl V2713) V2854) (if (cons? V2715) (let X (hd V2715) (let V2716 (shen.lazyderef (tl V2715) V2854) (if (cons? V2716) (let Y (hd V2716) (let V2717 (shen.lazyderef (tl V2716) V2854) (if (= () V2717) (let V2718 (shen.lazyderef V2852 V2854) (if (cons? V2718) (let A (hd V2718) (let V2719 (shen.lazyderef (tl V2718) V2854) (if (cons? V2719) (let V2720 (shen.lazyderef (hd V2719) V2854) (if (= * V2720) (let V2721 (shen.lazyderef (tl V2719) V2854) (if (cons? V2721) (let B (hd V2721) (let V2722 (shen.lazyderef (tl V2721) V2854) (if (= () V2722) (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y B V2853 V2854 V2855)))) (if (shen.pvar? V2722) (do (shen.bindv V2722 () V2854) (let Result (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y B V2853 V2854 V2855)))) (do (shen.unbindv V2722 V2854) Result))) false)))) (if (shen.pvar? V2721) (let B (shen.newpv V2854) (do (shen.bindv V2721 (cons B ()) V2854) (let Result (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y B V2853 V2854 V2855)))) (do (shen.unbindv V2721 V2854) Result)))) false))) (if (shen.pvar? V2720) (do (shen.bindv V2720 * V2854) (let Result (let V2723 (shen.lazyderef (tl V2719) V2854) (if (cons? V2723) (let B (hd V2723) (let V2724 (shen.lazyderef (tl V2723) V2854) (if (= () V2724) (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y B V2853 V2854 V2855)))) (if (shen.pvar? V2724) (do (shen.bindv V2724 () V2854) (let Result (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y B V2853 V2854 V2855)))) (do (shen.unbindv V2724 V2854) Result))) false)))) (if (shen.pvar? V2723) (let B (shen.newpv V2854) (do (shen.bindv V2723 (cons B ()) V2854) (let Result (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y B V2853 V2854 V2855)))) (do (shen.unbindv V2723 V2854) Result)))) false))) (do (shen.unbindv V2720 V2854) Result))) false))) (if (shen.pvar? V2719) (let B (shen.newpv V2854) (do (shen.bindv V2719 (cons * (cons B ())) V2854) (let Result (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y B V2853 V2854 V2855)))) (do (shen.unbindv V2719 V2854) Result)))) false)))) (if (shen.pvar? V2718) (let A (shen.newpv V2854) (let B (shen.newpv V2854) (do (shen.bindv V2718 (cons A (cons * (cons B ()))) V2854) (let Result (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y B V2853 V2854 V2855)))) (do (shen.unbindv V2718 V2854) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2725 (shen.lazyderef V2851 V2854) (if (cons? V2725) (let V2726 (shen.lazyderef (hd V2725) V2854) (if (= @v V2726) (let V2727 (shen.lazyderef (tl V2725) V2854) (if (cons? V2727) (let X (hd V2727) (let V2728 (shen.lazyderef (tl V2727) V2854) (if (cons? V2728) (let Y (hd V2728) (let V2729 (shen.lazyderef (tl V2728) V2854) (if (= () V2729) (let V2730 (shen.lazyderef V2852 V2854) (if (cons? V2730) (let V2731 (shen.lazyderef (hd V2730) V2854) (if (= vector V2731) (let V2732 (shen.lazyderef (tl V2730) V2854) (if (cons? V2732) (let A (hd V2732) (let V2733 (shen.lazyderef (tl V2732) V2854) (if (= () V2733) (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y (cons vector (cons A ())) V2853 V2854 V2855)))) (if (shen.pvar? V2733) (do (shen.bindv V2733 () V2854) (let Result (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y (cons vector (cons A ())) V2853 V2854 V2855)))) (do (shen.unbindv V2733 V2854) Result))) false)))) (if (shen.pvar? V2732) (let A (shen.newpv V2854) (do (shen.bindv V2732 (cons A ()) V2854) (let Result (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y (cons vector (cons A ())) V2853 V2854 V2855)))) (do (shen.unbindv V2732 V2854) Result)))) false))) (if (shen.pvar? V2731) (do (shen.bindv V2731 vector V2854) (let Result (let V2734 (shen.lazyderef (tl V2730) V2854) (if (cons? V2734) (let A (hd V2734) (let V2735 (shen.lazyderef (tl V2734) V2854) (if (= () V2735) (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y (cons vector (cons A ())) V2853 V2854 V2855)))) (if (shen.pvar? V2735) (do (shen.bindv V2735 () V2854) (let Result (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y (cons vector (cons A ())) V2853 V2854 V2855)))) (do (shen.unbindv V2735 V2854) Result))) false)))) (if (shen.pvar? V2734) (let A (shen.newpv V2854) (do (shen.bindv V2734 (cons A ()) V2854) (let Result (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y (cons vector (cons A ())) V2853 V2854 V2855)))) (do (shen.unbindv V2734 V2854) Result)))) false))) (do (shen.unbindv V2731 V2854) Result))) false))) (if (shen.pvar? V2730) (let A (shen.newpv V2854) (do (shen.bindv V2730 (cons vector (cons A ())) V2854) (let Result (do (shen.incinfs) (shen.th* X A V2853 V2854 (freeze (shen.th* Y (cons vector (cons A ())) V2853 V2854 V2855)))) (do (shen.unbindv V2730 V2854) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2736 (shen.lazyderef V2851 V2854) (if (cons? V2736) (let V2737 (shen.lazyderef (hd V2736) V2854) (if (= @s V2737) (let V2738 (shen.lazyderef (tl V2736) V2854) (if (cons? V2738) (let X (hd V2738) (let V2739 (shen.lazyderef (tl V2738) V2854) (if (cons? V2739) (let Y (hd V2739) (let V2740 (shen.lazyderef (tl V2739) V2854) (if (= () V2740) (let V2741 (shen.lazyderef V2852 V2854) (if (= string V2741) (do (shen.incinfs) (shen.th* X string V2853 V2854 (freeze (shen.th* Y string V2853 V2854 V2855)))) (if (shen.pvar? V2741) (do (shen.bindv V2741 string V2854) (let Result (do (shen.incinfs) (shen.th* X string V2853 V2854 (freeze (shen.th* Y string V2853 V2854 V2855)))) (do (shen.unbindv V2741 V2854) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2742 (shen.lazyderef V2851 V2854) (if (cons? V2742) (let V2743 (shen.lazyderef (hd V2742) V2854) (if (= lambda V2743) (let V2744 (shen.lazyderef (tl V2742) V2854) (if (cons? V2744) (let X (hd V2744) (let V2745 (shen.lazyderef (tl V2744) V2854) (if (cons? V2745) (let Y (hd V2745) (let V2746 (shen.lazyderef (tl V2745) V2854) (if (= () V2746) (let V2747 (shen.lazyderef V2852 V2854) (if (cons? V2747) (let A (hd V2747) (let V2748 (shen.lazyderef (tl V2747) V2854) (if (cons? V2748) (let V2749 (shen.lazyderef (hd V2748) V2854) (if (= --> V2749) (let V2750 (shen.lazyderef (tl V2748) V2854) (if (cons? V2750) (let B (hd V2750) (let V2751 (shen.lazyderef (tl V2750) V2854) (if (= () V2751) (let Z (shen.newpv V2854) (let X&& (shen.newpv V2854) (do (shen.incinfs) (cut Throwcontrol V2854 (freeze (bind X&& (shen.placeholder) V2854 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2854) (shen.lazyderef X V2854) (shen.lazyderef Y V2854)) V2854 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2853) V2854 V2855)))))))))) (if (shen.pvar? V2751) (do (shen.bindv V2751 () V2854) (let Result (let Z (shen.newpv V2854) (let X&& (shen.newpv V2854) (do (shen.incinfs) (cut Throwcontrol V2854 (freeze (bind X&& (shen.placeholder) V2854 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2854) (shen.lazyderef X V2854) (shen.lazyderef Y V2854)) V2854 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2853) V2854 V2855)))))))))) (do (shen.unbindv V2751 V2854) Result))) false)))) (if (shen.pvar? V2750) (let B (shen.newpv V2854) (do (shen.bindv V2750 (cons B ()) V2854) (let Result (let Z (shen.newpv V2854) (let X&& (shen.newpv V2854) (do (shen.incinfs) (cut Throwcontrol V2854 (freeze (bind X&& (shen.placeholder) V2854 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2854) (shen.lazyderef X V2854) (shen.lazyderef Y V2854)) V2854 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2853) V2854 V2855)))))))))) (do (shen.unbindv V2750 V2854) Result)))) false))) (if (shen.pvar? V2749) (do (shen.bindv V2749 --> V2854) (let Result (let V2752 (shen.lazyderef (tl V2748) V2854) (if (cons? V2752) (let B (hd V2752) (let V2753 (shen.lazyderef (tl V2752) V2854) (if (= () V2753) (let Z (shen.newpv V2854) (let X&& (shen.newpv V2854) (do (shen.incinfs) (cut Throwcontrol V2854 (freeze (bind X&& (shen.placeholder) V2854 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2854) (shen.lazyderef X V2854) (shen.lazyderef Y V2854)) V2854 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2853) V2854 V2855)))))))))) (if (shen.pvar? V2753) (do (shen.bindv V2753 () V2854) (let Result (let Z (shen.newpv V2854) (let X&& (shen.newpv V2854) (do (shen.incinfs) (cut Throwcontrol V2854 (freeze (bind X&& (shen.placeholder) V2854 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2854) (shen.lazyderef X V2854) (shen.lazyderef Y V2854)) V2854 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2853) V2854 V2855)))))))))) (do (shen.unbindv V2753 V2854) Result))) false)))) (if (shen.pvar? V2752) (let B (shen.newpv V2854) (do (shen.bindv V2752 (cons B ()) V2854) (let Result (let Z (shen.newpv V2854) (let X&& (shen.newpv V2854) (do (shen.incinfs) (cut Throwcontrol V2854 (freeze (bind X&& (shen.placeholder) V2854 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2854) (shen.lazyderef X V2854) (shen.lazyderef Y V2854)) V2854 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2853) V2854 V2855)))))))))) (do (shen.unbindv V2752 V2854) Result)))) false))) (do (shen.unbindv V2749 V2854) Result))) false))) (if (shen.pvar? V2748) (let B (shen.newpv V2854) (do (shen.bindv V2748 (cons --> (cons B ())) V2854) (let Result (let Z (shen.newpv V2854) (let X&& (shen.newpv V2854) (do (shen.incinfs) (cut Throwcontrol V2854 (freeze (bind X&& (shen.placeholder) V2854 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2854) (shen.lazyderef X V2854) (shen.lazyderef Y V2854)) V2854 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2853) V2854 V2855)))))))))) (do (shen.unbindv V2748 V2854) Result)))) false)))) (if (shen.pvar? V2747) (let A (shen.newpv V2854) (let B (shen.newpv V2854) (do (shen.bindv V2747 (cons A (cons --> (cons B ()))) V2854) (let Result (let Z (shen.newpv V2854) (let X&& (shen.newpv V2854) (do (shen.incinfs) (cut Throwcontrol V2854 (freeze (bind X&& (shen.placeholder) V2854 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2854) (shen.lazyderef X V2854) (shen.lazyderef Y V2854)) V2854 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2853) V2854 V2855)))))))))) (do (shen.unbindv V2747 V2854) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2754 (shen.lazyderef V2851 V2854) (if (cons? V2754) (let V2755 (shen.lazyderef (hd V2754) V2854) (if (= let V2755) (let V2756 (shen.lazyderef (tl V2754) V2854) (if (cons? V2756) (let X (hd V2756) (let V2757 (shen.lazyderef (tl V2756) V2854) (if (cons? V2757) (let Y (hd V2757) (let V2758 (shen.lazyderef (tl V2757) V2854) (if (cons? V2758) (let Z (hd V2758) (let V2759 (shen.lazyderef (tl V2758) V2854) (if (= () V2759) (let W (shen.newpv V2854) (let X&& (shen.newpv V2854) (let B (shen.newpv V2854) (do (shen.incinfs) (cut Throwcontrol V2854 (freeze (shen.th* Y B V2853 V2854 (freeze (bind X&& (shen.placeholder) V2854 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2854) (shen.lazyderef X V2854) (shen.lazyderef Z V2854)) V2854 (freeze (shen.th* W V2852 (cons (cons X&& (cons : (cons B ()))) V2853) V2854 V2855))))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2760 (shen.lazyderef V2851 V2854) (if (cons? V2760) (let V2761 (shen.lazyderef (hd V2760) V2854) (if (= open V2761) (let V2762 (shen.lazyderef (tl V2760) V2854) (if (cons? V2762) (let FileName (hd V2762) (let V2763 (shen.lazyderef (tl V2762) V2854) (if (cons? V2763) (let Direction2693 (hd V2763) (let V2764 (shen.lazyderef (tl V2763) V2854) (if (= () V2764) (let V2765 (shen.lazyderef V2852 V2854) (if (cons? V2765) (let V2766 (shen.lazyderef (hd V2765) V2854) (if (= stream V2766) (let V2767 (shen.lazyderef (tl V2765) V2854) (if (cons? V2767) (let Direction (hd V2767) (let V2768 (shen.lazyderef (tl V2767) V2854) (if (= () V2768) (do (shen.incinfs) (unify! Direction Direction2693 V2854 (freeze (cut Throwcontrol V2854 (freeze (shen.th* FileName string V2853 V2854 V2855)))))) (if (shen.pvar? V2768) (do (shen.bindv V2768 () V2854) (let Result (do (shen.incinfs) (unify! Direction Direction2693 V2854 (freeze (cut Throwcontrol V2854 (freeze (shen.th* FileName string V2853 V2854 V2855)))))) (do (shen.unbindv V2768 V2854) Result))) false)))) (if (shen.pvar? V2767) (let Direction (shen.newpv V2854) (do (shen.bindv V2767 (cons Direction ()) V2854) (let Result (do (shen.incinfs) (unify! Direction Direction2693 V2854 (freeze (cut Throwcontrol V2854 (freeze (shen.th* FileName string V2853 V2854 V2855)))))) (do (shen.unbindv V2767 V2854) Result)))) false))) (if (shen.pvar? V2766) (do (shen.bindv V2766 stream V2854) (let Result (let V2769 (shen.lazyderef (tl V2765) V2854) (if (cons? V2769) (let Direction (hd V2769) (let V2770 (shen.lazyderef (tl V2769) V2854) (if (= () V2770) (do (shen.incinfs) (unify! Direction Direction2693 V2854 (freeze (cut Throwcontrol V2854 (freeze (shen.th* FileName string V2853 V2854 V2855)))))) (if (shen.pvar? V2770) (do (shen.bindv V2770 () V2854) (let Result (do (shen.incinfs) (unify! Direction Direction2693 V2854 (freeze (cut Throwcontrol V2854 (freeze (shen.th* FileName string V2853 V2854 V2855)))))) (do (shen.unbindv V2770 V2854) Result))) false)))) (if (shen.pvar? V2769) (let Direction (shen.newpv V2854) (do (shen.bindv V2769 (cons Direction ()) V2854) (let Result (do (shen.incinfs) (unify! Direction Direction2693 V2854 (freeze (cut Throwcontrol V2854 (freeze (shen.th* FileName string V2853 V2854 V2855)))))) (do (shen.unbindv V2769 V2854) Result)))) false))) (do (shen.unbindv V2766 V2854) Result))) false))) (if (shen.pvar? V2765) (let Direction (shen.newpv V2854) (do (shen.bindv V2765 (cons stream (cons Direction ())) V2854) (let Result (do (shen.incinfs) (unify! Direction Direction2693 V2854 (freeze (cut Throwcontrol V2854 (freeze (shen.th* FileName string V2853 V2854 V2855)))))) (do (shen.unbindv V2765 V2854) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2771 (shen.lazyderef V2851 V2854) (if (cons? V2771) (let V2772 (shen.lazyderef (hd V2771) V2854) (if (= type V2772) (let V2773 (shen.lazyderef (tl V2771) V2854) (if (cons? V2773) (let X (hd V2773) (let V2774 (shen.lazyderef (tl V2773) V2854) (if (cons? V2774) (let A (hd V2774) (let V2775 (shen.lazyderef (tl V2774) V2854) (if (= () V2775) (do (shen.incinfs) (cut Throwcontrol V2854 (freeze (unify A V2852 V2854 (freeze (shen.th* X A V2853 V2854 V2855)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2776 (shen.lazyderef V2851 V2854) (if (cons? V2776) (let V2777 (shen.lazyderef (hd V2776) V2854) (if (= input+ V2777) (let V2778 (shen.lazyderef (tl V2776) V2854) (if (cons? V2778) (let A (hd V2778) (let V2779 (shen.lazyderef (tl V2778) V2854) (if (cons? V2779) (let Stream (hd V2779) (let V2780 (shen.lazyderef (tl V2779) V2854) (if (= () V2780) (let C (shen.newpv V2854) (do (shen.incinfs) (bind C (shen.demodulate (shen.lazyderef A V2854)) V2854 (freeze (unify V2852 C V2854 (freeze (shen.th* Stream (cons stream (cons in ())) V2853 V2854 V2855))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2781 (shen.lazyderef V2851 V2854) (if (cons? V2781) (let V2782 (shen.lazyderef (hd V2781) V2854) (if (= set V2782) (let V2783 (shen.lazyderef (tl V2781) V2854) (if (cons? V2783) (let Var (hd V2783) (let V2784 (shen.lazyderef (tl V2783) V2854) (if (cons? V2784) (let Val (hd V2784) (let V2785 (shen.lazyderef (tl V2784) V2854) (if (= () V2785) (do (shen.incinfs) (cut Throwcontrol V2854 (freeze (shen.th* Var symbol V2853 V2854 (freeze (cut Throwcontrol V2854 (freeze (shen.th* (cons value (cons Var ())) V2852 V2853 V2854 (freeze (shen.th* Val V2852 V2853 V2854 V2855)))))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2786 (shen.lazyderef V2851 V2854) (if (cons? V2786) (let V2787 (shen.lazyderef (hd V2786) V2854) (if (= shen.<-sem V2787) (let V2788 (shen.lazyderef (tl V2786) V2854) (if (cons? V2788) (let F (hd V2788) (let V2789 (shen.lazyderef (tl V2788) V2854) (if (= () V2789) (let A (shen.newpv V2854) (let F&& (shen.newpv V2854) (let B (shen.newpv V2854) (do (shen.incinfs) (cut Throwcontrol V2854 (freeze (shen.th* F (cons A (cons ==> (cons B ()))) V2853 V2854 (freeze (cut Throwcontrol V2854 (freeze (bind F&& (concat && (shen.lazyderef F V2854)) V2854 (freeze (cut Throwcontrol V2854 (freeze (shen.th* F&& V2852 (cons (cons F&& (cons : (cons B ()))) V2853) V2854 V2855))))))))))))))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2790 (shen.lazyderef V2851 V2854) (if (cons? V2790) (let V2791 (shen.lazyderef (hd V2790) V2854) (if (= fail V2791) (let V2792 (shen.lazyderef (tl V2790) V2854) (if (= () V2792) (let V2793 (shen.lazyderef V2852 V2854) (if (= symbol V2793) (do (shen.incinfs) (thaw V2855)) (if (shen.pvar? V2793) (do (shen.bindv V2793 symbol V2854) (let Result (do (shen.incinfs) (thaw V2855)) (do (shen.unbindv V2793 V2854) Result))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2854) (do (shen.incinfs) (shen.t*-hyps V2853 NewHyp V2854 (freeze (shen.th* V2851 V2852 NewHyp V2854 V2855))))) (if (= Case false) (let Case (let V2794 (shen.lazyderef V2851 V2854) (if (cons? V2794) (let V2795 (shen.lazyderef (hd V2794) V2854) (if (= define V2795) (let V2796 (shen.lazyderef (tl V2794) V2854) (if (cons? V2796) (let F (hd V2796) (let X (tl V2796) (do (shen.incinfs) (cut Throwcontrol V2854 (freeze (shen.t*-def (cons define (cons F X)) V2852 V2853 V2854 V2855)))))) false)) false)) false)) (if (= Case false) (let Case (let V2797 (shen.lazyderef V2851 V2854) (if (cons? V2797) (let V2798 (shen.lazyderef (hd V2797) V2854) (if (= defcc V2798) (let V2799 (shen.lazyderef (tl V2797) V2854) (if (cons? V2799) (let F (hd V2799) (let X (tl V2799) (do (shen.incinfs) (cut Throwcontrol V2854 (freeze (shen.t*-defcc (cons defcc (cons F X)) V2852 V2853 V2854 V2855)))))) false)) false)) false)) (if (= Case false) (let Case (let V2800 (shen.lazyderef V2851 V2854) (if (cons? V2800) (let V2801 (shen.lazyderef (hd V2800) V2854) (if (= defmacro V2801) (let V2802 (shen.lazyderef V2852 V2854) (if (= unit V2802) (do (shen.incinfs) (cut Throwcontrol V2854 V2855)) (if (shen.pvar? V2802) (do (shen.bindv V2802 unit V2854) (let Result (do (shen.incinfs) (cut Throwcontrol V2854 V2855)) (do (shen.unbindv V2802 V2854) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2803 (shen.lazyderef V2851 V2854) (if (cons? V2803) (let V2804 (shen.lazyderef (hd V2803) V2854) (if (= shen.process-datatype V2804) (let V2805 (shen.lazyderef V2852 V2854) (if (= symbol V2805) (do (shen.incinfs) (thaw V2855)) (if (shen.pvar? V2805) (do (shen.bindv V2805 symbol V2854) (let Result (do (shen.incinfs) (thaw V2855)) (do (shen.unbindv V2805 V2854) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2806 (shen.lazyderef V2851 V2854) (if (cons? V2806) (let V2807 (shen.lazyderef (hd V2806) V2854) (if (= shen.synonyms-help V2807) (let V2808 (shen.lazyderef V2852 V2854) (if (= symbol V2808) (do (shen.incinfs) (thaw V2855)) (if (shen.pvar? V2808) (do (shen.bindv V2808 symbol V2854) (let Result (do (shen.incinfs) (thaw V2855)) (do (shen.unbindv V2808 V2854) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2854) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2854 (freeze (shen.udefs* (cons V2851 (cons : (cons V2852 ()))) V2853 Datatypes V2854 V2855))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2856 V2857 V2858 V2859) (let Case (let V2608 (shen.lazyderef V2856 V2858) (if (cons? V2608) (let V2609 (shen.lazyderef (hd V2608) V2858) (if (cons? V2609) (let V2610 (shen.lazyderef (hd V2609) V2858) (if (cons? V2610) (let V2611 (shen.lazyderef (hd V2610) V2858) (if (= cons V2611) (let V2612 (shen.lazyderef (tl V2610) V2858) (if (cons? V2612) (let X (hd V2612) (let V2613 (shen.lazyderef (tl V2612) V2858) (if (cons? V2613) (let Y (hd V2613) (let V2614 (shen.lazyderef (tl V2613) V2858) (if (= () V2614) (let V2615 (shen.lazyderef (tl V2609) V2858) (if (cons? V2615) (let V2616 (shen.lazyderef (hd V2615) V2858) (if (= : V2616) (let V2617 (shen.lazyderef (tl V2615) V2858) (if (cons? V2617) (let V2618 (shen.lazyderef (hd V2617) V2858) (if (cons? V2618) (let V2619 (shen.lazyderef (hd V2618) V2858) (if (= list V2619) (let V2620 (shen.lazyderef (tl V2618) V2858) (if (cons? V2620) (let A (hd V2620) (let V2621 (shen.lazyderef (tl V2620) V2858) (if (= () V2621) (let V2622 (shen.lazyderef (tl V2617) V2858) (if (= () V2622) (let Hyp (tl V2608) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons list (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2622) (do (shen.bindv V2622 () V2858) (let Result (let Hyp (tl V2608) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons list (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2622 V2858) Result))) false))) (if (shen.pvar? V2621) (do (shen.bindv V2621 () V2858) (let Result (let V2623 (shen.lazyderef (tl V2617) V2858) (if (= () V2623) (let Hyp (tl V2608) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons list (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2623) (do (shen.bindv V2623 () V2858) (let Result (let Hyp (tl V2608) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons list (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2623 V2858) Result))) false))) (do (shen.unbindv V2621 V2858) Result))) false)))) (if (shen.pvar? V2620) (let A (shen.newpv V2858) (do (shen.bindv V2620 (cons A ()) V2858) (let Result (let V2624 (shen.lazyderef (tl V2617) V2858) (if (= () V2624) (let Hyp (tl V2608) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons list (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2624) (do (shen.bindv V2624 () V2858) (let Result (let Hyp (tl V2608) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons list (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2624 V2858) Result))) false))) (do (shen.unbindv V2620 V2858) Result)))) false))) (if (shen.pvar? V2619) (do (shen.bindv V2619 list V2858) (let Result (let V2625 (shen.lazyderef (tl V2618) V2858) (if (cons? V2625) (let A (hd V2625) (let V2626 (shen.lazyderef (tl V2625) V2858) (if (= () V2626) (let V2627 (shen.lazyderef (tl V2617) V2858) (if (= () V2627) (let Hyp (tl V2608) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons list (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2627) (do (shen.bindv V2627 () V2858) (let Result (let Hyp (tl V2608) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons list (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2627 V2858) Result))) false))) (if (shen.pvar? V2626) (do (shen.bindv V2626 () V2858) (let Result (let V2628 (shen.lazyderef (tl V2617) V2858) (if (= () V2628) (let Hyp (tl V2608) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons list (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2628) (do (shen.bindv V2628 () V2858) (let Result (let Hyp (tl V2608) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons list (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2628 V2858) Result))) false))) (do (shen.unbindv V2626 V2858) Result))) false)))) (if (shen.pvar? V2625) (let A (shen.newpv V2858) (do (shen.bindv V2625 (cons A ()) V2858) (let Result (let V2629 (shen.lazyderef (tl V2617) V2858) (if (= () V2629) (let Hyp (tl V2608) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons list (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2629) (do (shen.bindv V2629 () V2858) (let Result (let Hyp (tl V2608) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons list (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2629 V2858) Result))) false))) (do (shen.unbindv V2625 V2858) Result)))) false))) (do (shen.unbindv V2619 V2858) Result))) false))) (if (shen.pvar? V2618) (let A (shen.newpv V2858) (do (shen.bindv V2618 (cons list (cons A ())) V2858) (let Result (let V2630 (shen.lazyderef (tl V2617) V2858) (if (= () V2630) (let Hyp (tl V2608) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons list (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2630) (do (shen.bindv V2630 () V2858) (let Result (let Hyp (tl V2608) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons list (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2630 V2858) Result))) false))) (do (shen.unbindv V2618 V2858) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2631 (shen.lazyderef V2856 V2858) (if (cons? V2631) (let V2632 (shen.lazyderef (hd V2631) V2858) (if (cons? V2632) (let V2633 (shen.lazyderef (hd V2632) V2858) (if (cons? V2633) (let V2634 (shen.lazyderef (hd V2633) V2858) (if (= @p V2634) (let V2635 (shen.lazyderef (tl V2633) V2858) (if (cons? V2635) (let X (hd V2635) (let V2636 (shen.lazyderef (tl V2635) V2858) (if (cons? V2636) (let Y (hd V2636) (let V2637 (shen.lazyderef (tl V2636) V2858) (if (= () V2637) (let V2638 (shen.lazyderef (tl V2632) V2858) (if (cons? V2638) (let V2639 (shen.lazyderef (hd V2638) V2858) (if (= : V2639) (let V2640 (shen.lazyderef (tl V2638) V2858) (if (cons? V2640) (let V2641 (shen.lazyderef (hd V2640) V2858) (if (cons? V2641) (let A (hd V2641) (let V2642 (shen.lazyderef (tl V2641) V2858) (if (cons? V2642) (let V2643 (shen.lazyderef (hd V2642) V2858) (if (= * V2643) (let V2644 (shen.lazyderef (tl V2642) V2858) (if (cons? V2644) (let B (hd V2644) (let V2645 (shen.lazyderef (tl V2644) V2858) (if (= () V2645) (let V2646 (shen.lazyderef (tl V2640) V2858) (if (= () V2646) (let Hyp (tl V2631) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (shen.lazyderef B V2858) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2646) (do (shen.bindv V2646 () V2858) (let Result (let Hyp (tl V2631) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (shen.lazyderef B V2858) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2646 V2858) Result))) false))) (if (shen.pvar? V2645) (do (shen.bindv V2645 () V2858) (let Result (let V2647 (shen.lazyderef (tl V2640) V2858) (if (= () V2647) (let Hyp (tl V2631) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (shen.lazyderef B V2858) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2647) (do (shen.bindv V2647 () V2858) (let Result (let Hyp (tl V2631) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (shen.lazyderef B V2858) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2647 V2858) Result))) false))) (do (shen.unbindv V2645 V2858) Result))) false)))) (if (shen.pvar? V2644) (let B (shen.newpv V2858) (do (shen.bindv V2644 (cons B ()) V2858) (let Result (let V2648 (shen.lazyderef (tl V2640) V2858) (if (= () V2648) (let Hyp (tl V2631) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (shen.lazyderef B V2858) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2648) (do (shen.bindv V2648 () V2858) (let Result (let Hyp (tl V2631) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (shen.lazyderef B V2858) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2648 V2858) Result))) false))) (do (shen.unbindv V2644 V2858) Result)))) false))) (if (shen.pvar? V2643) (do (shen.bindv V2643 * V2858) (let Result (let V2649 (shen.lazyderef (tl V2642) V2858) (if (cons? V2649) (let B (hd V2649) (let V2650 (shen.lazyderef (tl V2649) V2858) (if (= () V2650) (let V2651 (shen.lazyderef (tl V2640) V2858) (if (= () V2651) (let Hyp (tl V2631) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (shen.lazyderef B V2858) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2651) (do (shen.bindv V2651 () V2858) (let Result (let Hyp (tl V2631) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (shen.lazyderef B V2858) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2651 V2858) Result))) false))) (if (shen.pvar? V2650) (do (shen.bindv V2650 () V2858) (let Result (let V2652 (shen.lazyderef (tl V2640) V2858) (if (= () V2652) (let Hyp (tl V2631) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (shen.lazyderef B V2858) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2652) (do (shen.bindv V2652 () V2858) (let Result (let Hyp (tl V2631) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (shen.lazyderef B V2858) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2652 V2858) Result))) false))) (do (shen.unbindv V2650 V2858) Result))) false)))) (if (shen.pvar? V2649) (let B (shen.newpv V2858) (do (shen.bindv V2649 (cons B ()) V2858) (let Result (let V2653 (shen.lazyderef (tl V2640) V2858) (if (= () V2653) (let Hyp (tl V2631) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (shen.lazyderef B V2858) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2653) (do (shen.bindv V2653 () V2858) (let Result (let Hyp (tl V2631) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (shen.lazyderef B V2858) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2653 V2858) Result))) false))) (do (shen.unbindv V2649 V2858) Result)))) false))) (do (shen.unbindv V2643 V2858) Result))) false))) (if (shen.pvar? V2642) (let B (shen.newpv V2858) (do (shen.bindv V2642 (cons * (cons B ())) V2858) (let Result (let V2654 (shen.lazyderef (tl V2640) V2858) (if (= () V2654) (let Hyp (tl V2631) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (shen.lazyderef B V2858) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2654) (do (shen.bindv V2654 () V2858) (let Result (let Hyp (tl V2631) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (shen.lazyderef B V2858) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2654 V2858) Result))) false))) (do (shen.unbindv V2642 V2858) Result)))) false)))) (if (shen.pvar? V2641) (let A (shen.newpv V2858) (let B (shen.newpv V2858) (do (shen.bindv V2641 (cons A (cons * (cons B ()))) V2858) (let Result (let V2655 (shen.lazyderef (tl V2640) V2858) (if (= () V2655) (let Hyp (tl V2631) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (shen.lazyderef B V2858) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2655) (do (shen.bindv V2655 () V2858) (let Result (let Hyp (tl V2631) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (shen.lazyderef B V2858) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2655 V2858) Result))) false))) (do (shen.unbindv V2641 V2858) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2656 (shen.lazyderef V2856 V2858) (if (cons? V2656) (let V2657 (shen.lazyderef (hd V2656) V2858) (if (cons? V2657) (let V2658 (shen.lazyderef (hd V2657) V2858) (if (cons? V2658) (let V2659 (shen.lazyderef (hd V2658) V2858) (if (= @v V2659) (let V2660 (shen.lazyderef (tl V2658) V2858) (if (cons? V2660) (let X (hd V2660) (let V2661 (shen.lazyderef (tl V2660) V2858) (if (cons? V2661) (let Y (hd V2661) (let V2662 (shen.lazyderef (tl V2661) V2858) (if (= () V2662) (let V2663 (shen.lazyderef (tl V2657) V2858) (if (cons? V2663) (let V2664 (shen.lazyderef (hd V2663) V2858) (if (= : V2664) (let V2665 (shen.lazyderef (tl V2663) V2858) (if (cons? V2665) (let V2666 (shen.lazyderef (hd V2665) V2858) (if (cons? V2666) (let V2667 (shen.lazyderef (hd V2666) V2858) (if (= vector V2667) (let V2668 (shen.lazyderef (tl V2666) V2858) (if (cons? V2668) (let A (hd V2668) (let V2669 (shen.lazyderef (tl V2668) V2858) (if (= () V2669) (let V2670 (shen.lazyderef (tl V2665) V2858) (if (= () V2670) (let Hyp (tl V2656) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons vector (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2670) (do (shen.bindv V2670 () V2858) (let Result (let Hyp (tl V2656) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons vector (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2670 V2858) Result))) false))) (if (shen.pvar? V2669) (do (shen.bindv V2669 () V2858) (let Result (let V2671 (shen.lazyderef (tl V2665) V2858) (if (= () V2671) (let Hyp (tl V2656) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons vector (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2671) (do (shen.bindv V2671 () V2858) (let Result (let Hyp (tl V2656) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons vector (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2671 V2858) Result))) false))) (do (shen.unbindv V2669 V2858) Result))) false)))) (if (shen.pvar? V2668) (let A (shen.newpv V2858) (do (shen.bindv V2668 (cons A ()) V2858) (let Result (let V2672 (shen.lazyderef (tl V2665) V2858) (if (= () V2672) (let Hyp (tl V2656) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons vector (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2672) (do (shen.bindv V2672 () V2858) (let Result (let Hyp (tl V2656) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons vector (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2672 V2858) Result))) false))) (do (shen.unbindv V2668 V2858) Result)))) false))) (if (shen.pvar? V2667) (do (shen.bindv V2667 vector V2858) (let Result (let V2673 (shen.lazyderef (tl V2666) V2858) (if (cons? V2673) (let A (hd V2673) (let V2674 (shen.lazyderef (tl V2673) V2858) (if (= () V2674) (let V2675 (shen.lazyderef (tl V2665) V2858) (if (= () V2675) (let Hyp (tl V2656) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons vector (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2675) (do (shen.bindv V2675 () V2858) (let Result (let Hyp (tl V2656) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons vector (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2675 V2858) Result))) false))) (if (shen.pvar? V2674) (do (shen.bindv V2674 () V2858) (let Result (let V2676 (shen.lazyderef (tl V2665) V2858) (if (= () V2676) (let Hyp (tl V2656) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons vector (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2676) (do (shen.bindv V2676 () V2858) (let Result (let Hyp (tl V2656) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons vector (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2676 V2858) Result))) false))) (do (shen.unbindv V2674 V2858) Result))) false)))) (if (shen.pvar? V2673) (let A (shen.newpv V2858) (do (shen.bindv V2673 (cons A ()) V2858) (let Result (let V2677 (shen.lazyderef (tl V2665) V2858) (if (= () V2677) (let Hyp (tl V2656) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons vector (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2677) (do (shen.bindv V2677 () V2858) (let Result (let Hyp (tl V2656) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons vector (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2677 V2858) Result))) false))) (do (shen.unbindv V2673 V2858) Result)))) false))) (do (shen.unbindv V2667 V2858) Result))) false))) (if (shen.pvar? V2666) (let A (shen.newpv V2858) (do (shen.bindv V2666 (cons vector (cons A ())) V2858) (let Result (let V2678 (shen.lazyderef (tl V2665) V2858) (if (= () V2678) (let Hyp (tl V2656) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons vector (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2678) (do (shen.bindv V2678 () V2858) (let Result (let Hyp (tl V2656) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons (shen.lazyderef A V2858) ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons (cons vector (cons (shen.lazyderef A V2858) ())) ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2678 V2858) Result))) false))) (do (shen.unbindv V2666 V2858) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2679 (shen.lazyderef V2856 V2858) (if (cons? V2679) (let V2680 (shen.lazyderef (hd V2679) V2858) (if (cons? V2680) (let V2681 (shen.lazyderef (hd V2680) V2858) (if (cons? V2681) (let V2682 (shen.lazyderef (hd V2681) V2858) (if (= @s V2682) (let V2683 (shen.lazyderef (tl V2681) V2858) (if (cons? V2683) (let X (hd V2683) (let V2684 (shen.lazyderef (tl V2683) V2858) (if (cons? V2684) (let Y (hd V2684) (let V2685 (shen.lazyderef (tl V2684) V2858) (if (= () V2685) (let V2686 (shen.lazyderef (tl V2680) V2858) (if (cons? V2686) (let V2687 (shen.lazyderef (hd V2686) V2858) (if (= : V2687) (let V2688 (shen.lazyderef (tl V2686) V2858) (if (cons? V2688) (let V2689 (shen.lazyderef (hd V2688) V2858) (if (= string V2689) (let V2690 (shen.lazyderef (tl V2688) V2858) (if (= () V2690) (let Hyp (tl V2679) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons string ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2690) (do (shen.bindv V2690 () V2858) (let Result (let Hyp (tl V2679) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons string ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2690 V2858) Result))) false))) (if (shen.pvar? V2689) (do (shen.bindv V2689 string V2858) (let Result (let V2691 (shen.lazyderef (tl V2688) V2858) (if (= () V2691) (let Hyp (tl V2679) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons string ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (if (shen.pvar? V2691) (do (shen.bindv V2691 () V2858) (let Result (let Hyp (tl V2679) (do (shen.incinfs) (bind V2857 (cons (cons (shen.lazyderef X V2858) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2858) (cons : (cons string ()))) (shen.lazyderef Hyp V2858))) V2858 V2859))) (do (shen.unbindv V2691 V2858) Result))) false))) (do (shen.unbindv V2689 V2858) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V2692 (shen.lazyderef V2856 V2858) (if (cons? V2692) (let X (hd V2692) (let Hyp (tl V2692) (let NewHyps (shen.newpv V2858) (do (shen.incinfs) (bind V2857 (cons (shen.lazyderef X V2858) (shen.lazyderef NewHyps V2858)) V2858 (freeze (shen.t*-hyps Hyp NewHyps V2858 V2859))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2872 V2873 V2874 V2875) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2872 V2874)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2873 V2874) 1) (do (shen.prhush "
> " (stoutput)) (do (shen.pause-for-user) (thaw V2875))))))))) (true (thaw V2875))))

(defun shen.line () (let Infs (inferences) (shen.prhush (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2876) (cond ((and (cons? V2876) (and (cons? (tl V2876)) (and (= : (hd (tl V2876))) (and (cons? (tl (tl V2876))) (= () (tl (tl (tl V2876)))))))) (shen.prhush (shen.app (hd V2876) (cn " : " (shen.app (hd (tl (tl V2876))) "" shen.r)) shen.r) (stoutput))) (true (shen.prhush (shen.app V2876 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2879 V2880) (cond ((= () V2879) shen.skip) ((cons? V2879) (do (shen.prhush (shen.app V2880 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2879)) (do (nl 1) (shen.show-assumptions (tl V2879) (+ V2880 1)))))) (true (shen.sys-error shen.show-assumptions))))

(defun shen.pause-for-user () (let Byte (do (read-byte (stinput)) (read-byte (stinput))) (if (= Byte 94) (simple-error "input aborted
") (nl 1))))

(defun shen.typedf? (V2881) (cons? (assoc V2881 (value shen.*signedfuncs*))))

(defun shen.sigf (V2882) (concat shen.type-signature-of- V2882))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2883 V2884 V2885 V2886) (let Case (let V2595 (shen.lazyderef V2884 V2885) (if (= number V2595) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2883 V2885)) V2885 V2886)) (if (shen.pvar? V2595) (do (shen.bindv V2595 number V2885) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2883 V2885)) V2885 V2886)) (do (shen.unbindv V2595 V2885) Result))) false))) (if (= Case false) (let Case (let V2596 (shen.lazyderef V2884 V2885) (if (= boolean V2596) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2883 V2885)) V2885 V2886)) (if (shen.pvar? V2596) (do (shen.bindv V2596 boolean V2885) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2883 V2885)) V2885 V2886)) (do (shen.unbindv V2596 V2885) Result))) false))) (if (= Case false) (let Case (let V2597 (shen.lazyderef V2884 V2885) (if (= string V2597) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2883 V2885)) V2885 V2886)) (if (shen.pvar? V2597) (do (shen.bindv V2597 string V2885) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2883 V2885)) V2885 V2886)) (do (shen.unbindv V2597 V2885) Result))) false))) (if (= Case false) (let Case (let V2598 (shen.lazyderef V2884 V2885) (if (= symbol V2598) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2883 V2885)) V2885 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2883 V2885))) V2885 V2886)))) (if (shen.pvar? V2598) (do (shen.bindv V2598 symbol V2885) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2883 V2885)) V2885 (freeze (fwhen (not (shen.ue? (shen.lazyderef V2883 V2885))) V2885 V2886)))) (do (shen.unbindv V2598 V2885) Result))) false))) (if (= Case false) (let V2599 (shen.lazyderef V2883 V2885) (if (= () V2599) (let V2600 (shen.lazyderef V2884 V2885) (if (cons? V2600) (let V2601 (shen.lazyderef (hd V2600) V2885) (if (= list V2601) (let V2602 (shen.lazyderef (tl V2600) V2885) (if (cons? V2602) (let A (hd V2602) (let V2603 (shen.lazyderef (tl V2602) V2885) (if (= () V2603) (do (shen.incinfs) (thaw V2886)) (if (shen.pvar? V2603) (do (shen.bindv V2603 () V2885) (let Result (do (shen.incinfs) (thaw V2886)) (do (shen.unbindv V2603 V2885) Result))) false)))) (if (shen.pvar? V2602) (let A (shen.newpv V2885) (do (shen.bindv V2602 (cons A ()) V2885) (let Result (do (shen.incinfs) (thaw V2886)) (do (shen.unbindv V2602 V2885) Result)))) false))) (if (shen.pvar? V2601) (do (shen.bindv V2601 list V2885) (let Result (let V2604 (shen.lazyderef (tl V2600) V2885) (if (cons? V2604) (let A (hd V2604) (let V2605 (shen.lazyderef (tl V2604) V2885) (if (= () V2605) (do (shen.incinfs) (thaw V2886)) (if (shen.pvar? V2605) (do (shen.bindv V2605 () V2885) (let Result (do (shen.incinfs) (thaw V2886)) (do (shen.unbindv V2605 V2885) Result))) false)))) (if (shen.pvar? V2604) (let A (shen.newpv V2885) (do (shen.bindv V2604 (cons A ()) V2885) (let Result (do (shen.incinfs) (thaw V2886)) (do (shen.unbindv V2604 V2885) Result)))) false))) (do (shen.unbindv V2601 V2885) Result))) false))) (if (shen.pvar? V2600) (let A (shen.newpv V2885) (do (shen.bindv V2600 (cons list (cons A ())) V2885) (let Result (do (shen.incinfs) (thaw V2886)) (do (shen.unbindv V2600 V2885) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.by_hypothesis (V2887 V2888 V2889 V2890 V2891) (let Case (let V2586 (shen.lazyderef V2889 V2890) (if (cons? V2586) (let V2587 (shen.lazyderef (hd V2586) V2890) (if (cons? V2587) (let Y (hd V2587) (let V2588 (shen.lazyderef (tl V2587) V2890) (if (cons? V2588) (let V2589 (shen.lazyderef (hd V2588) V2890) (if (= : V2589) (let V2590 (shen.lazyderef (tl V2588) V2890) (if (cons? V2590) (let B (hd V2590) (let V2591 (shen.lazyderef (tl V2590) V2890) (if (= () V2591) (do (shen.incinfs) (identical V2887 Y V2890 (freeze (unify! V2888 B V2890 V2891)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V2592 (shen.lazyderef V2889 V2890) (if (cons? V2592) (let Hyp (tl V2592) (do (shen.incinfs) (shen.by_hypothesis V2887 V2888 Hyp V2890 V2891))) false)) Case)))

(defun shen.t*-def (V2892 V2893 V2894 V2895 V2896) (let V2580 (shen.lazyderef V2892 V2895) (if (cons? V2580) (let V2581 (shen.lazyderef (hd V2580) V2895) (if (= define V2581) (let V2582 (shen.lazyderef (tl V2580) V2895) (if (cons? V2582) (let F (hd V2582) (let X (tl V2582) (let E (shen.newpv V2895) (do (shen.incinfs) (shen.t*-defh (compile shen.<sig+rules> X (lambda E (if (cons? E) (simple-error (cn "parse error here: " (shen.app E "
" shen.s))) (simple-error "parse error
")))) F V2893 V2894 V2895 V2896))))) false)) false)) false)))

(defun shen.t*-defh (V2897 V2898 V2899 V2900 V2901 V2902) (let V2576 (shen.lazyderef V2897 V2901) (if (cons? V2576) (let Sig (hd V2576) (let Rules (tl V2576) (do (shen.incinfs) (shen.t*-defhh Sig (shen.ue-sig Sig) V2898 V2899 V2900 Rules V2901 V2902)))) false)))

(defun shen.t*-defhh (V2903 V2904 V2905 V2906 V2907 V2908 V2909 V2910) (do (shen.incinfs) (shen.t*-rules V2908 V2904 1 V2905 (cons (cons V2905 (cons : (cons V2904 ()))) V2907) V2909 (freeze (shen.memo V2905 V2903 V2906 V2909 V2910)))))

(defun shen.memo (V2911 V2912 V2913 V2914 V2915) (let Jnk (shen.newpv V2914) (do (shen.incinfs) (unify! V2913 V2912 V2914 (freeze (bind Jnk (declare (shen.lazyderef V2911 V2914) (shen.lazyderef V2913 V2914)) V2914 V2915))))))

(defun shen.<sig+rules> (V2920) (let Result (let Parse_shen.<signature> (shen.<signature> V2920) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.ue (V2921) (cond ((and (cons? V2921) (and (cons? (tl V2921)) (and (= () (tl (tl V2921))) (= (hd V2921) protect)))) V2921) ((cons? V2921) (map shen.ue V2921)) ((variable? V2921) (concat && V2921)) (true V2921)))

(defun shen.ue-sig (V2922) (cond ((cons? V2922) (map shen.ue-sig V2922)) ((variable? V2922) (concat shen.&&& V2922)) (true V2922)))

(defun shen.ues (V2927) (cond ((shen.ue? V2927) (cons V2927 ())) ((cons? V2927) (union (shen.ues (hd V2927)) (shen.ues (tl V2927)))) (true ())))

(defun shen.ue? (V2928) (and (symbol? V2928) (shen.ue-h? (str V2928))))

(defun shen.ue-h? (V2935) (cond ((and (shen.+string? V2935) (and (= "&" (pos V2935 0)) (and (shen.+string? (tlstr V2935)) (= "&" (pos (tlstr V2935) 0))))) true) (true false)))

(defun shen.t*-rules (V2936 V2937 V2938 V2939 V2940 V2941 V2942) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2551 (shen.lazyderef V2936 V2941) (if (= () V2551) (do (shen.incinfs) (thaw V2942)) false)) (if (= Case false) (let Case (let V2552 (shen.lazyderef V2936 V2941) (if (cons? V2552) (let V2553 (shen.lazyderef (hd V2552) V2941) (if (cons? V2553) (let V2554 (shen.lazyderef (hd V2553) V2941) (if (= () V2554) (let V2555 (shen.lazyderef (tl V2553) V2941) (if (cons? V2555) (let Action (hd V2555) (let V2556 (shen.lazyderef (tl V2555) V2941) (if (= () V2556) (let Rules (tl V2552) (let V2557 (shen.lazyderef V2937 V2941) (if (cons? V2557) (let V2558 (shen.lazyderef (hd V2557) V2941) (if (= --> V2558) (let V2559 (shen.lazyderef (tl V2557) V2941) (if (cons? V2559) (let A (hd V2559) (let V2560 (shen.lazyderef (tl V2559) V2941) (if (= () V2560) (do (shen.incinfs) (shen.t*-rule (cons () (cons (shen.ue Action) ())) A V2940 V2941 (freeze (cut Throwcontrol V2941 (freeze (shen.t*-rules Rules A (+ V2938 1) V2939 V2940 V2941 V2942)))))) false))) false)) false)) false))) false))) false)) false)) false)) false)) (if (= Case false) (let Case (let V2561 (shen.lazyderef V2936 V2941) (if (cons? V2561) (let Rule (hd V2561) (let Rules (tl V2561) (do (shen.incinfs) (shen.t*-rule (shen.ue Rule) V2937 V2940 V2941 (freeze (cut Throwcontrol V2941 (freeze (shen.t*-rules Rules V2937 (+ V2938 1) V2939 V2940 V2941 V2942)))))))) false)) (if (= Case false) (let Err (shen.newpv V2941) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2938 V2941) (cn " of " (shen.app (shen.lazyderef V2939 V2941) "" shen.a)) shen.a))) V2941 V2942))) Case)) Case)) Case)))))

(defun shen.t*-rule (V2943 V2944 V2945 V2946 V2947) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2533 (shen.lazyderef V2943 V2946) (if (cons? V2533) (let V2534 (shen.lazyderef (hd V2533) V2946) (if (= () V2534) (let V2535 (shen.lazyderef (tl V2533) V2946) (if (cons? V2535) (let Action (hd V2535) (let V2536 (shen.lazyderef (tl V2535) V2946) (if (= () V2536) (do (shen.incinfs) (cut Throwcontrol V2946 (freeze (shen.t*-action (shen.curry Action) V2944 V2945 V2946 V2947)))) false))) false)) false)) false)) (if (= Case false) (let V2537 (shen.lazyderef V2943 V2946) (if (cons? V2537) (let V2538 (shen.lazyderef (hd V2537) V2946) (if (cons? V2538) (let Pattern (hd V2538) (let Patterns (tl V2538) (let V2539 (shen.lazyderef (tl V2537) V2946) (if (cons? V2539) (let Action (hd V2539) (let V2540 (shen.lazyderef (tl V2539) V2946) (if (= () V2540) (let V2541 (shen.lazyderef V2944 V2946) (if (cons? V2541) (let A (hd V2541) (let V2542 (shen.lazyderef (tl V2541) V2946) (if (cons? V2542) (let V2543 (shen.lazyderef (hd V2542) V2946) (if (= --> V2543) (let V2544 (shen.lazyderef (tl V2542) V2946) (if (cons? V2544) (let B (hd V2544) (let V2545 (shen.lazyderef (tl V2544) V2946) (if (= () V2545) (do (shen.incinfs) (shen.t*-pattern Pattern A V2946 (freeze (cut Throwcontrol V2946 (freeze (shen.t*-rule (cons Patterns (cons Action ())) B (cons (cons Pattern (cons : (cons A ()))) V2945) V2946 V2947)))))) false))) false)) false)) false))) false)) false))) false)))) false)) false)) Case)))))

(defun shen.t*-action (V2948 V2949 V2950 V2951 V2952) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2510 (shen.lazyderef V2948 V2951) (if (cons? V2510) (let V2511 (shen.lazyderef (hd V2510) V2951) (if (= where V2511) (let V2512 (shen.lazyderef (tl V2510) V2951) (if (cons? V2512) (let P (hd V2512) (let V2513 (shen.lazyderef (tl V2512) V2951) (if (cons? V2513) (let Action (hd V2513) (let V2514 (shen.lazyderef (tl V2513) V2951) (if (= () V2514) (do (shen.incinfs) (cut Throwcontrol V2951 (freeze (shen.t* (cons P (cons : (cons boolean ()))) V2950 V2951 (freeze (cut Throwcontrol V2951 (freeze (shen.t*-action Action V2949 (cons (cons P (cons : (cons verified ()))) V2950) V2951 V2952)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2515 (shen.lazyderef V2948 V2951) (if (cons? V2515) (let V2516 (shen.lazyderef (hd V2515) V2951) (if (= shen.choicepoint! V2516) (let V2517 (shen.lazyderef (tl V2515) V2951) (if (cons? V2517) (let V2518 (shen.lazyderef (hd V2517) V2951) (if (cons? V2518) (let V2519 (shen.lazyderef (hd V2518) V2951) (if (cons? V2519) (let V2520 (shen.lazyderef (hd V2519) V2951) (if (= fail-if V2520) (let V2521 (shen.lazyderef (tl V2519) V2951) (if (cons? V2521) (let F (hd V2521) (let V2522 (shen.lazyderef (tl V2521) V2951) (if (= () V2522) (let V2523 (shen.lazyderef (tl V2518) V2951) (if (cons? V2523) (let Action (hd V2523) (let V2524 (shen.lazyderef (tl V2523) V2951) (if (= () V2524) (let V2525 (shen.lazyderef (tl V2517) V2951) (if (= () V2525) (do (shen.incinfs) (cut Throwcontrol V2951 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons F (cons Action ())) ())) (cons Action ()))) V2949 V2950 V2951 V2952)))) false)) false))) false)) false))) false)) false)) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2526 (shen.lazyderef V2948 V2951) (if (cons? V2526) (let V2527 (shen.lazyderef (hd V2526) V2951) (if (= shen.choicepoint! V2527) (let V2528 (shen.lazyderef (tl V2526) V2951) (if (cons? V2528) (let Action (hd V2528) (let V2529 (shen.lazyderef (tl V2528) V2951) (if (= () V2529) (do (shen.incinfs) (cut Throwcontrol V2951 (freeze (shen.t*-action (cons where (cons (cons not (cons (cons (cons = (cons Action ())) (cons (cons fail ()) ())) ())) (cons Action ()))) V2949 V2950 V2951 V2952)))) false))) false)) false)) false)) (if (= Case false) (do (shen.incinfs) (shen.t* (cons V2948 (cons : (cons V2949 ()))) V2950 V2951 V2952)) Case)) Case)) Case)))))

(defun shen.t*-pattern (V2953 V2954 V2955 V2956) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Hyp (shen.newpv V2955) (do (shen.incinfs) (shen.tms->hyp (shen.ues V2953) Hyp V2955 (freeze (cut Throwcontrol V2955 (freeze (shen.t* (cons V2953 (cons : (cons V2954 ()))) Hyp V2955 V2956))))))))))

(defun shen.tms->hyp (V2957 V2958 V2959 V2960) (let Case (let V2494 (shen.lazyderef V2957 V2959) (if (= () V2494) (let V2495 (shen.lazyderef V2958 V2959) (if (= () V2495) (do (shen.incinfs) (thaw V2960)) (if (shen.pvar? V2495) (do (shen.bindv V2495 () V2959) (let Result (do (shen.incinfs) (thaw V2960)) (do (shen.unbindv V2495 V2959) Result))) false))) false)) (if (= Case false) (let V2496 (shen.lazyderef V2957 V2959) (if (cons? V2496) (let Tm2491 (hd V2496) (let Tms (tl V2496) (let V2497 (shen.lazyderef V2958 V2959) (if (cons? V2497) (let V2498 (shen.lazyderef (hd V2497) V2959) (if (cons? V2498) (let Tm (hd V2498) (let V2499 (shen.lazyderef (tl V2498) V2959) (if (cons? V2499) (let V2500 (shen.lazyderef (hd V2499) V2959) (if (= : V2500) (let V2501 (shen.lazyderef (tl V2499) V2959) (if (cons? V2501) (let A (hd V2501) (let V2502 (shen.lazyderef (tl V2501) V2959) (if (= () V2502) (let Hyp (tl V2497) (do (shen.incinfs) (unify! Tm Tm2491 V2959 (freeze (shen.tms->hyp Tms Hyp V2959 V2960))))) (if (shen.pvar? V2502) (do (shen.bindv V2502 () V2959) (let Result (let Hyp (tl V2497) (do (shen.incinfs) (unify! Tm Tm2491 V2959 (freeze (shen.tms->hyp Tms Hyp V2959 V2960))))) (do (shen.unbindv V2502 V2959) Result))) false)))) (if (shen.pvar? V2501) (let A (shen.newpv V2959) (do (shen.bindv V2501 (cons A ()) V2959) (let Result (let Hyp (tl V2497) (do (shen.incinfs) (unify! Tm Tm2491 V2959 (freeze (shen.tms->hyp Tms Hyp V2959 V2960))))) (do (shen.unbindv V2501 V2959) Result)))) false))) (if (shen.pvar? V2500) (do (shen.bindv V2500 : V2959) (let Result (let V2503 (shen.lazyderef (tl V2499) V2959) (if (cons? V2503) (let A (hd V2503) (let V2504 (shen.lazyderef (tl V2503) V2959) (if (= () V2504) (let Hyp (tl V2497) (do (shen.incinfs) (unify! Tm Tm2491 V2959 (freeze (shen.tms->hyp Tms Hyp V2959 V2960))))) (if (shen.pvar? V2504) (do (shen.bindv V2504 () V2959) (let Result (let Hyp (tl V2497) (do (shen.incinfs) (unify! Tm Tm2491 V2959 (freeze (shen.tms->hyp Tms Hyp V2959 V2960))))) (do (shen.unbindv V2504 V2959) Result))) false)))) (if (shen.pvar? V2503) (let A (shen.newpv V2959) (do (shen.bindv V2503 (cons A ()) V2959) (let Result (let Hyp (tl V2497) (do (shen.incinfs) (unify! Tm Tm2491 V2959 (freeze (shen.tms->hyp Tms Hyp V2959 V2960))))) (do (shen.unbindv V2503 V2959) Result)))) false))) (do (shen.unbindv V2500 V2959) Result))) false))) (if (shen.pvar? V2499) (let A (shen.newpv V2959) (do (shen.bindv V2499 (cons : (cons A ())) V2959) (let Result (let Hyp (tl V2497) (do (shen.incinfs) (unify! Tm Tm2491 V2959 (freeze (shen.tms->hyp Tms Hyp V2959 V2960))))) (do (shen.unbindv V2499 V2959) Result)))) false)))) (if (shen.pvar? V2498) (let Tm (shen.newpv V2959) (let A (shen.newpv V2959) (do (shen.bindv V2498 (cons Tm (cons : (cons A ()))) V2959) (let Result (let Hyp (tl V2497) (do (shen.incinfs) (unify! Tm Tm2491 V2959 (freeze (shen.tms->hyp Tms Hyp V2959 V2960))))) (do (shen.unbindv V2498 V2959) Result))))) false))) (if (shen.pvar? V2497) (let Tm (shen.newpv V2959) (let A (shen.newpv V2959) (let Hyp (shen.newpv V2959) (do (shen.bindv V2497 (cons (cons Tm (cons : (cons A ()))) Hyp) V2959) (let Result (do (shen.incinfs) (unify! Tm Tm2491 V2959 (freeze (shen.tms->hyp Tms Hyp V2959 V2960)))) (do (shen.unbindv V2497 V2959) Result)))))) false))))) false)) Case)))

(defun findall (V2961 V2962 V2963 V2964 V2965) (let B (shen.newpv V2964) (let A (shen.newpv V2964) (do (shen.incinfs) (bind A (gensym shen.a) V2964 (freeze (bind B (set (shen.lazyderef A V2964) ()) V2964 (freeze (shen.findallhelp V2961 V2962 V2963 A V2964 V2965)))))))))

(defun shen.findallhelp (V2966 V2967 V2968 V2969 V2970 V2971) (let Case (do (shen.incinfs) (call V2967 V2970 (freeze (shen.remember V2969 V2966 V2970 (freeze (fwhen false V2970 V2971)))))) (if (= Case false) (do (shen.incinfs) (bind V2968 (value (shen.lazyderef V2969 V2970)) V2970 V2971)) Case)))

(defun shen.remember (V2972 V2973 V2974 V2975) (let B (shen.newpv V2974) (do (shen.incinfs) (bind B (set (shen.deref V2972 V2974) (cons (shen.deref V2973 V2974) (value (shen.deref V2972 V2974)))) V2974 V2975))))

(defun shen.t*-defcc (V2976 V2977 V2978 V2979 V2980) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2467 (shen.lazyderef V2976 V2979) (if (cons? V2467) (let V2468 (shen.lazyderef (hd V2467) V2979) (if (= defcc V2468) (let V2469 (shen.lazyderef (tl V2467) V2979) (if (cons? V2469) (let F (hd V2469) (let V2470 (shen.lazyderef (tl V2469) V2979) (if (cons? V2470) (let V2471 (shen.lazyderef (hd V2470) V2979) (if (= { V2471) (let V2472 (shen.lazyderef (tl V2470) V2979) (if (cons? V2472) (let V2473 (shen.lazyderef (hd V2472) V2979) (if (cons? V2473) (let V2474 (shen.lazyderef (hd V2473) V2979) (if (= list V2474) (let V2475 (shen.lazyderef (tl V2473) V2979) (if (cons? V2475) (let A (hd V2475) (let V2476 (shen.lazyderef (tl V2475) V2979) (if (= () V2476) (let V2477 (shen.lazyderef (tl V2472) V2979) (if (cons? V2477) (let V2478 (shen.lazyderef (hd V2477) V2979) (if (= ==> V2478) (let V2479 (shen.lazyderef (tl V2477) V2979) (if (cons? V2479) (let B (hd V2479) (let V2480 (shen.lazyderef (tl V2479) V2979) (if (cons? V2480) (let V2481 (shen.lazyderef (hd V2480) V2979) (if (= } V2481) (let Rest (tl V2480) (let Rest& (shen.newpv V2979) (let Rest&& (shen.newpv V2979) (let Rules (shen.newpv V2979) (let ListA&& (shen.newpv V2979) (let B&& (shen.newpv V2979) (let Sig (shen.newpv V2979) (let Declare (shen.newpv V2979) (do (shen.incinfs) (bind Sig (shen.ue (cons (cons list (cons (shen.lazyderef A V2979) ())) (cons ==> (cons (shen.lazyderef B V2979) ())))) V2979 (freeze (bind ListA&& (hd (shen.lazyderef Sig V2979)) V2979 (freeze (bind B&& (hd (tl (tl (shen.lazyderef Sig V2979)))) V2979 (freeze (bind Rest& (shen.plug-wildcards (shen.lazyderef Rest V2979)) V2979 (freeze (bind Rest&& (shen.ue (shen.lazyderef Rest& V2979)) V2979 (freeze (shen.get-rules Rules Rest&& V2979 (freeze (cut Throwcontrol V2979 (freeze (shen.tc-rules F Rules ListA&& B&& (cons (cons F (cons : (cons Sig ()))) V2978) 1 V2979 (freeze (unify V2977 (cons (cons list (cons A ())) (cons ==> (cons B ()))) V2979 (freeze (bind Declare (declare (shen.lazyderef F V2979) (cons (cons list (cons (shen.lazyderef A V2979) ())) (cons ==> (cons (shen.lazyderef B V2979) ())))) V2979 V2980)))))))))))))))))))))))))))) false)) false))) false)) false)) false)) false))) false)) false)) false)) false)) false)) false))) false)) false)) false)))))

(defun shen.plug-wildcards (V2981) (cond ((cons? V2981) (map shen.plug-wildcards V2981)) ((= V2981 _) (gensym (intern "X"))) (true V2981)))

(defun shen.get-rules (V2982 V2983 V2984 V2985) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2460 (shen.lazyderef V2982 V2984) (if (= () V2460) (let V2461 (shen.lazyderef V2983 V2984) (if (= () V2461) (do (shen.incinfs) (cut Throwcontrol V2984 V2985)) false)) (if (shen.pvar? V2460) (do (shen.bindv V2460 () V2984) (let Result (let V2462 (shen.lazyderef V2983 V2984) (if (= () V2462) (do (shen.incinfs) (cut Throwcontrol V2984 V2985)) false)) (do (shen.unbindv V2460 V2984) Result))) false))) (if (= Case false) (let V2463 (shen.lazyderef V2982 V2984) (if (cons? V2463) (let Rule (hd V2463) (let Rules (tl V2463) (let Other (shen.newpv V2984) (do (shen.incinfs) (shen.first-rule V2983 Rule Other V2984 (freeze (cut Throwcontrol V2984 (freeze (shen.get-rules Rules Other V2984 V2985))))))))) (if (shen.pvar? V2463) (let Rule (shen.newpv V2984) (let Rules (shen.newpv V2984) (do (shen.bindv V2463 (cons Rule Rules) V2984) (let Result (let Other (shen.newpv V2984) (do (shen.incinfs) (shen.first-rule V2983 Rule Other V2984 (freeze (cut Throwcontrol V2984 (freeze (shen.get-rules Rules Other V2984 V2985))))))) (do (shen.unbindv V2463 V2984) Result))))) false))) Case)))))

(defun shen.first-rule (V2986 V2987 V2988 V2989 V2990) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2453 (shen.lazyderef V2986 V2989) (if (cons? V2453) (let V2454 (shen.lazyderef (hd V2453) V2989) (if (= ; V2454) (let Other2448 (tl V2453) (let V2455 (shen.lazyderef V2987 V2989) (if (= () V2455) (do (shen.incinfs) (unify! V2988 Other2448 V2989 (freeze (cut Throwcontrol V2989 V2990)))) (if (shen.pvar? V2455) (do (shen.bindv V2455 () V2989) (let Result (do (shen.incinfs) (unify! V2988 Other2448 V2989 (freeze (cut Throwcontrol V2989 V2990)))) (do (shen.unbindv V2455 V2989) Result))) false)))) false)) false)) (if (= Case false) (let V2456 (shen.lazyderef V2986 V2989) (if (cons? V2456) (let X2449 (hd V2456) (let Rest (tl V2456) (let V2457 (shen.lazyderef V2987 V2989) (if (cons? V2457) (let X (hd V2457) (let Rule (tl V2457) (do (shen.incinfs) (unify! X X2449 V2989 (freeze (shen.first-rule Rest Rule V2988 V2989 V2990)))))) (if (shen.pvar? V2457) (let X (shen.newpv V2989) (let Rule (shen.newpv V2989) (do (shen.bindv V2457 (cons X Rule) V2989) (let Result (do (shen.incinfs) (unify! X X2449 V2989 (freeze (shen.first-rule Rest Rule V2988 V2989 V2990)))) (do (shen.unbindv V2457 V2989) Result))))) false))))) false)) Case)))))

(defun shen.tc-rules (V2991 V2992 V2993 V2994 V2995 V2996 V2997 V2998) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2442 (shen.lazyderef V2992 V2997) (if (= () V2442) (do (shen.incinfs) (thaw V2998)) false)) (if (= Case false) (let V2443 (shen.lazyderef V2992 V2997) (if (cons? V2443) (let Rule (hd V2443) (let Rules (tl V2443) (let V2444 (shen.lazyderef V2993 V2997) (if (cons? V2444) (let V2445 (shen.lazyderef (hd V2444) V2997) (if (= list V2445) (let V2446 (shen.lazyderef (tl V2444) V2997) (if (cons? V2446) (let A (hd V2446) (let V2447 (shen.lazyderef (tl V2446) V2997) (if (= () V2447) (let M (shen.newpv V2997) (do (shen.incinfs) (shen.tc-rule V2991 Rule A V2994 V2995 V2996 V2997 (freeze (bind M (+ (shen.deref V2996 V2997) 1) V2997 (freeze (cut Throwcontrol V2997 (freeze (shen.tc-rules V2991 Rules (cons list (cons A ())) V2994 V2995 M V2997 V2998))))))))) false))) false)) false)) false)))) false)) Case)))))

(defun shen.tc-rule (V2999 V3000 V3001 V3002 V3003 V3004 V3005 V3006) (let Case (do (shen.incinfs) (shen.check-defcc-rule V3000 V3001 V3002 V3003 V3005 V3006)) (if (= Case false) (let Err (shen.newpv V3005) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V3004 V3005) (cn " of " (shen.app (shen.lazyderef V2999 V3005) "" shen.a)) shen.a))) V3005 V3006))) Case)))

(defun shen.check-defcc-rule (V3007 V3008 V3009 V3010 V3011 V3012) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Syntax (shen.newpv V3011) (let Semantics (shen.newpv V3011) (let SynHyps (shen.newpv V3011) (do (shen.incinfs) (shen.get-syntax+semantics Syntax Semantics V3007 V3011 (freeze (cut Throwcontrol V3011 (freeze (shen.syntax-hyps Syntax V3010 SynHyps V3008 V3011 (freeze (cut Throwcontrol V3011 (freeze (shen.syntax-check Syntax V3008 SynHyps V3011 (freeze (cut Throwcontrol V3011 (freeze (shen.semantics-check Semantics V3009 SynHyps V3011 V3012))))))))))))))))))))

(defun shen.syntax-hyps (V3013 V3014 V3015 V3016 V3017 V3018) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2415 (shen.lazyderef V3013 V3017) (if (= () V2415) (do (shen.incinfs) (unify! V3015 V3014 V3017 V3018)) false)) (if (= Case false) (let Case (let V2416 (shen.lazyderef V3013 V3017) (if (cons? V2416) (let X2409 (hd V2416) (let Y (tl V2416) (let V2417 (shen.lazyderef V3015 V3017) (if (cons? V2417) (let V2418 (shen.lazyderef (hd V2417) V3017) (if (cons? V2418) (let X (hd V2418) (let V2419 (shen.lazyderef (tl V2418) V3017) (if (cons? V2419) (let V2420 (shen.lazyderef (hd V2419) V3017) (if (= : V2420) (let V2421 (shen.lazyderef (tl V2419) V3017) (if (cons? V2421) (let A2410 (hd V2421) (let V2422 (shen.lazyderef (tl V2421) V3017) (if (= () V2422) (let SynHyps (tl V2417) (do (shen.incinfs) (unify! V3016 A2410 V3017 (freeze (unify! X X2409 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018))))))))))) (if (shen.pvar? V2422) (do (shen.bindv V2422 () V3017) (let Result (let SynHyps (tl V2417) (do (shen.incinfs) (unify! V3016 A2410 V3017 (freeze (unify! X X2409 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018))))))))))) (do (shen.unbindv V2422 V3017) Result))) false)))) (if (shen.pvar? V2421) (let A2410 (shen.newpv V3017) (do (shen.bindv V2421 (cons A2410 ()) V3017) (let Result (let SynHyps (tl V2417) (do (shen.incinfs) (unify! V3016 A2410 V3017 (freeze (unify! X X2409 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018))))))))))) (do (shen.unbindv V2421 V3017) Result)))) false))) (if (shen.pvar? V2420) (do (shen.bindv V2420 : V3017) (let Result (let V2423 (shen.lazyderef (tl V2419) V3017) (if (cons? V2423) (let A2410 (hd V2423) (let V2424 (shen.lazyderef (tl V2423) V3017) (if (= () V2424) (let SynHyps (tl V2417) (do (shen.incinfs) (unify! V3016 A2410 V3017 (freeze (unify! X X2409 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018))))))))))) (if (shen.pvar? V2424) (do (shen.bindv V2424 () V3017) (let Result (let SynHyps (tl V2417) (do (shen.incinfs) (unify! V3016 A2410 V3017 (freeze (unify! X X2409 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018))))))))))) (do (shen.unbindv V2424 V3017) Result))) false)))) (if (shen.pvar? V2423) (let A2410 (shen.newpv V3017) (do (shen.bindv V2423 (cons A2410 ()) V3017) (let Result (let SynHyps (tl V2417) (do (shen.incinfs) (unify! V3016 A2410 V3017 (freeze (unify! X X2409 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018))))))))))) (do (shen.unbindv V2423 V3017) Result)))) false))) (do (shen.unbindv V2420 V3017) Result))) false))) (if (shen.pvar? V2419) (let A2410 (shen.newpv V3017) (do (shen.bindv V2419 (cons : (cons A2410 ())) V3017) (let Result (let SynHyps (tl V2417) (do (shen.incinfs) (unify! V3016 A2410 V3017 (freeze (unify! X X2409 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018))))))))))) (do (shen.unbindv V2419 V3017) Result)))) false)))) (if (shen.pvar? V2418) (let X (shen.newpv V3017) (let A2410 (shen.newpv V3017) (do (shen.bindv V2418 (cons X (cons : (cons A2410 ()))) V3017) (let Result (let SynHyps (tl V2417) (do (shen.incinfs) (unify! V3016 A2410 V3017 (freeze (unify! X X2409 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018))))))))))) (do (shen.unbindv V2418 V3017) Result))))) false))) (if (shen.pvar? V2417) (let X (shen.newpv V3017) (let A2410 (shen.newpv V3017) (let SynHyps (shen.newpv V3017) (do (shen.bindv V2417 (cons (cons X (cons : (cons A2410 ()))) SynHyps) V3017) (let Result (do (shen.incinfs) (unify! V3016 A2410 V3017 (freeze (unify! X X2409 V3017 (freeze (fwhen (shen.ue? (shen.deref X V3017)) V3017 (freeze (cut Throwcontrol V3017 (freeze (shen.syntax-hyps Y V3014 SynHyps V3016 V3017 V3018)))))))))) (do (shen.unbindv V2417 V3017) Result)))))) false))))) false)) (if (= Case false) (let V2425 (shen.lazyderef V3013 V3017) (if (cons? V2425) (let Y (tl V2425) (do (shen.incinfs) (shen.syntax-hyps Y V3014 V3015 V3016 V3017 V3018))) false)) Case)) Case)))))

(defun shen.get-syntax+semantics (V3019 V3020 V3021 V3022 V3023) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2381 (shen.lazyderef V3019 V3022) (if (= () V2381) (let V2382 (shen.lazyderef V3021 V3022) (if (cons? V2382) (let V2383 (shen.lazyderef (hd V2382) V3022) (if (= := V2383) (let V2384 (shen.lazyderef (tl V2382) V3022) (if (cons? V2384) (let Semantics (hd V2384) (let V2385 (shen.lazyderef (tl V2384) V3022) (if (= () V2385) (do (shen.incinfs) (cut Throwcontrol V3022 (freeze (bind V3020 (shen.lazyderef Semantics V3022) V3022 V3023)))) false))) false)) false)) false)) (if (shen.pvar? V2381) (do (shen.bindv V2381 () V3022) (let Result (let V2386 (shen.lazyderef V3021 V3022) (if (cons? V2386) (let V2387 (shen.lazyderef (hd V2386) V3022) (if (= := V2387) (let V2388 (shen.lazyderef (tl V2386) V3022) (if (cons? V2388) (let Semantics (hd V2388) (let V2389 (shen.lazyderef (tl V2388) V3022) (if (= () V2389) (do (shen.incinfs) (cut Throwcontrol V3022 (freeze (bind V3020 (shen.lazyderef Semantics V3022) V3022 V3023)))) false))) false)) false)) false)) (do (shen.unbindv V2381 V3022) Result))) false))) (if (= Case false) (let Case (let V2390 (shen.lazyderef V3019 V3022) (if (= () V2390) (let V2391 (shen.lazyderef V3021 V3022) (if (cons? V2391) (let V2392 (shen.lazyderef (hd V2391) V3022) (if (= := V2392) (let V2393 (shen.lazyderef (tl V2391) V3022) (if (cons? V2393) (let Semantics (hd V2393) (let V2394 (shen.lazyderef (tl V2393) V3022) (if (cons? V2394) (let V2395 (shen.lazyderef (hd V2394) V3022) (if (= where V2395) (let V2396 (shen.lazyderef (tl V2394) V3022) (if (cons? V2396) (let G (hd V2396) (let V2397 (shen.lazyderef (tl V2396) V3022) (if (= () V2397) (do (shen.incinfs) (cut Throwcontrol V3022 (freeze (bind V3020 (cons where (cons (shen.lazyderef G V3022) (cons (shen.lazyderef Semantics V3022) ()))) V3022 V3023)))) false))) false)) false)) false))) false)) false)) false)) (if (shen.pvar? V2390) (do (shen.bindv V2390 () V3022) (let Result (let V2398 (shen.lazyderef V3021 V3022) (if (cons? V2398) (let V2399 (shen.lazyderef (hd V2398) V3022) (if (= := V2399) (let V2400 (shen.lazyderef (tl V2398) V3022) (if (cons? V2400) (let Semantics (hd V2400) (let V2401 (shen.lazyderef (tl V2400) V3022) (if (cons? V2401) (let V2402 (shen.lazyderef (hd V2401) V3022) (if (= where V2402) (let V2403 (shen.lazyderef (tl V2401) V3022) (if (cons? V2403) (let G (hd V2403) (let V2404 (shen.lazyderef (tl V2403) V3022) (if (= () V2404) (do (shen.incinfs) (cut Throwcontrol V3022 (freeze (bind V3020 (cons where (cons (shen.lazyderef G V3022) (cons (shen.lazyderef Semantics V3022) ()))) V3022 V3023)))) false))) false)) false)) false))) false)) false)) false)) (do (shen.unbindv V2390 V3022) Result))) false))) (if (= Case false) (let V2405 (shen.lazyderef V3019 V3022) (if (cons? V2405) (let X2377 (hd V2405) (let Syntax (tl V2405) (let V2406 (shen.lazyderef V3021 V3022) (if (cons? V2406) (let X (hd V2406) (let Rule (tl V2406) (do (shen.incinfs) (unify! X X2377 V3022 (freeze (shen.get-syntax+semantics Syntax V3020 Rule V3022 V3023)))))) false)))) (if (shen.pvar? V2405) (let X2377 (shen.newpv V3022) (let Syntax (shen.newpv V3022) (do (shen.bindv V2405 (cons X2377 Syntax) V3022) (let Result (let V2407 (shen.lazyderef V3021 V3022) (if (cons? V2407) (let X (hd V2407) (let Rule (tl V2407) (do (shen.incinfs) (unify! X X2377 V3022 (freeze (shen.get-syntax+semantics Syntax V3020 Rule V3022 V3023)))))) false)) (do (shen.unbindv V2405 V3022) Result))))) false))) Case)) Case)))))

(defun shen.syntax-check (V3024 V3025 V3026 V3027 V3028) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2374 (shen.lazyderef V3024 V3027) (if (= () V2374) (do (shen.incinfs) (thaw V3028)) false)) (if (= Case false) (let Case (let V2375 (shen.lazyderef V3024 V3027) (if (cons? V2375) (let X (hd V2375) (let Syntax (tl V2375) (let C (shen.newpv V3027) (let X&& (shen.newpv V3027) (let B (shen.newpv V3027) (do (shen.incinfs) (fwhen (shen.grammar_symbol? (shen.lazyderef X V3027)) V3027 (freeze (cut Throwcontrol V3027 (freeze (shen.t* (cons X (cons : (cons (cons (cons list (cons B ())) (cons ==> (cons C ()))) ()))) V3026 V3027 (freeze (cut Throwcontrol V3027 (freeze (bind X&& (concat && (shen.lazyderef X V3027)) V3027 (freeze (cut Throwcontrol V3027 (freeze (shen.t* (cons X&& (cons : (cons (cons list (cons V3025 ())) ()))) (cons (cons X&& (cons : (cons (cons list (cons B ())) ()))) V3026) V3027 (freeze (cut Throwcontrol V3027 (freeze (shen.syntax-check Syntax V3025 V3026 V3027 V3028))))))))))))))))))))))) false)) (if (= Case false) (let V2376 (shen.lazyderef V3024 V3027) (if (cons? V2376) (let X (hd V2376) (let Syntax (tl V2376) (do (shen.incinfs) (shen.t* (cons X (cons : (cons V3025 ()))) V3026 V3027 (freeze (cut Throwcontrol V3027 (freeze (shen.syntax-check Syntax V3025 V3026 V3027 V3028)))))))) false)) Case)) Case)))))

(defun shen.semantics-check (V3029 V3030 V3031 V3032 V3033) (let Semantics* (shen.newpv V3032) (do (shen.incinfs) (bind Semantics* (shen.curry (shen.rename-semantics (shen.deref V3029 V3032))) V3032 (freeze (shen.t* (cons Semantics* (cons : (cons V3030 ()))) V3031 V3032 V3033))))))

(defun shen.rename-semantics (V3034) (cond ((cons? V3034) (cons (shen.rename-semantics (hd V3034)) (shen.rename-semantics (tl V3034)))) ((shen.grammar_symbol? V3034) (cons shen.<-sem (cons V3034 ()))) (true V3034)))



