"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.<defprolog> (V907) (let Result (let Parse_shen.<predicate*> (shen.<predicate*> V907) (if (not (= (fail) Parse_shen.<predicate*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (hd (shen.prolog->shen (map (lambda Parse_X (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>) Parse_X)) (shen.hdtl Parse_shen.<clauses*>))))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.prolog-error (V914 V915) (cond ((and (cons? V915) (and (cons? (tl V915)) (= () (tl (tl V915))))) (simple-error (cn "prolog syntax error in " (shen.app V914 (cn " here:

 " (shen.app (shen.next-50 50 (hd V915)) "
" shen.a)) shen.a)))) (true (simple-error (cn "prolog syntax error in " (shen.app V914 "
" shen.a))))))

(defun shen.next-50 (V920 V921) (cond ((= () V921) "") ((= 0 V920) "") ((cons? V921) (cn (shen.decons-string (hd V921)) (shen.next-50 (- V920 1) (tl V921)))) (true (shen.sys-error shen.next-50))))

(defun shen.decons-string (V922) (cond ((and (cons? V922) (and (= cons (hd V922)) (and (cons? (tl V922)) (and (cons? (tl (tl V922))) (= () (tl (tl (tl V922)))))))) (shen.app (shen.eval-cons V922) " " shen.s)) (true (shen.app V922 " " shen.r))))

(defun shen.insert-predicate (V923 V924) (cond ((and (cons? V924) (and (cons? (tl V924)) (= () (tl (tl V924))))) (cons (cons V923 (hd V924)) (cons :- (tl V924)))) (true (shen.sys-error shen.insert-predicate))))

(defun shen.<predicate*> (V929) (let Result (if (cons? (hd V929)) (let Parse_X (hd (hd V929)) (shen.pair (hd (shen.pair (tl (hd V929)) (shen.hdtl V929))) Parse_X)) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<clauses*> (V934) (let Result (let Parse_shen.<clause*> (shen.<clause*> V934) (if (not (= (fail) Parse_shen.<clause*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (cons (shen.hdtl Parse_shen.<clause*>) (shen.hdtl Parse_shen.<clauses*>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V934) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (append (shen.hdtl Parse_<e>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<clause*> (V939) (let Result (let Parse_shen.<head*> (shen.<head*> V939) (if (not (= (fail) Parse_shen.<head*>)) (if (and (cons? (hd Parse_shen.<head*>)) (= <-- (hd (hd Parse_shen.<head*>)))) (let Parse_shen.<body*> (shen.<body*> (shen.pair (tl (hd Parse_shen.<head*>)) (shen.hdtl Parse_shen.<head*>))) (if (not (= (fail) Parse_shen.<body*>)) (let Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>) (if (not (= (fail) Parse_shen.<end*>)) (shen.pair (hd Parse_shen.<end*>) (cons (shen.hdtl Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<body*>) ()))) (fail))) (fail))) (fail)) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<head*> (V944) (let Result (let Parse_shen.<term*> (shen.<term*> V944) (if (not (= (fail) Parse_shen.<term*>)) (let Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>) (if (not (= (fail) Parse_shen.<head*>)) (shen.pair (hd Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V944) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (append (shen.hdtl Parse_<e>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<term*> (V949) (let Result (if (cons? (hd V949)) (let Parse_X (hd (hd V949)) (if (and (not (= <-- Parse_X)) (shen.legitimate-term? Parse_X)) (shen.pair (hd (shen.pair (tl (hd V949)) (shen.hdtl V949))) (shen.eval-cons Parse_X)) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.legitimate-term? (V954) (cond ((and (cons? V954) (and (= cons (hd V954)) (and (cons? (tl V954)) (and (cons? (tl (tl V954))) (= () (tl (tl (tl V954)))))))) (and (shen.legitimate-term? (hd (tl V954))) (shen.legitimate-term? (hd (tl (tl V954)))))) ((and (cons? V954) (and (= mode (hd V954)) (and (cons? (tl V954)) (and (cons? (tl (tl V954))) (and (= + (hd (tl (tl V954)))) (= () (tl (tl (tl V954))))))))) (shen.legitimate-term? (hd (tl V954)))) ((and (cons? V954) (and (= mode (hd V954)) (and (cons? (tl V954)) (and (cons? (tl (tl V954))) (and (= - (hd (tl (tl V954)))) (= () (tl (tl (tl V954))))))))) (shen.legitimate-term? (hd (tl V954)))) ((cons? V954) false) (true true)))

(defun shen.eval-cons (V955) (cond ((and (cons? V955) (and (= cons (hd V955)) (and (cons? (tl V955)) (and (cons? (tl (tl V955))) (= () (tl (tl (tl V955)))))))) (cons (shen.eval-cons (hd (tl V955))) (shen.eval-cons (hd (tl (tl V955)))))) ((and (cons? V955) (and (= mode (hd V955)) (and (cons? (tl V955)) (and (cons? (tl (tl V955))) (= () (tl (tl (tl V955)))))))) (cons mode (cons (shen.eval-cons (hd (tl V955))) (tl (tl V955))))) (true V955)))

(defun shen.<body*> (V960) (let Result (let Parse_shen.<literal*> (shen.<literal*> V960) (if (not (= (fail) Parse_shen.<literal*>)) (let Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>) (if (not (= (fail) Parse_shen.<body*>)) (shen.pair (hd Parse_shen.<body*>) (cons (shen.hdtl Parse_shen.<literal*>) (shen.hdtl Parse_shen.<body*>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V960) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (append (shen.hdtl Parse_<e>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<literal*> (V965) (let Result (if (and (cons? (hd V965)) (= ! (hd (hd V965)))) (shen.pair (hd (shen.pair (tl (hd V965)) (shen.hdtl V965))) (cons cut (cons (intern "Throwcontrol") ()))) (fail)) (if (= Result (fail)) (let Result (if (cons? (hd V965)) (let Parse_X (hd (hd V965)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V965)) (shen.hdtl V965))) Parse_X) (fail))) (fail)) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<end*> (V970) (let Result (if (cons? (hd V970)) (let Parse_X (hd (hd V970)) (if (= Parse_X ;) (shen.pair (hd (shen.pair (tl (hd V970)) (shen.hdtl V970))) Parse_X) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun cut (V971 V972 V973) (let Result (thaw V973) (if (= Result false) V971 Result)))

(defun shen.insert_modes (V974) (cond ((and (cons? V974) (and (= mode (hd V974)) (and (cons? (tl V974)) (and (cons? (tl (tl V974))) (= () (tl (tl (tl V974)))))))) V974) ((= () V974) ()) ((cons? V974) (cons (cons mode (cons (hd V974) (cons + ()))) (cons mode (cons (shen.insert_modes (tl V974)) (cons - ()))))) (true V974)))

(defun shen.s-prolog (V975) (map (lambda V901 (eval V901)) (shen.prolog->shen V975)))

(defun shen.prolog->shen (V976) (map shen.compile_prolog_procedure (shen.group_clauses (map shen.s-prolog_clause (mapcan shen.head_abstraction V976)))))

(defun shen.s-prolog_clause (V977) (cond ((and (cons? V977) (and (cons? (tl V977)) (and (= :- (hd (tl V977))) (and (cons? (tl (tl V977))) (= () (tl (tl (tl V977)))))))) (cons (hd V977) (cons :- (cons (map shen.s-prolog_literal (hd (tl (tl V977)))) ())))) (true (shen.sys-error shen.s-prolog_clause))))

(defun shen.head_abstraction (V978) (cond ((and (cons? V978) (and (cons? (tl V978)) (and (= :- (hd (tl V978))) (and (cons? (tl (tl V978))) (and (= () (tl (tl (tl V978)))) (< (shen.complexity_head (hd V978)) (value shen.*maxcomplexity*))))))) (cons V978 ())) ((and (cons? V978) (and (cons? (hd V978)) (and (cons? (tl V978)) (and (= :- (hd (tl V978))) (and (cons? (tl (tl V978))) (= () (tl (tl (tl V978))))))))) (let Terms (map (lambda Y (gensym V)) (tl (hd V978))) (let XTerms (shen.rcons_form (shen.remove_modes (tl (hd V978)))) (let Literal (cons unify (cons (shen.cons_form Terms) (cons XTerms ()))) (let Clause (cons (cons (hd (hd V978)) Terms) (cons :- (cons (cons Literal (hd (tl (tl V978)))) ()))) (cons Clause ())))))) (true (shen.sys-error shen.head_abstraction))))

(defun shen.complexity_head (V983) (cond ((cons? V983) (shen.product (map shen.complexity (tl V983)))) (true (shen.sys-error shen.complexity_head))))

(defun shen.complexity (V991) (cond ((and (cons? V991) (and (= mode (hd V991)) (and (cons? (tl V991)) (and (cons? (hd (tl V991))) (and (= mode (hd (hd (tl V991)))) (and (cons? (tl (hd (tl V991)))) (and (cons? (tl (tl (hd (tl V991))))) (and (= () (tl (tl (tl (hd (tl V991)))))) (and (cons? (tl (tl V991))) (= () (tl (tl (tl V991))))))))))))) (shen.complexity (hd (tl V991)))) ((and (cons? V991) (and (= mode (hd V991)) (and (cons? (tl V991)) (and (cons? (hd (tl V991))) (and (cons? (tl (tl V991))) (and (= + (hd (tl (tl V991)))) (= () (tl (tl (tl V991)))))))))) (* 2 (* (shen.complexity (cons mode (cons (hd (hd (tl V991))) (tl (tl V991))))) (shen.complexity (cons mode (cons (tl (hd (tl V991))) (tl (tl V991)))))))) ((and (cons? V991) (and (= mode (hd V991)) (and (cons? (tl V991)) (and (cons? (hd (tl V991))) (and (cons? (tl (tl V991))) (and (= - (hd (tl (tl V991)))) (= () (tl (tl (tl V991)))))))))) (* (shen.complexity (cons mode (cons (hd (hd (tl V991))) (tl (tl V991))))) (shen.complexity (cons mode (cons (tl (hd (tl V991))) (tl (tl V991))))))) ((and (cons? V991) (and (= mode (hd V991)) (and (cons? (tl V991)) (and (cons? (tl (tl V991))) (and (= () (tl (tl (tl V991)))) (variable? (hd (tl V991)))))))) 1) ((and (cons? V991) (and (= mode (hd V991)) (and (cons? (tl V991)) (and (cons? (tl (tl V991))) (and (= + (hd (tl (tl V991)))) (= () (tl (tl (tl V991))))))))) 2) ((and (cons? V991) (and (= mode (hd V991)) (and (cons? (tl V991)) (and (cons? (tl (tl V991))) (and (= - (hd (tl (tl V991)))) (= () (tl (tl (tl V991))))))))) 1) (true (shen.complexity (cons mode (cons V991 (cons + ())))))))

(defun shen.product (V992) (cond ((= () V992) 1) ((cons? V992) (* (hd V992) (shen.product (tl V992)))) (true (shen.sys-error shen.product))))

(defun shen.s-prolog_literal (V993) (cond ((and (cons? V993) (and (= is (hd V993)) (and (cons? (tl V993)) (and (cons? (tl (tl V993))) (= () (tl (tl (tl V993)))))))) (cons bind (cons (hd (tl V993)) (cons (shen.insert_deref (hd (tl (tl V993)))) ())))) ((and (cons? V993) (and (= when (hd V993)) (and (cons? (tl V993)) (= () (tl (tl V993)))))) (cons fwhen (cons (shen.insert_deref (hd (tl V993))) ()))) ((and (cons? V993) (and (= bind (hd V993)) (and (cons? (tl V993)) (and (cons? (tl (tl V993))) (= () (tl (tl (tl V993)))))))) (cons bind (cons (hd (tl V993)) (cons (shen.insert_lazyderef (hd (tl (tl V993)))) ())))) ((and (cons? V993) (and (= fwhen (hd V993)) (and (cons? (tl V993)) (= () (tl (tl V993)))))) (cons fwhen (cons (shen.insert_lazyderef (hd (tl V993))) ()))) ((cons? V993) (cons (shen.m_prolog_to_s-prolog_predicate (hd V993)) (tl V993))) (true (shen.sys-error shen.s-prolog_literal))))

(defun shen.insert_deref (V994) (cond ((variable? V994) (cons shen.deref (cons V994 (cons ProcessN ())))) ((cons? V994) (cons (shen.insert_deref (hd V994)) (shen.insert_deref (tl V994)))) (true V994)))

(defun shen.insert_lazyderef (V995) (cond ((variable? V995) (cons shen.lazyderef (cons V995 (cons ProcessN ())))) ((cons? V995) (cons (shen.insert_lazyderef (hd V995)) (shen.insert_lazyderef (tl V995)))) (true V995)))

(defun shen.m_prolog_to_s-prolog_predicate (V996) (cond ((= = V996) unify) ((= =! V996) unify!) ((= == V996) identical) (true V996)))

(defun shen.group_clauses (V997) (cond ((= () V997) ()) ((cons? V997) (let Group (shen.collect (lambda X (shen.same_predicate? (hd V997) X)) V997) (let Rest (difference V997 Group) (cons Group (shen.group_clauses Rest))))) (true (shen.sys-error shen.group_clauses))))

(defun shen.collect (V1000 V1001) (cond ((= () V1001) ()) ((cons? V1001) (if (V1000 (hd V1001)) (cons (hd V1001) (shen.collect V1000 (tl V1001))) (shen.collect V1000 (tl V1001)))) (true (shen.sys-error shen.collect))))

(defun shen.same_predicate? (V1018 V1019) (cond ((and (cons? V1018) (and (cons? (hd V1018)) (and (cons? V1019) (cons? (hd V1019))))) (= (hd (hd V1018)) (hd (hd V1019)))) (true (shen.sys-error shen.same_predicate?))))

(defun shen.compile_prolog_procedure (V1020) (let F (shen.procedure_name V1020) (let Shen (shen.clauses-to-shen F V1020) Shen)))

(defun shen.procedure_name (V1033) (cond ((and (cons? V1033) (and (cons? (hd V1033)) (cons? (hd (hd V1033))))) (hd (hd (hd V1033)))) (true (shen.sys-error shen.procedure_name))))

(defun shen.clauses-to-shen (V1034 V1035) (let Linear (map shen.linearise-clause V1035) (let Arity (shen.prolog-aritycheck V1034 (map (lambda V902 (head V902)) V1035)) (let Parameters (shen.parameters Arity) (let AUM_instructions (map (lambda X (shen.aum X Parameters)) Linear) (let Code (shen.catch-cut (shen.nest-disjunct (map shen.aum_to_shen AUM_instructions))) (let ShenDef (cons define (cons V1034 (append Parameters (append (cons ProcessN (cons Continuation ())) (cons -> (cons Code ())))))) ShenDef)))))))

(defun shen.catch-cut (V1036) (cond ((not (shen.occurs? cut V1036)) V1036) (true (cons let (cons Throwcontrol (cons (cons shen.catchpoint ()) (cons (cons shen.cutpoint (cons Throwcontrol (cons V1036 ()))) ())))))))

(defun shen.catchpoint () (set shen.*catch* (+ 1 (value shen.*catch*))))

(defun shen.cutpoint (V1041 V1042) (cond ((= V1042 V1041) false) (true V1042)))

(defun shen.nest-disjunct (V1044) (cond ((and (cons? V1044) (= () (tl V1044))) (hd V1044)) ((cons? V1044) (shen.lisp-or (hd V1044) (shen.nest-disjunct (tl V1044)))) (true (shen.sys-error shen.nest-disjunct))))

(defun shen.lisp-or (V1045 V1046) (cons let (cons Case (cons V1045 (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons V1046 (cons Case ())))) ())))))

(defun shen.prolog-aritycheck (V1049 V1050) (cond ((and (cons? V1050) (= () (tl V1050))) (- (length (hd V1050)) 1)) ((and (cons? V1050) (cons? (tl V1050))) (if (= (length (hd V1050)) (length (hd (tl V1050)))) (shen.prolog-aritycheck V1049 (tl V1050)) (simple-error (cn "arity error in prolog procedure " (shen.app (cons V1049 ()) "
" shen.a))))) (true (shen.sys-error shen.prolog-aritycheck))))

(defun shen.linearise-clause (V1051) (cond ((and (cons? V1051) (and (cons? (tl V1051)) (and (= :- (hd (tl V1051))) (and (cons? (tl (tl V1051))) (= () (tl (tl (tl V1051)))))))) (let Linear (shen.linearise (cons (hd V1051) (tl (tl V1051)))) (shen.clause_form Linear))) (true (shen.sys-error shen.linearise-clause))))

(defun shen.clause_form (V1052) (cond ((and (cons? V1052) (and (cons? (tl V1052)) (= () (tl (tl V1052))))) (cons (shen.explicit_modes (hd V1052)) (cons :- (cons (shen.cf_help (hd (tl V1052))) ())))) (true (shen.sys-error shen.clause_form))))

(defun shen.explicit_modes (V1053) (cond ((cons? V1053) (cons (hd V1053) (map shen.em_help (tl V1053)))) (true (shen.sys-error shen.explicit_modes))))

(defun shen.em_help (V1054) (cond ((and (cons? V1054) (and (= mode (hd V1054)) (and (cons? (tl V1054)) (and (cons? (tl (tl V1054))) (= () (tl (tl (tl V1054)))))))) V1054) (true (cons mode (cons V1054 (cons + ()))))))

(defun shen.cf_help (V1055) (cond ((and (cons? V1055) (and (= where (hd V1055)) (and (cons? (tl V1055)) (and (cons? (hd (tl V1055))) (and (= = (hd (hd (tl V1055)))) (and (cons? (tl (hd (tl V1055)))) (and (cons? (tl (tl (hd (tl V1055))))) (and (= () (tl (tl (tl (hd (tl V1055)))))) (and (cons? (tl (tl V1055))) (= () (tl (tl (tl V1055))))))))))))) (cons (cons (if (value shen.*occurs*) unify! unify) (tl (hd (tl V1055)))) (shen.cf_help (hd (tl (tl V1055)))))) (true V1055)))

(defun occurs-check (V1060) (cond ((= + V1060) (set shen.*occurs* true)) ((= - V1060) (set shen.*occurs* false)) (true (simple-error "occurs-check expects + or -
"))))

(defun shen.aum (V1061 V1062) (cond ((and (cons? V1061) (and (cons? (hd V1061)) (and (cons? (tl V1061)) (and (= :- (hd (tl V1061))) (and (cons? (tl (tl V1061))) (= () (tl (tl (tl V1061))))))))) (let MuApplication (shen.make_mu_application (cons shen.mu (cons (tl (hd V1061)) (cons (shen.continuation_call (tl (hd V1061)) (hd (tl (tl V1061)))) ()))) V1062) (shen.mu_reduction MuApplication +))) (true (shen.sys-error shen.aum))))

(defun shen.continuation_call (V1063 V1064) (let VTerms (cons ProcessN (shen.extract_vars V1063)) (let VBody (shen.extract_vars V1064) (let Free (remove Throwcontrol (difference VBody VTerms)) (shen.cc_help Free V1064)))))

(defun remove (V1065 V1066) (shen.remove-h V1065 V1066 ()))

(defun shen.remove-h (V1069 V1070 V1071) (cond ((= () V1070) (reverse V1071)) ((and (cons? V1070) (= (hd V1070) V1069)) (shen.remove-h (hd V1070) (tl V1070) V1071)) ((cons? V1070) (shen.remove-h V1069 (tl V1070) (cons (hd V1070) V1071))) (true (shen.sys-error shen.remove-h))))

(defun shen.cc_help (V1073 V1074) (cond ((and (= () V1073) (= () V1074)) (cons shen.pop (cons shen.the (cons shen.stack ())))) ((= () V1074) (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1073 (cons and (cons shen.then (cons (cons shen.pop (cons shen.the (cons shen.stack ()))) ()))))))))) ((= () V1073) (cons call (cons shen.the (cons shen.continuation (cons V1074 ()))))) (true (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1073 (cons and (cons shen.then (cons (cons call (cons shen.the (cons shen.continuation (cons V1074 ())))) ())))))))))))

(defun shen.make_mu_application (V1075 V1076) (cond ((and (cons? V1075) (and (= shen.mu (hd V1075)) (and (cons? (tl V1075)) (and (= () (hd (tl V1075))) (and (cons? (tl (tl V1075))) (and (= () (tl (tl (tl V1075)))) (= () V1076))))))) (hd (tl (tl V1075)))) ((and (cons? V1075) (and (= shen.mu (hd V1075)) (and (cons? (tl V1075)) (and (cons? (hd (tl V1075))) (and (cons? (tl (tl V1075))) (and (= () (tl (tl (tl V1075)))) (cons? V1076))))))) (cons (cons shen.mu (cons (hd (hd (tl V1075))) (cons (shen.make_mu_application (cons shen.mu (cons (tl (hd (tl V1075))) (tl (tl V1075)))) (tl V1076)) ()))) (cons (hd V1076) ()))) (true (shen.sys-error shen.make_mu_application))))

(defun shen.mu_reduction (V1083 V1084) (cond ((and (cons? V1083) (and (cons? (hd V1083)) (and (= shen.mu (hd (hd V1083))) (and (cons? (tl (hd V1083))) (and (cons? (hd (tl (hd V1083)))) (and (= mode (hd (hd (tl (hd V1083))))) (and (cons? (tl (hd (tl (hd V1083))))) (and (cons? (tl (tl (hd (tl (hd V1083)))))) (and (= () (tl (tl (tl (hd (tl (hd V1083))))))) (and (cons? (tl (tl (hd V1083)))) (and (= () (tl (tl (tl (hd V1083))))) (and (cons? (tl V1083)) (= () (tl (tl V1083))))))))))))))) (shen.mu_reduction (cons (cons shen.mu (cons (hd (tl (hd (tl (hd V1083))))) (tl (tl (hd V1083))))) (tl V1083)) (hd (tl (tl (hd (tl (hd V1083)))))))) ((and (cons? V1083) (and (cons? (hd V1083)) (and (= shen.mu (hd (hd V1083))) (and (cons? (tl (hd V1083))) (and (cons? (tl (tl (hd V1083)))) (and (= () (tl (tl (tl (hd V1083))))) (and (cons? (tl V1083)) (and (= () (tl (tl V1083))) (= _ (hd (tl (hd V1083)))))))))))) (shen.mu_reduction (hd (tl (tl (hd V1083)))) V1084)) ((and (cons? V1083) (and (cons? (hd V1083)) (and (= shen.mu (hd (hd V1083))) (and (cons? (tl (hd V1083))) (and (cons? (tl (tl (hd V1083)))) (and (= () (tl (tl (tl (hd V1083))))) (and (cons? (tl V1083)) (and (= () (tl (tl V1083))) (shen.ephemeral_variable? (hd (tl (hd V1083))) (hd (tl V1083))))))))))) (subst (hd (tl V1083)) (hd (tl (hd V1083))) (shen.mu_reduction (hd (tl (tl (hd V1083)))) V1084))) ((and (cons? V1083) (and (cons? (hd V1083)) (and (= shen.mu (hd (hd V1083))) (and (cons? (tl (hd V1083))) (and (cons? (tl (tl (hd V1083)))) (and (= () (tl (tl (tl (hd V1083))))) (and (cons? (tl V1083)) (and (= () (tl (tl V1083))) (variable? (hd (tl (hd V1083)))))))))))) (cons let (cons (hd (tl (hd V1083))) (cons shen.be (cons (hd (tl V1083)) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1083)))) V1084) ()))))))) ((and (cons? V1083) (and (cons? (hd V1083)) (and (= shen.mu (hd (hd V1083))) (and (cons? (tl (hd V1083))) (and (cons? (tl (tl (hd V1083)))) (and (= () (tl (tl (tl (hd V1083))))) (and (cons? (tl V1083)) (and (= () (tl (tl V1083))) (and (= - V1084) (shen.prolog_constant? (hd (tl (hd V1083))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1083))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1083))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1083)))) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1083) (and (cons? (hd V1083)) (and (= shen.mu (hd (hd V1083))) (and (cons? (tl (hd V1083))) (and (cons? (tl (tl (hd V1083)))) (and (= () (tl (tl (tl (hd V1083))))) (and (cons? (tl V1083)) (and (= () (tl (tl V1083))) (and (= + V1084) (shen.prolog_constant? (hd (tl (hd V1083))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1083))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1083))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1083)))) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (hd (tl (hd V1083))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1083)))) +) ())))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) ((and (cons? V1083) (and (cons? (hd V1083)) (and (= shen.mu (hd (hd V1083))) (and (cons? (tl (hd V1083))) (and (cons? (hd (tl (hd V1083)))) (and (cons? (tl (tl (hd V1083)))) (and (= () (tl (tl (tl (hd V1083))))) (and (cons? (tl V1083)) (and (= () (tl (tl V1083))) (= - V1084)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1083))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1083)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1083)))) (tl (tl (hd V1083))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1083) (and (cons? (hd V1083)) (and (= shen.mu (hd (hd V1083))) (and (cons? (tl (hd V1083))) (and (cons? (hd (tl (hd V1083)))) (and (cons? (tl (tl (hd V1083)))) (and (= () (tl (tl (tl (hd V1083))))) (and (cons? (tl V1083)) (and (= () (tl (tl V1083))) (= + V1084)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1083))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1083)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1083)))) (tl (tl (hd V1083))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (shen.extract_vars (hd (tl (hd V1083)))) (cons and (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (shen.rcons_form (shen.remove_modes (hd (tl (hd V1083))))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1083)))) +) ())))))) ())))))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) (true V1083)))

(defun shen.rcons_form (V1085) (cond ((cons? V1085) (cons cons (cons (shen.rcons_form (hd V1085)) (cons (shen.rcons_form (tl V1085)) ())))) (true V1085)))

(defun shen.remove_modes (V1086) (cond ((and (cons? V1086) (and (= mode (hd V1086)) (and (cons? (tl V1086)) (and (cons? (tl (tl V1086))) (and (= + (hd (tl (tl V1086)))) (= () (tl (tl (tl V1086))))))))) (shen.remove_modes (hd (tl V1086)))) ((and (cons? V1086) (and (= mode (hd V1086)) (and (cons? (tl V1086)) (and (cons? (tl (tl V1086))) (and (= - (hd (tl (tl V1086)))) (= () (tl (tl (tl V1086))))))))) (shen.remove_modes (hd (tl V1086)))) ((cons? V1086) (cons (shen.remove_modes (hd V1086)) (shen.remove_modes (tl V1086)))) (true V1086)))

(defun shen.ephemeral_variable? (V1087 V1088) (and (variable? V1087) (variable? V1088)))

(defun shen.prolog_constant? (V1097) (cond ((cons? V1097) false) (true true)))

(defun shen.aum_to_shen (V1098) (cond ((and (cons? V1098) (and (= let (hd V1098)) (and (cons? (tl V1098)) (and (cons? (tl (tl V1098))) (and (= shen.be (hd (tl (tl V1098)))) (and (cons? (tl (tl (tl V1098)))) (and (cons? (tl (tl (tl (tl V1098))))) (and (= in (hd (tl (tl (tl (tl V1098)))))) (and (cons? (tl (tl (tl (tl (tl V1098)))))) (= () (tl (tl (tl (tl (tl (tl V1098)))))))))))))))) (cons let (cons (hd (tl V1098)) (cons (shen.aum_to_shen (hd (tl (tl (tl V1098))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1098))))))) ()))))) ((and (cons? V1098) (and (= shen.the (hd V1098)) (and (cons? (tl V1098)) (and (= shen.result (hd (tl V1098))) (and (cons? (tl (tl V1098))) (and (= shen.of (hd (tl (tl V1098)))) (and (cons? (tl (tl (tl V1098)))) (and (= shen.dereferencing (hd (tl (tl (tl V1098))))) (and (cons? (tl (tl (tl (tl V1098))))) (= () (tl (tl (tl (tl (tl V1098))))))))))))))) (cons shen.lazyderef (cons (shen.aum_to_shen (hd (tl (tl (tl (tl V1098)))))) (cons ProcessN ())))) ((and (cons? V1098) (and (= if (hd V1098)) (and (cons? (tl V1098)) (and (cons? (tl (tl V1098))) (and (= shen.then (hd (tl (tl V1098)))) (and (cons? (tl (tl (tl V1098)))) (and (cons? (tl (tl (tl (tl V1098))))) (and (= shen.else (hd (tl (tl (tl (tl V1098)))))) (and (cons? (tl (tl (tl (tl (tl V1098)))))) (= () (tl (tl (tl (tl (tl (tl V1098)))))))))))))))) (cons if (cons (shen.aum_to_shen (hd (tl V1098))) (cons (shen.aum_to_shen (hd (tl (tl (tl V1098))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1098))))))) ()))))) ((and (cons? V1098) (and (cons? (tl V1098)) (and (= is (hd (tl V1098))) (and (cons? (tl (tl V1098))) (and (= shen.a (hd (tl (tl V1098)))) (and (cons? (tl (tl (tl V1098)))) (and (= shen.variable (hd (tl (tl (tl V1098))))) (= () (tl (tl (tl (tl V1098)))))))))))) (cons shen.pvar? (cons (hd V1098) ()))) ((and (cons? V1098) (and (cons? (tl V1098)) (and (= is (hd (tl V1098))) (and (cons? (tl (tl V1098))) (and (= shen.a (hd (tl (tl V1098)))) (and (cons? (tl (tl (tl V1098)))) (and (= shen.non-empty (hd (tl (tl (tl V1098))))) (and (cons? (tl (tl (tl (tl V1098))))) (and (= list (hd (tl (tl (tl (tl V1098)))))) (= () (tl (tl (tl (tl (tl V1098))))))))))))))) (cons cons? (cons (hd V1098) ()))) ((and (cons? V1098) (and (= shen.rename (hd V1098)) (and (cons? (tl V1098)) (and (= shen.the (hd (tl V1098))) (and (cons? (tl (tl V1098))) (and (= shen.variables (hd (tl (tl V1098)))) (and (cons? (tl (tl (tl V1098)))) (and (= in (hd (tl (tl (tl V1098))))) (and (cons? (tl (tl (tl (tl V1098))))) (and (= () (hd (tl (tl (tl (tl V1098)))))) (and (cons? (tl (tl (tl (tl (tl V1098)))))) (and (= and (hd (tl (tl (tl (tl (tl V1098))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1098))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1098)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1098)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1098)))))))))))))))))))))))) (shen.aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V1098)))))))))) ((and (cons? V1098) (and (= shen.rename (hd V1098)) (and (cons? (tl V1098)) (and (= shen.the (hd (tl V1098))) (and (cons? (tl (tl V1098))) (and (= shen.variables (hd (tl (tl V1098)))) (and (cons? (tl (tl (tl V1098)))) (and (= in (hd (tl (tl (tl V1098))))) (and (cons? (tl (tl (tl (tl V1098))))) (and (cons? (hd (tl (tl (tl (tl V1098)))))) (and (cons? (tl (tl (tl (tl (tl V1098)))))) (and (= and (hd (tl (tl (tl (tl (tl V1098))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1098))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1098)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1098)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1098)))))))))))))))))))))))) (cons let (cons (hd (hd (tl (tl (tl (tl V1098)))))) (cons (cons shen.newpv (cons ProcessN ())) (cons (shen.aum_to_shen (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (tl (hd (tl (tl (tl (tl V1098)))))) (tl (tl (tl (tl (tl V1098))))))))))) ()))))) ((and (cons? V1098) (and (= bind (hd V1098)) (and (cons? (tl V1098)) (and (cons? (tl (tl V1098))) (and (= shen.to (hd (tl (tl V1098)))) (and (cons? (tl (tl (tl V1098)))) (and (cons? (tl (tl (tl (tl V1098))))) (and (= in (hd (tl (tl (tl (tl V1098)))))) (and (cons? (tl (tl (tl (tl (tl V1098)))))) (= () (tl (tl (tl (tl (tl (tl V1098)))))))))))))))) (cons do (cons (cons shen.bindv (cons (hd (tl V1098)) (cons (shen.chwild (hd (tl (tl (tl V1098))))) (cons ProcessN ())))) (cons (cons let (cons Result (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1098))))))) (cons (cons do (cons (cons shen.unbindv (cons (hd (tl V1098)) (cons ProcessN ()))) (cons Result ()))) ())))) ())))) ((and (cons? V1098) (and (cons? (tl V1098)) (and (= is (hd (tl V1098))) (and (cons? (tl (tl V1098))) (and (= identical (hd (tl (tl V1098)))) (and (cons? (tl (tl (tl V1098)))) (and (= shen.to (hd (tl (tl (tl V1098))))) (and (cons? (tl (tl (tl (tl V1098))))) (= () (tl (tl (tl (tl (tl V1098)))))))))))))) (cons = (cons (hd (tl (tl (tl (tl V1098))))) (cons (hd V1098) ())))) ((= shen.failed! V1098) false) ((and (cons? V1098) (and (= shen.the (hd V1098)) (and (cons? (tl V1098)) (and (= head (hd (tl V1098))) (and (cons? (tl (tl V1098))) (and (= shen.of (hd (tl (tl V1098)))) (and (cons? (tl (tl (tl V1098)))) (= () (tl (tl (tl (tl V1098)))))))))))) (cons hd (tl (tl (tl V1098))))) ((and (cons? V1098) (and (= shen.the (hd V1098)) (and (cons? (tl V1098)) (and (= tail (hd (tl V1098))) (and (cons? (tl (tl V1098))) (and (= shen.of (hd (tl (tl V1098)))) (and (cons? (tl (tl (tl V1098)))) (= () (tl (tl (tl (tl V1098)))))))))))) (cons tl (tl (tl (tl V1098))))) ((and (cons? V1098) (and (= shen.pop (hd V1098)) (and (cons? (tl V1098)) (and (= shen.the (hd (tl V1098))) (and (cons? (tl (tl V1098))) (and (= shen.stack (hd (tl (tl V1098)))) (= () (tl (tl (tl V1098)))))))))) (cons do (cons (cons shen.incinfs ()) (cons (cons thaw (cons Continuation ())) ())))) ((and (cons? V1098) (and (= call (hd V1098)) (and (cons? (tl V1098)) (and (= shen.the (hd (tl V1098))) (and (cons? (tl (tl V1098))) (and (= shen.continuation (hd (tl (tl V1098)))) (and (cons? (tl (tl (tl V1098)))) (= () (tl (tl (tl (tl V1098)))))))))))) (cons do (cons (cons shen.incinfs ()) (cons (shen.call_the_continuation (shen.chwild (hd (tl (tl (tl V1098))))) ProcessN Continuation) ())))) (true V1098)))

(defun shen.chwild (V1099) (cond ((= V1099 _) (cons shen.newpv (cons ProcessN ()))) ((cons? V1099) (map shen.chwild V1099)) (true V1099)))

(defun shen.newpv (V1100) (let Count+1 (+ (<-address (value shen.*varcounter*) V1100) 1) (let IncVar (address-> (value shen.*varcounter*) V1100 Count+1) (let Vector (<-address (value shen.*prologvectors*) V1100) (let ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen.resizeprocessvector V1100 Count+1) shen.skip) (shen.mk-pvar Count+1))))))

(defun shen.resizeprocessvector (V1101 V1102) (let Vector (<-address (value shen.*prologvectors*) V1101) (let BigVector (shen.resize-vector Vector (+ V1102 V1102) shen.-null-) (address-> (value shen.*prologvectors*) V1101 BigVector))))

(defun shen.resize-vector (V1103 V1104 V1105) (let BigVector (address-> (absvector (+ 1 V1104)) 0 V1104) (shen.copy-vector V1103 BigVector (limit V1103) V1104 V1105)))

(defun shen.copy-vector (V1106 V1107 V1108 V1109 V1110) (shen.copy-vector-stage-2 (+ 1 V1108) (+ V1109 1) V1110 (shen.copy-vector-stage-1 1 V1106 V1107 (+ 1 V1108))))

(defun shen.copy-vector-stage-1 (V1113 V1114 V1115 V1116) (cond ((= V1116 V1113) V1115) (true (shen.copy-vector-stage-1 (+ 1 V1113) V1114 (address-> V1115 V1113 (<-address V1114 V1113)) V1116))))

(defun shen.copy-vector-stage-2 (V1120 V1121 V1122 V1123) (cond ((= V1121 V1120) V1123) (true (shen.copy-vector-stage-2 (+ V1120 1) V1121 V1122 (address-> V1123 V1120 V1122)))))

(defun shen.mk-pvar (V1125) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V1125))

(defun shen.pvar? (V1126) (and (absvector? V1126) (= (<-address V1126 0) shen.pvar)))

(defun shen.bindv (V1127 V1128 V1129) (let Vector (<-address (value shen.*prologvectors*) V1129) (address-> Vector (<-address V1127 1) V1128)))

(defun shen.unbindv (V1130 V1131) (let Vector (<-address (value shen.*prologvectors*) V1131) (address-> Vector (<-address V1130 1) shen.-null-)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.call_the_continuation (V1132 V1133 V1134) (cond ((and (cons? V1132) (and (cons? (hd V1132)) (= () (tl V1132)))) (cons (hd (hd V1132)) (append (tl (hd V1132)) (cons V1133 (cons V1134 ()))))) ((and (cons? V1132) (cons? (hd V1132))) (let NewContinuation (shen.newcontinuation (tl V1132) V1133 V1134) (cons (hd (hd V1132)) (append (tl (hd V1132)) (cons V1133 (cons NewContinuation ())))))) (true (shen.sys-error shen.call_the_continuation))))

(defun shen.newcontinuation (V1135 V1136 V1137) (cond ((= () V1135) V1137) ((and (cons? V1135) (cons? (hd V1135))) (cons freeze (cons (cons (hd (hd V1135)) (append (tl (hd V1135)) (cons V1136 (cons (shen.newcontinuation (tl V1135) V1136 V1137) ())))) ()))) (true (shen.sys-error shen.newcontinuation))))

(defun return (V1142 V1143 V1144) (shen.deref V1142 V1143))

(defun shen.measure&return (V1149 V1150 V1151) (do (shen.prhush (shen.app (value shen.*infs*) " inferences
" shen.a) (stoutput)) (shen.deref V1149 V1150)))

(defun unify (V1152 V1153 V1154 V1155) (shen.lzy= (shen.lazyderef V1152 V1154) (shen.lazyderef V1153 V1154) V1154 V1155))

(defun shen.lzy= (V1172 V1173 V1174 V1175) (cond ((= V1173 V1172) (thaw V1175)) ((shen.pvar? V1172) (bind V1172 V1173 V1174 V1175)) ((shen.pvar? V1173) (bind V1173 V1172 V1174 V1175)) ((and (cons? V1172) (cons? V1173)) (shen.lzy= (shen.lazyderef (hd V1172) V1174) (shen.lazyderef (hd V1173) V1174) V1174 (freeze (shen.lzy= (shen.lazyderef (tl V1172) V1174) (shen.lazyderef (tl V1173) V1174) V1174 V1175)))) (true false)))

(defun shen.deref (V1177 V1178) (cond ((cons? V1177) (cons (shen.deref (hd V1177) V1178) (shen.deref (tl V1177) V1178))) (true (if (shen.pvar? V1177) (let Value (shen.valvector V1177 V1178) (if (= Value shen.-null-) V1177 (shen.deref Value V1178))) V1177))))

(defun shen.lazyderef (V1179 V1180) (if (shen.pvar? V1179) (let Value (shen.valvector V1179 V1180) (if (= Value shen.-null-) V1179 (shen.lazyderef Value V1180))) V1179))

(defun shen.valvector (V1181 V1182) (<-address (<-address (value shen.*prologvectors*) V1182) (<-address V1181 1)))

(defun unify! (V1183 V1184 V1185 V1186) (shen.lzy=! (shen.lazyderef V1183 V1185) (shen.lazyderef V1184 V1185) V1185 V1186))

(defun shen.lzy=! (V1203 V1204 V1205 V1206) (cond ((= V1204 V1203) (thaw V1206)) ((and (shen.pvar? V1203) (not (shen.occurs? V1203 (shen.deref V1204 V1205)))) (bind V1203 V1204 V1205 V1206)) ((and (shen.pvar? V1204) (not (shen.occurs? V1204 (shen.deref V1203 V1205)))) (bind V1204 V1203 V1205 V1206)) ((and (cons? V1203) (cons? V1204)) (shen.lzy=! (shen.lazyderef (hd V1203) V1205) (shen.lazyderef (hd V1204) V1205) V1205 (freeze (shen.lzy=! (shen.lazyderef (tl V1203) V1205) (shen.lazyderef (tl V1204) V1205) V1205 V1206)))) (true false)))

(defun shen.occurs? (V1216 V1217) (cond ((= V1217 V1216) true) ((cons? V1217) (or (shen.occurs? V1216 (hd V1217)) (shen.occurs? V1216 (tl V1217)))) (true false)))

(defun identical (V1219 V1220 V1221 V1222) (shen.lzy== (shen.lazyderef V1219 V1221) (shen.lazyderef V1220 V1221) V1221 V1222))

(defun shen.lzy== (V1239 V1240 V1241 V1242) (cond ((= V1240 V1239) (thaw V1242)) ((and (cons? V1239) (cons? V1240)) (shen.lzy== (shen.lazyderef (hd V1239) V1241) (shen.lazyderef (hd V1240) V1241) V1241 (freeze (shen.lzy== (tl V1239) (tl V1240) V1241 V1242)))) (true false)))

(defun shen.pvar (V1244) (cn "Var" (shen.app (<-address V1244 1) "" shen.a)))

(defun bind (V1245 V1246 V1247 V1248) (do (shen.bindv V1245 V1246 V1247) (let Result (thaw V1248) (do (shen.unbindv V1245 V1247) Result))))

(defun fwhen (V1263 V1264 V1265) (cond ((= true V1263) (thaw V1265)) ((= false V1263) false) (true (simple-error (cn "fwhen expects a boolean: not " (shen.app V1263 "%" shen.s))))))

(defun call (V1278 V1279 V1280) (cond ((cons? V1278) (shen.call-help (shen.m_prolog_to_s-prolog_predicate (shen.lazyderef (hd V1278) V1279)) (tl V1278) V1279 V1280)) (true false)))

(defun shen.call-help (V1281 V1282 V1283 V1284) (cond ((= () V1282) (V1281 V1283 V1284)) ((cons? V1282) (shen.call-help (V1281 (hd V1282)) (tl V1282) V1283 V1284)) (true (shen.sys-error shen.call-help))))

(defun shen.intprolog (V1285) (cond ((and (cons? V1285) (cons? (hd V1285))) (let ProcessN (shen.start-new-prolog-process) (shen.intprolog-help (hd (hd V1285)) (shen.insert-prolog-variables (cons (tl (hd V1285)) (cons (tl V1285) ())) ProcessN) ProcessN))) (true (shen.sys-error shen.intprolog))))

(defun shen.intprolog-help (V1286 V1287 V1288) (cond ((and (cons? V1287) (and (cons? (tl V1287)) (= () (tl (tl V1287))))) (shen.intprolog-help-help V1286 (hd V1287) (hd (tl V1287)) V1288)) (true (shen.sys-error shen.intprolog-help))))

(defun shen.intprolog-help-help (V1289 V1290 V1291 V1292) (cond ((= () V1290) (V1289 V1292 (freeze (shen.call-rest V1291 V1292)))) ((cons? V1290) (shen.intprolog-help-help (V1289 (hd V1290)) (tl V1290) V1291 V1292)) (true (shen.sys-error shen.intprolog-help-help))))

(defun shen.call-rest (V1295 V1296) (cond ((= () V1295) true) ((and (cons? V1295) (and (cons? (hd V1295)) (cons? (tl (hd V1295))))) (shen.call-rest (cons (cons ((hd (hd V1295)) (hd (tl (hd V1295)))) (tl (tl (hd V1295)))) (tl V1295)) V1296)) ((and (cons? V1295) (and (cons? (hd V1295)) (= () (tl (hd V1295))))) ((hd (hd V1295)) V1296 (freeze (shen.call-rest (tl V1295) V1296)))) (true (shen.sys-error shen.call-rest))))

(defun shen.start-new-prolog-process () (let IncrementProcessCounter (set shen.*process-counter* (+ 1 (value shen.*process-counter*))) (shen.initialise-prolog IncrementProcessCounter)))

(defun shen.insert-prolog-variables (V1297 V1298) (shen.insert-prolog-variables-help V1297 (shen.flatten V1297) V1298))

(defun shen.insert-prolog-variables-help (V1303 V1304 V1305) (cond ((= () V1304) V1303) ((and (cons? V1304) (variable? (hd V1304))) (let V (shen.newpv V1305) (let XV/Y (subst V (hd V1304) V1303) (let Z-Y (remove (hd V1304) (tl V1304)) (shen.insert-prolog-variables-help XV/Y Z-Y V1305))))) ((cons? V1304) (shen.insert-prolog-variables-help V1303 (tl V1304) V1305)) (true (shen.sys-error shen.insert-prolog-variables-help))))

(defun shen.initialise-prolog (V1306) (let Vector (address-> (value shen.*prologvectors*) V1306 (shen.fillvector (vector 10) 1 10 shen.-null-)) (let Counter (address-> (value shen.*varcounter*) V1306 1) V1306)))



