"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.<defprolog> (V906) (let Result (let Parse_shen.<predicate*> (shen.<predicate*> V906) (if (not (= (fail) Parse_shen.<predicate*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (hd (shen.prolog->shen (map (lambda Parse_X (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>) Parse_X)) (shen.hdtl Parse_shen.<clauses*>))))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.prolog-error (V913 V914) (cond ((and (cons? V914) (and (cons? (tl V914)) (= () (tl (tl V914))))) (simple-error (cn "prolog syntax error in " (shen.app V913 (cn " here:

 " (shen.app (shen.next-50 50 (hd V914)) "
" shen.a)) shen.a)))) (true (simple-error (cn "prolog syntax error in " (shen.app V913 "
" shen.a))))))

(defun shen.next-50 (V919 V920) (cond ((= () V920) "") ((= 0 V919) "") ((cons? V920) (cn (shen.decons-string (hd V920)) (shen.next-50 (- V919 1) (tl V920)))) (true (shen.sys-error shen.next-50))))

(defun shen.decons-string (V921) (cond ((and (cons? V921) (and (= cons (hd V921)) (and (cons? (tl V921)) (and (cons? (tl (tl V921))) (= () (tl (tl (tl V921)))))))) (shen.app (shen.eval-cons V921) " " shen.s)) (true (shen.app V921 " " shen.r))))

(defun shen.insert-predicate (V922 V923) (cond ((and (cons? V923) (and (cons? (tl V923)) (= () (tl (tl V923))))) (cons (cons V922 (hd V923)) (cons :- (tl V923)))) (true (shen.sys-error shen.insert-predicate))))

(defun shen.<predicate*> (V928) (let Result (if (cons? (hd V928)) (let Parse_X (hd (hd V928)) (shen.pair (hd (shen.pair (tl (hd V928)) (shen.hdtl V928))) Parse_X)) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<clauses*> (V933) (let Result (let Parse_shen.<clause*> (shen.<clause*> V933) (if (not (= (fail) Parse_shen.<clause*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (cons (shen.hdtl Parse_shen.<clause*>) (shen.hdtl Parse_shen.<clauses*>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V933) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (append (shen.hdtl Parse_<e>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<clause*> (V938) (let Result (let Parse_shen.<head*> (shen.<head*> V938) (if (not (= (fail) Parse_shen.<head*>)) (if (and (cons? (hd Parse_shen.<head*>)) (= <-- (hd (hd Parse_shen.<head*>)))) (let Parse_shen.<body*> (shen.<body*> (shen.pair (tl (hd Parse_shen.<head*>)) (shen.hdtl Parse_shen.<head*>))) (if (not (= (fail) Parse_shen.<body*>)) (let Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>) (if (not (= (fail) Parse_shen.<end*>)) (shen.pair (hd Parse_shen.<end*>) (cons (shen.hdtl Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<body*>) ()))) (fail))) (fail))) (fail)) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<head*> (V943) (let Result (let Parse_shen.<term*> (shen.<term*> V943) (if (not (= (fail) Parse_shen.<term*>)) (let Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>) (if (not (= (fail) Parse_shen.<head*>)) (shen.pair (hd Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V943) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (append (shen.hdtl Parse_<e>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<term*> (V948) (let Result (if (cons? (hd V948)) (let Parse_X (hd (hd V948)) (if (and (not (= <-- Parse_X)) (shen.legitimate-term? Parse_X)) (shen.pair (hd (shen.pair (tl (hd V948)) (shen.hdtl V948))) (shen.eval-cons Parse_X)) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.legitimate-term? (V953) (cond ((and (cons? V953) (and (= cons (hd V953)) (and (cons? (tl V953)) (and (cons? (tl (tl V953))) (= () (tl (tl (tl V953)))))))) (and (shen.legitimate-term? (hd (tl V953))) (shen.legitimate-term? (hd (tl (tl V953)))))) ((and (cons? V953) (and (= mode (hd V953)) (and (cons? (tl V953)) (and (cons? (tl (tl V953))) (and (= + (hd (tl (tl V953)))) (= () (tl (tl (tl V953))))))))) (shen.legitimate-term? (hd (tl V953)))) ((and (cons? V953) (and (= mode (hd V953)) (and (cons? (tl V953)) (and (cons? (tl (tl V953))) (and (= - (hd (tl (tl V953)))) (= () (tl (tl (tl V953))))))))) (shen.legitimate-term? (hd (tl V953)))) ((cons? V953) false) (true true)))

(defun shen.eval-cons (V954) (cond ((and (cons? V954) (and (= cons (hd V954)) (and (cons? (tl V954)) (and (cons? (tl (tl V954))) (= () (tl (tl (tl V954)))))))) (cons (shen.eval-cons (hd (tl V954))) (shen.eval-cons (hd (tl (tl V954)))))) ((and (cons? V954) (and (= mode (hd V954)) (and (cons? (tl V954)) (and (cons? (tl (tl V954))) (= () (tl (tl (tl V954)))))))) (cons mode (cons (shen.eval-cons (hd (tl V954))) (tl (tl V954))))) (true V954)))

(defun shen.<body*> (V959) (let Result (let Parse_shen.<literal*> (shen.<literal*> V959) (if (not (= (fail) Parse_shen.<literal*>)) (let Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>) (if (not (= (fail) Parse_shen.<body*>)) (shen.pair (hd Parse_shen.<body*>) (cons (shen.hdtl Parse_shen.<literal*>) (shen.hdtl Parse_shen.<body*>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V959) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (append (shen.hdtl Parse_<e>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<literal*> (V964) (let Result (if (and (cons? (hd V964)) (= ! (hd (hd V964)))) (shen.pair (hd (shen.pair (tl (hd V964)) (shen.hdtl V964))) (cons cut (cons (intern "Throwcontrol") ()))) (fail)) (if (= Result (fail)) (let Result (if (cons? (hd V964)) (let Parse_X (hd (hd V964)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V964)) (shen.hdtl V964))) Parse_X) (fail))) (fail)) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<end*> (V969) (let Result (if (cons? (hd V969)) (let Parse_X (hd (hd V969)) (if (= Parse_X ;) (shen.pair (hd (shen.pair (tl (hd V969)) (shen.hdtl V969))) Parse_X) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun cut (V970 V971 V972) (let Result (thaw V972) (if (= Result false) V970 Result)))

(defun shen.insert_modes (V973) (cond ((and (cons? V973) (and (= mode (hd V973)) (and (cons? (tl V973)) (and (cons? (tl (tl V973))) (= () (tl (tl (tl V973)))))))) V973) ((= () V973) ()) ((cons? V973) (cons (cons mode (cons (hd V973) (cons + ()))) (cons mode (cons (shen.insert_modes (tl V973)) (cons - ()))))) (true V973)))

(defun shen.s-prolog (V974) (map (lambda V900 (eval V900)) (shen.prolog->shen V974)))

(defun shen.prolog->shen (V975) (map shen.compile_prolog_procedure (shen.group_clauses (map shen.s-prolog_clause (mapcan shen.head_abstraction V975)))))

(defun shen.s-prolog_clause (V976) (cond ((and (cons? V976) (and (cons? (tl V976)) (and (= :- (hd (tl V976))) (and (cons? (tl (tl V976))) (= () (tl (tl (tl V976)))))))) (cons (hd V976) (cons :- (cons (map shen.s-prolog_literal (hd (tl (tl V976)))) ())))) (true (shen.sys-error shen.s-prolog_clause))))

(defun shen.head_abstraction (V977) (cond ((and (cons? V977) (and (cons? (tl V977)) (and (= :- (hd (tl V977))) (and (cons? (tl (tl V977))) (and (= () (tl (tl (tl V977)))) (< (shen.complexity_head (hd V977)) (value shen.*maxcomplexity*))))))) (cons V977 ())) ((and (cons? V977) (and (cons? (hd V977)) (and (cons? (tl V977)) (and (= :- (hd (tl V977))) (and (cons? (tl (tl V977))) (= () (tl (tl (tl V977))))))))) (let Terms (map (lambda Y (gensym V)) (tl (hd V977))) (let XTerms (shen.rcons_form (shen.remove_modes (tl (hd V977)))) (let Literal (cons unify (cons (shen.cons_form Terms) (cons XTerms ()))) (let Clause (cons (cons (hd (hd V977)) Terms) (cons :- (cons (cons Literal (hd (tl (tl V977)))) ()))) (cons Clause ())))))) (true (shen.sys-error shen.head_abstraction))))

(defun shen.complexity_head (V982) (cond ((cons? V982) (shen.product (map shen.complexity (tl V982)))) (true (shen.sys-error shen.complexity_head))))

(defun shen.complexity (V990) (cond ((and (cons? V990) (and (= mode (hd V990)) (and (cons? (tl V990)) (and (cons? (hd (tl V990))) (and (= mode (hd (hd (tl V990)))) (and (cons? (tl (hd (tl V990)))) (and (cons? (tl (tl (hd (tl V990))))) (and (= () (tl (tl (tl (hd (tl V990)))))) (and (cons? (tl (tl V990))) (= () (tl (tl (tl V990))))))))))))) (shen.complexity (hd (tl V990)))) ((and (cons? V990) (and (= mode (hd V990)) (and (cons? (tl V990)) (and (cons? (hd (tl V990))) (and (cons? (tl (tl V990))) (and (= + (hd (tl (tl V990)))) (= () (tl (tl (tl V990)))))))))) (* 2 (* (shen.complexity (cons mode (cons (hd (hd (tl V990))) (tl (tl V990))))) (shen.complexity (cons mode (cons (tl (hd (tl V990))) (tl (tl V990)))))))) ((and (cons? V990) (and (= mode (hd V990)) (and (cons? (tl V990)) (and (cons? (hd (tl V990))) (and (cons? (tl (tl V990))) (and (= - (hd (tl (tl V990)))) (= () (tl (tl (tl V990)))))))))) (* (shen.complexity (cons mode (cons (hd (hd (tl V990))) (tl (tl V990))))) (shen.complexity (cons mode (cons (tl (hd (tl V990))) (tl (tl V990))))))) ((and (cons? V990) (and (= mode (hd V990)) (and (cons? (tl V990)) (and (cons? (tl (tl V990))) (and (= () (tl (tl (tl V990)))) (variable? (hd (tl V990)))))))) 1) ((and (cons? V990) (and (= mode (hd V990)) (and (cons? (tl V990)) (and (cons? (tl (tl V990))) (and (= + (hd (tl (tl V990)))) (= () (tl (tl (tl V990))))))))) 2) ((and (cons? V990) (and (= mode (hd V990)) (and (cons? (tl V990)) (and (cons? (tl (tl V990))) (and (= - (hd (tl (tl V990)))) (= () (tl (tl (tl V990))))))))) 1) (true (shen.complexity (cons mode (cons V990 (cons + ())))))))

(defun shen.product (V991) (cond ((= () V991) 1) ((cons? V991) (* (hd V991) (shen.product (tl V991)))) (true (shen.sys-error shen.product))))

(defun shen.s-prolog_literal (V992) (cond ((and (cons? V992) (and (= is (hd V992)) (and (cons? (tl V992)) (and (cons? (tl (tl V992))) (= () (tl (tl (tl V992)))))))) (cons bind (cons (hd (tl V992)) (cons (shen.insert_deref (hd (tl (tl V992)))) ())))) ((and (cons? V992) (and (= when (hd V992)) (and (cons? (tl V992)) (= () (tl (tl V992)))))) (cons fwhen (cons (shen.insert_deref (hd (tl V992))) ()))) ((and (cons? V992) (and (= bind (hd V992)) (and (cons? (tl V992)) (and (cons? (tl (tl V992))) (= () (tl (tl (tl V992)))))))) (cons bind (cons (hd (tl V992)) (cons (shen.insert_lazyderef (hd (tl (tl V992)))) ())))) ((and (cons? V992) (and (= fwhen (hd V992)) (and (cons? (tl V992)) (= () (tl (tl V992)))))) (cons fwhen (cons (shen.insert_lazyderef (hd (tl V992))) ()))) ((cons? V992) (cons (shen.m_prolog_to_s-prolog_predicate (hd V992)) (tl V992))) (true (shen.sys-error shen.s-prolog_literal))))

(defun shen.insert_deref (V993) (cond ((variable? V993) (cons shen.deref (cons V993 (cons ProcessN ())))) ((cons? V993) (cons (shen.insert_deref (hd V993)) (shen.insert_deref (tl V993)))) (true V993)))

(defun shen.insert_lazyderef (V994) (cond ((variable? V994) (cons shen.lazyderef (cons V994 (cons ProcessN ())))) ((cons? V994) (cons (shen.insert_lazyderef (hd V994)) (shen.insert_lazyderef (tl V994)))) (true V994)))

(defun shen.m_prolog_to_s-prolog_predicate (V995) (cond ((= = V995) unify) ((= =! V995) unify!) ((= == V995) identical) (true V995)))

(defun shen.group_clauses (V996) (cond ((= () V996) ()) ((cons? V996) (let Group (shen.collect (lambda X (shen.same_predicate? (hd V996) X)) V996) (let Rest (difference V996 Group) (cons Group (shen.group_clauses Rest))))) (true (shen.sys-error shen.group_clauses))))

(defun shen.collect (V999 V1000) (cond ((= () V1000) ()) ((cons? V1000) (if (V999 (hd V1000)) (cons (hd V1000) (shen.collect V999 (tl V1000))) (shen.collect V999 (tl V1000)))) (true (shen.sys-error shen.collect))))

(defun shen.same_predicate? (V1017 V1018) (cond ((and (cons? V1017) (and (cons? (hd V1017)) (and (cons? V1018) (cons? (hd V1018))))) (= (hd (hd V1017)) (hd (hd V1018)))) (true (shen.sys-error shen.same_predicate?))))

(defun shen.compile_prolog_procedure (V1019) (let F (shen.procedure_name V1019) (let Shen (shen.clauses-to-shen F V1019) Shen)))

(defun shen.procedure_name (V1032) (cond ((and (cons? V1032) (and (cons? (hd V1032)) (cons? (hd (hd V1032))))) (hd (hd (hd V1032)))) (true (shen.sys-error shen.procedure_name))))

(defun shen.clauses-to-shen (V1033 V1034) (let Linear (map shen.linearise-clause V1034) (let Arity (shen.prolog-aritycheck V1033 (map (lambda V901 (head V901)) V1034)) (let Parameters (shen.parameters Arity) (let AUM_instructions (map (lambda X (shen.aum X Parameters)) Linear) (let Code (shen.catch-cut (shen.nest-disjunct (map shen.aum_to_shen AUM_instructions))) (let ShenDef (cons define (cons V1033 (append Parameters (append (cons ProcessN (cons Continuation ())) (cons -> (cons Code ())))))) ShenDef)))))))

(defun shen.catch-cut (V1035) (cond ((not (shen.occurs? cut V1035)) V1035) (true (cons let (cons Throwcontrol (cons (cons shen.catchpoint ()) (cons (cons shen.cutpoint (cons Throwcontrol (cons V1035 ()))) ())))))))

(defun shen.catchpoint () (set shen.*catch* (+ 1 (value shen.*catch*))))

(defun shen.cutpoint (V1040 V1041) (cond ((= V1041 V1040) false) (true V1041)))

(defun shen.nest-disjunct (V1043) (cond ((and (cons? V1043) (= () (tl V1043))) (hd V1043)) ((cons? V1043) (shen.lisp-or (hd V1043) (shen.nest-disjunct (tl V1043)))) (true (shen.sys-error shen.nest-disjunct))))

(defun shen.lisp-or (V1044 V1045) (cons let (cons Case (cons V1044 (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons V1045 (cons Case ())))) ())))))

(defun shen.prolog-aritycheck (V1048 V1049) (cond ((and (cons? V1049) (= () (tl V1049))) (- (length (hd V1049)) 1)) ((and (cons? V1049) (cons? (tl V1049))) (if (= (length (hd V1049)) (length (hd (tl V1049)))) (shen.prolog-aritycheck V1048 (tl V1049)) (simple-error (cn "arity error in prolog procedure " (shen.app (cons V1048 ()) "
" shen.a))))) (true (shen.sys-error shen.prolog-aritycheck))))

(defun shen.linearise-clause (V1050) (cond ((and (cons? V1050) (and (cons? (tl V1050)) (and (= :- (hd (tl V1050))) (and (cons? (tl (tl V1050))) (= () (tl (tl (tl V1050)))))))) (let Linear (shen.linearise (cons (hd V1050) (tl (tl V1050)))) (shen.clause_form Linear))) (true (shen.sys-error shen.linearise-clause))))

(defun shen.clause_form (V1051) (cond ((and (cons? V1051) (and (cons? (tl V1051)) (= () (tl (tl V1051))))) (cons (shen.explicit_modes (hd V1051)) (cons :- (cons (shen.cf_help (hd (tl V1051))) ())))) (true (shen.sys-error shen.clause_form))))

(defun shen.explicit_modes (V1052) (cond ((cons? V1052) (cons (hd V1052) (map shen.em_help (tl V1052)))) (true (shen.sys-error shen.explicit_modes))))

(defun shen.em_help (V1053) (cond ((and (cons? V1053) (and (= mode (hd V1053)) (and (cons? (tl V1053)) (and (cons? (tl (tl V1053))) (= () (tl (tl (tl V1053)))))))) V1053) (true (cons mode (cons V1053 (cons + ()))))))

(defun shen.cf_help (V1054) (cond ((and (cons? V1054) (and (= where (hd V1054)) (and (cons? (tl V1054)) (and (cons? (hd (tl V1054))) (and (= = (hd (hd (tl V1054)))) (and (cons? (tl (hd (tl V1054)))) (and (cons? (tl (tl (hd (tl V1054))))) (and (= () (tl (tl (tl (hd (tl V1054)))))) (and (cons? (tl (tl V1054))) (= () (tl (tl (tl V1054))))))))))))) (cons (cons (if (value shen.*occurs*) unify! unify) (tl (hd (tl V1054)))) (shen.cf_help (hd (tl (tl V1054)))))) (true V1054)))

(defun occurs-check (V1059) (cond ((= + V1059) (set shen.*occurs* true)) ((= - V1059) (set shen.*occurs* false)) (true (simple-error "occurs-check expects + or -
"))))

(defun shen.aum (V1060 V1061) (cond ((and (cons? V1060) (and (cons? (hd V1060)) (and (cons? (tl V1060)) (and (= :- (hd (tl V1060))) (and (cons? (tl (tl V1060))) (= () (tl (tl (tl V1060))))))))) (let MuApplication (shen.make_mu_application (cons shen.mu (cons (tl (hd V1060)) (cons (shen.continuation_call (tl (hd V1060)) (hd (tl (tl V1060)))) ()))) V1061) (shen.mu_reduction MuApplication +))) (true (shen.sys-error shen.aum))))

(defun shen.continuation_call (V1062 V1063) (let VTerms (cons ProcessN (shen.extract_vars V1062)) (let VBody (shen.extract_vars V1063) (let Free (remove Throwcontrol (difference VBody VTerms)) (shen.cc_help Free V1063)))))

(defun remove (V1064 V1065) (shen.remove-h V1064 V1065 ()))

(defun shen.remove-h (V1068 V1069 V1070) (cond ((= () V1069) (reverse V1070)) ((and (cons? V1069) (= (hd V1069) V1068)) (shen.remove-h (hd V1069) (tl V1069) V1070)) ((cons? V1069) (shen.remove-h V1068 (tl V1069) (cons (hd V1069) V1070))) (true (shen.sys-error shen.remove-h))))

(defun shen.cc_help (V1072 V1073) (cond ((and (= () V1072) (= () V1073)) (cons shen.pop (cons shen.the (cons shen.stack ())))) ((= () V1073) (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1072 (cons and (cons shen.then (cons (cons shen.pop (cons shen.the (cons shen.stack ()))) ()))))))))) ((= () V1072) (cons call (cons shen.the (cons shen.continuation (cons V1073 ()))))) (true (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1072 (cons and (cons shen.then (cons (cons call (cons shen.the (cons shen.continuation (cons V1073 ())))) ())))))))))))

(defun shen.make_mu_application (V1074 V1075) (cond ((and (cons? V1074) (and (= shen.mu (hd V1074)) (and (cons? (tl V1074)) (and (= () (hd (tl V1074))) (and (cons? (tl (tl V1074))) (and (= () (tl (tl (tl V1074)))) (= () V1075))))))) (hd (tl (tl V1074)))) ((and (cons? V1074) (and (= shen.mu (hd V1074)) (and (cons? (tl V1074)) (and (cons? (hd (tl V1074))) (and (cons? (tl (tl V1074))) (and (= () (tl (tl (tl V1074)))) (cons? V1075))))))) (cons (cons shen.mu (cons (hd (hd (tl V1074))) (cons (shen.make_mu_application (cons shen.mu (cons (tl (hd (tl V1074))) (tl (tl V1074)))) (tl V1075)) ()))) (cons (hd V1075) ()))) (true (shen.sys-error shen.make_mu_application))))

(defun shen.mu_reduction (V1082 V1083) (cond ((and (cons? V1082) (and (cons? (hd V1082)) (and (= shen.mu (hd (hd V1082))) (and (cons? (tl (hd V1082))) (and (cons? (hd (tl (hd V1082)))) (and (= mode (hd (hd (tl (hd V1082))))) (and (cons? (tl (hd (tl (hd V1082))))) (and (cons? (tl (tl (hd (tl (hd V1082)))))) (and (= () (tl (tl (tl (hd (tl (hd V1082))))))) (and (cons? (tl (tl (hd V1082)))) (and (= () (tl (tl (tl (hd V1082))))) (and (cons? (tl V1082)) (= () (tl (tl V1082))))))))))))))) (shen.mu_reduction (cons (cons shen.mu (cons (hd (tl (hd (tl (hd V1082))))) (tl (tl (hd V1082))))) (tl V1082)) (hd (tl (tl (hd (tl (hd V1082)))))))) ((and (cons? V1082) (and (cons? (hd V1082)) (and (= shen.mu (hd (hd V1082))) (and (cons? (tl (hd V1082))) (and (cons? (tl (tl (hd V1082)))) (and (= () (tl (tl (tl (hd V1082))))) (and (cons? (tl V1082)) (and (= () (tl (tl V1082))) (= _ (hd (tl (hd V1082)))))))))))) (shen.mu_reduction (hd (tl (tl (hd V1082)))) V1083)) ((and (cons? V1082) (and (cons? (hd V1082)) (and (= shen.mu (hd (hd V1082))) (and (cons? (tl (hd V1082))) (and (cons? (tl (tl (hd V1082)))) (and (= () (tl (tl (tl (hd V1082))))) (and (cons? (tl V1082)) (and (= () (tl (tl V1082))) (shen.ephemeral_variable? (hd (tl (hd V1082))) (hd (tl V1082))))))))))) (subst (hd (tl V1082)) (hd (tl (hd V1082))) (shen.mu_reduction (hd (tl (tl (hd V1082)))) V1083))) ((and (cons? V1082) (and (cons? (hd V1082)) (and (= shen.mu (hd (hd V1082))) (and (cons? (tl (hd V1082))) (and (cons? (tl (tl (hd V1082)))) (and (= () (tl (tl (tl (hd V1082))))) (and (cons? (tl V1082)) (and (= () (tl (tl V1082))) (variable? (hd (tl (hd V1082)))))))))))) (cons let (cons (hd (tl (hd V1082))) (cons shen.be (cons (hd (tl V1082)) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1082)))) V1083) ()))))))) ((and (cons? V1082) (and (cons? (hd V1082)) (and (= shen.mu (hd (hd V1082))) (and (cons? (tl (hd V1082))) (and (cons? (tl (tl (hd V1082)))) (and (= () (tl (tl (tl (hd V1082))))) (and (cons? (tl V1082)) (and (= () (tl (tl V1082))) (and (= - V1083) (shen.prolog_constant? (hd (tl (hd V1082))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1082))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1082))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1082)))) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1082) (and (cons? (hd V1082)) (and (= shen.mu (hd (hd V1082))) (and (cons? (tl (hd V1082))) (and (cons? (tl (tl (hd V1082)))) (and (= () (tl (tl (tl (hd V1082))))) (and (cons? (tl V1082)) (and (= () (tl (tl V1082))) (and (= + V1083) (shen.prolog_constant? (hd (tl (hd V1082))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1082))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1082))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1082)))) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (hd (tl (hd V1082))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1082)))) +) ())))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) ((and (cons? V1082) (and (cons? (hd V1082)) (and (= shen.mu (hd (hd V1082))) (and (cons? (tl (hd V1082))) (and (cons? (hd (tl (hd V1082)))) (and (cons? (tl (tl (hd V1082)))) (and (= () (tl (tl (tl (hd V1082))))) (and (cons? (tl V1082)) (and (= () (tl (tl V1082))) (= - V1083)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1082))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1082)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1082)))) (tl (tl (hd V1082))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1082) (and (cons? (hd V1082)) (and (= shen.mu (hd (hd V1082))) (and (cons? (tl (hd V1082))) (and (cons? (hd (tl (hd V1082)))) (and (cons? (tl (tl (hd V1082)))) (and (= () (tl (tl (tl (hd V1082))))) (and (cons? (tl V1082)) (and (= () (tl (tl V1082))) (= + V1083)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1082))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1082)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1082)))) (tl (tl (hd V1082))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (shen.extract_vars (hd (tl (hd V1082)))) (cons and (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (shen.rcons_form (shen.remove_modes (hd (tl (hd V1082))))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1082)))) +) ())))))) ())))))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) (true V1082)))

(defun shen.rcons_form (V1084) (cond ((cons? V1084) (cons cons (cons (shen.rcons_form (hd V1084)) (cons (shen.rcons_form (tl V1084)) ())))) (true V1084)))

(defun shen.remove_modes (V1085) (cond ((and (cons? V1085) (and (= mode (hd V1085)) (and (cons? (tl V1085)) (and (cons? (tl (tl V1085))) (and (= + (hd (tl (tl V1085)))) (= () (tl (tl (tl V1085))))))))) (shen.remove_modes (hd (tl V1085)))) ((and (cons? V1085) (and (= mode (hd V1085)) (and (cons? (tl V1085)) (and (cons? (tl (tl V1085))) (and (= - (hd (tl (tl V1085)))) (= () (tl (tl (tl V1085))))))))) (shen.remove_modes (hd (tl V1085)))) ((cons? V1085) (cons (shen.remove_modes (hd V1085)) (shen.remove_modes (tl V1085)))) (true V1085)))

(defun shen.ephemeral_variable? (V1086 V1087) (and (variable? V1086) (variable? V1087)))

(defun shen.prolog_constant? (V1096) (cond ((cons? V1096) false) (true true)))

(defun shen.aum_to_shen (V1097) (cond ((and (cons? V1097) (and (= let (hd V1097)) (and (cons? (tl V1097)) (and (cons? (tl (tl V1097))) (and (= shen.be (hd (tl (tl V1097)))) (and (cons? (tl (tl (tl V1097)))) (and (cons? (tl (tl (tl (tl V1097))))) (and (= in (hd (tl (tl (tl (tl V1097)))))) (and (cons? (tl (tl (tl (tl (tl V1097)))))) (= () (tl (tl (tl (tl (tl (tl V1097)))))))))))))))) (cons let (cons (hd (tl V1097)) (cons (shen.aum_to_shen (hd (tl (tl (tl V1097))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1097))))))) ()))))) ((and (cons? V1097) (and (= shen.the (hd V1097)) (and (cons? (tl V1097)) (and (= shen.result (hd (tl V1097))) (and (cons? (tl (tl V1097))) (and (= shen.of (hd (tl (tl V1097)))) (and (cons? (tl (tl (tl V1097)))) (and (= shen.dereferencing (hd (tl (tl (tl V1097))))) (and (cons? (tl (tl (tl (tl V1097))))) (= () (tl (tl (tl (tl (tl V1097))))))))))))))) (cons shen.lazyderef (cons (shen.aum_to_shen (hd (tl (tl (tl (tl V1097)))))) (cons ProcessN ())))) ((and (cons? V1097) (and (= if (hd V1097)) (and (cons? (tl V1097)) (and (cons? (tl (tl V1097))) (and (= shen.then (hd (tl (tl V1097)))) (and (cons? (tl (tl (tl V1097)))) (and (cons? (tl (tl (tl (tl V1097))))) (and (= shen.else (hd (tl (tl (tl (tl V1097)))))) (and (cons? (tl (tl (tl (tl (tl V1097)))))) (= () (tl (tl (tl (tl (tl (tl V1097)))))))))))))))) (cons if (cons (shen.aum_to_shen (hd (tl V1097))) (cons (shen.aum_to_shen (hd (tl (tl (tl V1097))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1097))))))) ()))))) ((and (cons? V1097) (and (cons? (tl V1097)) (and (= is (hd (tl V1097))) (and (cons? (tl (tl V1097))) (and (= shen.a (hd (tl (tl V1097)))) (and (cons? (tl (tl (tl V1097)))) (and (= shen.variable (hd (tl (tl (tl V1097))))) (= () (tl (tl (tl (tl V1097)))))))))))) (cons shen.pvar? (cons (hd V1097) ()))) ((and (cons? V1097) (and (cons? (tl V1097)) (and (= is (hd (tl V1097))) (and (cons? (tl (tl V1097))) (and (= shen.a (hd (tl (tl V1097)))) (and (cons? (tl (tl (tl V1097)))) (and (= shen.non-empty (hd (tl (tl (tl V1097))))) (and (cons? (tl (tl (tl (tl V1097))))) (and (= list (hd (tl (tl (tl (tl V1097)))))) (= () (tl (tl (tl (tl (tl V1097))))))))))))))) (cons cons? (cons (hd V1097) ()))) ((and (cons? V1097) (and (= shen.rename (hd V1097)) (and (cons? (tl V1097)) (and (= shen.the (hd (tl V1097))) (and (cons? (tl (tl V1097))) (and (= shen.variables (hd (tl (tl V1097)))) (and (cons? (tl (tl (tl V1097)))) (and (= in (hd (tl (tl (tl V1097))))) (and (cons? (tl (tl (tl (tl V1097))))) (and (= () (hd (tl (tl (tl (tl V1097)))))) (and (cons? (tl (tl (tl (tl (tl V1097)))))) (and (= and (hd (tl (tl (tl (tl (tl V1097))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1097))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1097)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1097)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1097)))))))))))))))))))))))) (shen.aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V1097)))))))))) ((and (cons? V1097) (and (= shen.rename (hd V1097)) (and (cons? (tl V1097)) (and (= shen.the (hd (tl V1097))) (and (cons? (tl (tl V1097))) (and (= shen.variables (hd (tl (tl V1097)))) (and (cons? (tl (tl (tl V1097)))) (and (= in (hd (tl (tl (tl V1097))))) (and (cons? (tl (tl (tl (tl V1097))))) (and (cons? (hd (tl (tl (tl (tl V1097)))))) (and (cons? (tl (tl (tl (tl (tl V1097)))))) (and (= and (hd (tl (tl (tl (tl (tl V1097))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1097))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1097)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1097)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1097)))))))))))))))))))))))) (cons let (cons (hd (hd (tl (tl (tl (tl V1097)))))) (cons (cons shen.newpv (cons ProcessN ())) (cons (shen.aum_to_shen (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (tl (hd (tl (tl (tl (tl V1097)))))) (tl (tl (tl (tl (tl V1097))))))))))) ()))))) ((and (cons? V1097) (and (= bind (hd V1097)) (and (cons? (tl V1097)) (and (cons? (tl (tl V1097))) (and (= shen.to (hd (tl (tl V1097)))) (and (cons? (tl (tl (tl V1097)))) (and (cons? (tl (tl (tl (tl V1097))))) (and (= in (hd (tl (tl (tl (tl V1097)))))) (and (cons? (tl (tl (tl (tl (tl V1097)))))) (= () (tl (tl (tl (tl (tl (tl V1097)))))))))))))))) (cons do (cons (cons shen.bindv (cons (hd (tl V1097)) (cons (shen.chwild (hd (tl (tl (tl V1097))))) (cons ProcessN ())))) (cons (cons let (cons Result (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1097))))))) (cons (cons do (cons (cons shen.unbindv (cons (hd (tl V1097)) (cons ProcessN ()))) (cons Result ()))) ())))) ())))) ((and (cons? V1097) (and (cons? (tl V1097)) (and (= is (hd (tl V1097))) (and (cons? (tl (tl V1097))) (and (= identical (hd (tl (tl V1097)))) (and (cons? (tl (tl (tl V1097)))) (and (= shen.to (hd (tl (tl (tl V1097))))) (and (cons? (tl (tl (tl (tl V1097))))) (= () (tl (tl (tl (tl (tl V1097)))))))))))))) (cons = (cons (hd (tl (tl (tl (tl V1097))))) (cons (hd V1097) ())))) ((= shen.failed! V1097) false) ((and (cons? V1097) (and (= shen.the (hd V1097)) (and (cons? (tl V1097)) (and (= head (hd (tl V1097))) (and (cons? (tl (tl V1097))) (and (= shen.of (hd (tl (tl V1097)))) (and (cons? (tl (tl (tl V1097)))) (= () (tl (tl (tl (tl V1097)))))))))))) (cons hd (tl (tl (tl V1097))))) ((and (cons? V1097) (and (= shen.the (hd V1097)) (and (cons? (tl V1097)) (and (= tail (hd (tl V1097))) (and (cons? (tl (tl V1097))) (and (= shen.of (hd (tl (tl V1097)))) (and (cons? (tl (tl (tl V1097)))) (= () (tl (tl (tl (tl V1097)))))))))))) (cons tl (tl (tl (tl V1097))))) ((and (cons? V1097) (and (= shen.pop (hd V1097)) (and (cons? (tl V1097)) (and (= shen.the (hd (tl V1097))) (and (cons? (tl (tl V1097))) (and (= shen.stack (hd (tl (tl V1097)))) (= () (tl (tl (tl V1097)))))))))) (cons do (cons (cons shen.incinfs ()) (cons (cons thaw (cons Continuation ())) ())))) ((and (cons? V1097) (and (= call (hd V1097)) (and (cons? (tl V1097)) (and (= shen.the (hd (tl V1097))) (and (cons? (tl (tl V1097))) (and (= shen.continuation (hd (tl (tl V1097)))) (and (cons? (tl (tl (tl V1097)))) (= () (tl (tl (tl (tl V1097)))))))))))) (cons do (cons (cons shen.incinfs ()) (cons (shen.call_the_continuation (shen.chwild (hd (tl (tl (tl V1097))))) ProcessN Continuation) ())))) (true V1097)))

(defun shen.chwild (V1098) (cond ((= V1098 _) (cons shen.newpv (cons ProcessN ()))) ((cons? V1098) (map shen.chwild V1098)) (true V1098)))

(defun shen.newpv (V1099) (let Count+1 (+ (<-address (value shen.*varcounter*) V1099) 1) (let IncVar (address-> (value shen.*varcounter*) V1099 Count+1) (let Vector (<-address (value shen.*prologvectors*) V1099) (let ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen.resizeprocessvector V1099 Count+1) shen.skip) (shen.mk-pvar Count+1))))))

(defun shen.resizeprocessvector (V1100 V1101) (let Vector (<-address (value shen.*prologvectors*) V1100) (let BigVector (shen.resize-vector Vector (+ V1101 V1101) shen.-null-) (address-> (value shen.*prologvectors*) V1100 BigVector))))

(defun shen.resize-vector (V1102 V1103 V1104) (let BigVector (address-> (absvector (+ 1 V1103)) 0 V1103) (shen.copy-vector V1102 BigVector (limit V1102) V1103 V1104)))

(defun shen.copy-vector (V1105 V1106 V1107 V1108 V1109) (shen.copy-vector-stage-2 (+ 1 V1107) (+ V1108 1) V1109 (shen.copy-vector-stage-1 1 V1105 V1106 (+ 1 V1107))))

(defun shen.copy-vector-stage-1 (V1112 V1113 V1114 V1115) (cond ((= V1115 V1112) V1114) (true (shen.copy-vector-stage-1 (+ 1 V1112) V1113 (address-> V1114 V1112 (<-address V1113 V1112)) V1115))))

(defun shen.copy-vector-stage-2 (V1119 V1120 V1121 V1122) (cond ((= V1120 V1119) V1122) (true (shen.copy-vector-stage-2 (+ V1119 1) V1120 V1121 (address-> V1122 V1119 V1121)))))

(defun shen.mk-pvar (V1124) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V1124))

(defun shen.pvar? (V1125) (and (absvector? V1125) (= (<-address V1125 0) shen.pvar)))

(defun shen.bindv (V1126 V1127 V1128) (let Vector (<-address (value shen.*prologvectors*) V1128) (address-> Vector (<-address V1126 1) V1127)))

(defun shen.unbindv (V1129 V1130) (let Vector (<-address (value shen.*prologvectors*) V1130) (address-> Vector (<-address V1129 1) shen.-null-)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.call_the_continuation (V1131 V1132 V1133) (cond ((and (cons? V1131) (and (cons? (hd V1131)) (= () (tl V1131)))) (cons (hd (hd V1131)) (append (tl (hd V1131)) (cons V1132 (cons V1133 ()))))) ((and (cons? V1131) (cons? (hd V1131))) (let NewContinuation (shen.newcontinuation (tl V1131) V1132 V1133) (cons (hd (hd V1131)) (append (tl (hd V1131)) (cons V1132 (cons NewContinuation ())))))) (true (shen.sys-error shen.call_the_continuation))))

(defun shen.newcontinuation (V1134 V1135 V1136) (cond ((= () V1134) V1136) ((and (cons? V1134) (cons? (hd V1134))) (cons freeze (cons (cons (hd (hd V1134)) (append (tl (hd V1134)) (cons V1135 (cons (shen.newcontinuation (tl V1134) V1135 V1136) ())))) ()))) (true (shen.sys-error shen.newcontinuation))))

(defun return (V1141 V1142 V1143) (shen.deref V1141 V1142))

(defun shen.measure&return (V1148 V1149 V1150) (do (shen.prhush (shen.app (value shen.*infs*) " inferences
" shen.a) (stoutput)) (shen.deref V1148 V1149)))

(defun unify (V1151 V1152 V1153 V1154) (shen.lzy= (shen.lazyderef V1151 V1153) (shen.lazyderef V1152 V1153) V1153 V1154))

(defun shen.lzy= (V1171 V1172 V1173 V1174) (cond ((= V1172 V1171) (thaw V1174)) ((shen.pvar? V1171) (bind V1171 V1172 V1173 V1174)) ((shen.pvar? V1172) (bind V1172 V1171 V1173 V1174)) ((and (cons? V1171) (cons? V1172)) (shen.lzy= (shen.lazyderef (hd V1171) V1173) (shen.lazyderef (hd V1172) V1173) V1173 (freeze (shen.lzy= (shen.lazyderef (tl V1171) V1173) (shen.lazyderef (tl V1172) V1173) V1173 V1174)))) (true false)))

(defun shen.deref (V1176 V1177) (cond ((cons? V1176) (cons (shen.deref (hd V1176) V1177) (shen.deref (tl V1176) V1177))) (true (if (shen.pvar? V1176) (let Value (shen.valvector V1176 V1177) (if (= Value shen.-null-) V1176 (shen.deref Value V1177))) V1176))))

(defun shen.lazyderef (V1178 V1179) (if (shen.pvar? V1178) (let Value (shen.valvector V1178 V1179) (if (= Value shen.-null-) V1178 (shen.lazyderef Value V1179))) V1178))

(defun shen.valvector (V1180 V1181) (<-address (<-address (value shen.*prologvectors*) V1181) (<-address V1180 1)))

(defun unify! (V1182 V1183 V1184 V1185) (shen.lzy=! (shen.lazyderef V1182 V1184) (shen.lazyderef V1183 V1184) V1184 V1185))

(defun shen.lzy=! (V1202 V1203 V1204 V1205) (cond ((= V1203 V1202) (thaw V1205)) ((and (shen.pvar? V1202) (not (shen.occurs? V1202 (shen.deref V1203 V1204)))) (bind V1202 V1203 V1204 V1205)) ((and (shen.pvar? V1203) (not (shen.occurs? V1203 (shen.deref V1202 V1204)))) (bind V1203 V1202 V1204 V1205)) ((and (cons? V1202) (cons? V1203)) (shen.lzy=! (shen.lazyderef (hd V1202) V1204) (shen.lazyderef (hd V1203) V1204) V1204 (freeze (shen.lzy=! (shen.lazyderef (tl V1202) V1204) (shen.lazyderef (tl V1203) V1204) V1204 V1205)))) (true false)))

(defun shen.occurs? (V1215 V1216) (cond ((= V1216 V1215) true) ((cons? V1216) (or (shen.occurs? V1215 (hd V1216)) (shen.occurs? V1215 (tl V1216)))) (true false)))

(defun identical (V1218 V1219 V1220 V1221) (shen.lzy== (shen.lazyderef V1218 V1220) (shen.lazyderef V1219 V1220) V1220 V1221))

(defun shen.lzy== (V1238 V1239 V1240 V1241) (cond ((= V1239 V1238) (thaw V1241)) ((and (cons? V1238) (cons? V1239)) (shen.lzy== (shen.lazyderef (hd V1238) V1240) (shen.lazyderef (hd V1239) V1240) V1240 (freeze (shen.lzy== (tl V1238) (tl V1239) V1240 V1241)))) (true false)))

(defun shen.pvar (V1243) (cn "Var" (shen.app (<-address V1243 1) "" shen.a)))

(defun bind (V1244 V1245 V1246 V1247) (do (shen.bindv V1244 V1245 V1246) (let Result (thaw V1247) (do (shen.unbindv V1244 V1246) Result))))

(defun fwhen (V1262 V1263 V1264) (cond ((= true V1262) (thaw V1264)) ((= false V1262) false) (true (simple-error (cn "fwhen expects a boolean: not " (shen.app V1262 "%" shen.s))))))

(defun call (V1277 V1278 V1279) (cond ((cons? V1277) (shen.call-help (shen.m_prolog_to_s-prolog_predicate (shen.lazyderef (hd V1277) V1278)) (tl V1277) V1278 V1279)) (true false)))

(defun shen.call-help (V1280 V1281 V1282 V1283) (cond ((= () V1281) (V1280 V1282 V1283)) ((cons? V1281) (shen.call-help (V1280 (hd V1281)) (tl V1281) V1282 V1283)) (true (shen.sys-error shen.call-help))))

(defun shen.intprolog (V1284) (cond ((and (cons? V1284) (cons? (hd V1284))) (let ProcessN (shen.start-new-prolog-process) (shen.intprolog-help (hd (hd V1284)) (shen.insert-prolog-variables (cons (tl (hd V1284)) (cons (tl V1284) ())) ProcessN) ProcessN))) (true (shen.sys-error shen.intprolog))))

(defun shen.intprolog-help (V1285 V1286 V1287) (cond ((and (cons? V1286) (and (cons? (tl V1286)) (= () (tl (tl V1286))))) (shen.intprolog-help-help V1285 (hd V1286) (hd (tl V1286)) V1287)) (true (shen.sys-error shen.intprolog-help))))

(defun shen.intprolog-help-help (V1288 V1289 V1290 V1291) (cond ((= () V1289) (V1288 V1291 (freeze (shen.call-rest V1290 V1291)))) ((cons? V1289) (shen.intprolog-help-help (V1288 (hd V1289)) (tl V1289) V1290 V1291)) (true (shen.sys-error shen.intprolog-help-help))))

(defun shen.call-rest (V1294 V1295) (cond ((= () V1294) true) ((and (cons? V1294) (and (cons? (hd V1294)) (cons? (tl (hd V1294))))) (shen.call-rest (cons (cons ((hd (hd V1294)) (hd (tl (hd V1294)))) (tl (tl (hd V1294)))) (tl V1294)) V1295)) ((and (cons? V1294) (and (cons? (hd V1294)) (= () (tl (hd V1294))))) ((hd (hd V1294)) V1295 (freeze (shen.call-rest (tl V1294) V1295)))) (true (shen.sys-error shen.call-rest))))

(defun shen.start-new-prolog-process () (let IncrementProcessCounter (set shen.*process-counter* (+ 1 (value shen.*process-counter*))) (shen.initialise-prolog IncrementProcessCounter)))

(defun shen.insert-prolog-variables (V1296 V1297) (shen.insert-prolog-variables-help V1296 (shen.flatten V1296) V1297))

(defun shen.insert-prolog-variables-help (V1302 V1303 V1304) (cond ((= () V1303) V1302) ((and (cons? V1303) (variable? (hd V1303))) (let V (shen.newpv V1304) (let XV/Y (subst V (hd V1303) V1302) (let Z-Y (remove (hd V1303) (tl V1303)) (shen.insert-prolog-variables-help XV/Y Z-Y V1304))))) ((cons? V1303) (shen.insert-prolog-variables-help V1302 (tl V1303) V1304)) (true (shen.sys-error shen.insert-prolog-variables-help))))

(defun shen.initialise-prolog (V1305) (let Vector (address-> (value shen.*prologvectors*) V1305 (shen.fillvector (vector 10) 1 10 shen.-null-)) (let Counter (address-> (value shen.*varcounter*) V1305 1) V1305)))



