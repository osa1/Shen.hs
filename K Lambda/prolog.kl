"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.<defprolog> (V927) (let Result (let Parse_shen.<predicate*> (shen.<predicate*> V927) (if (not (= (fail) Parse_shen.<predicate*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (hd (shen.prolog->shen (map (lambda Parse_X (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>) Parse_X)) (shen.hdtl Parse_shen.<clauses*>))))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.prolog-error (V934 V935) (cond ((and (cons? V935) (and (cons? (tl V935)) (= () (tl (tl V935))))) (simple-error (cn "prolog syntax error in " (shen.app V934 (cn " here:

 " (shen.app (shen.next-50 50 (hd V935)) "
" shen.a)) shen.a)))) (true (simple-error (cn "prolog syntax error in " (shen.app V934 "
" shen.a))))))

(defun shen.next-50 (V940 V941) (cond ((= () V941) "") ((= 0 V940) "") ((cons? V941) (cn (shen.decons-string (hd V941)) (shen.next-50 (- V940 1) (tl V941)))) (true (shen.sys-error shen.next-50))))

(defun shen.decons-string (V942) (cond ((and (cons? V942) (and (= cons (hd V942)) (and (cons? (tl V942)) (and (cons? (tl (tl V942))) (= () (tl (tl (tl V942)))))))) (shen.app (shen.eval-cons V942) " " shen.s)) (true (shen.app V942 " " shen.r))))

(defun shen.insert-predicate (V943 V944) (cond ((and (cons? V944) (and (cons? (tl V944)) (= () (tl (tl V944))))) (cons (cons V943 (hd V944)) (cons :- (tl V944)))) (true (shen.sys-error shen.insert-predicate))))

(defun shen.<predicate*> (V949) (let Result (if (cons? (hd V949)) (let Parse_X (hd (hd V949)) (shen.pair (hd (shen.pair (tl (hd V949)) (shen.hdtl V949))) Parse_X)) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<clauses*> (V954) (let Result (let Parse_shen.<clause*> (shen.<clause*> V954) (if (not (= (fail) Parse_shen.<clause*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (cons (shen.hdtl Parse_shen.<clause*>) (shen.hdtl Parse_shen.<clauses*>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V954) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (append (shen.hdtl Parse_<e>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<clause*> (V959) (let Result (let Parse_shen.<head*> (shen.<head*> V959) (if (not (= (fail) Parse_shen.<head*>)) (if (and (cons? (hd Parse_shen.<head*>)) (= <-- (hd (hd Parse_shen.<head*>)))) (let Parse_shen.<body*> (shen.<body*> (shen.pair (tl (hd Parse_shen.<head*>)) (shen.hdtl Parse_shen.<head*>))) (if (not (= (fail) Parse_shen.<body*>)) (let Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>) (if (not (= (fail) Parse_shen.<end*>)) (shen.pair (hd Parse_shen.<end*>) (cons (shen.hdtl Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<body*>) ()))) (fail))) (fail))) (fail)) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<head*> (V964) (let Result (let Parse_shen.<term*> (shen.<term*> V964) (if (not (= (fail) Parse_shen.<term*>)) (let Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>) (if (not (= (fail) Parse_shen.<head*>)) (shen.pair (hd Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V964) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (append (shen.hdtl Parse_<e>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<term*> (V969) (let Result (if (cons? (hd V969)) (let Parse_X (hd (hd V969)) (if (and (not (= <-- Parse_X)) (shen.legitimate-term? Parse_X)) (shen.pair (hd (shen.pair (tl (hd V969)) (shen.hdtl V969))) (shen.eval-cons Parse_X)) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.legitimate-term? (V974) (cond ((and (cons? V974) (and (= cons (hd V974)) (and (cons? (tl V974)) (and (cons? (tl (tl V974))) (= () (tl (tl (tl V974)))))))) (and (shen.legitimate-term? (hd (tl V974))) (shen.legitimate-term? (hd (tl (tl V974)))))) ((and (cons? V974) (and (= mode (hd V974)) (and (cons? (tl V974)) (and (cons? (tl (tl V974))) (and (= + (hd (tl (tl V974)))) (= () (tl (tl (tl V974))))))))) (shen.legitimate-term? (hd (tl V974)))) ((and (cons? V974) (and (= mode (hd V974)) (and (cons? (tl V974)) (and (cons? (tl (tl V974))) (and (= - (hd (tl (tl V974)))) (= () (tl (tl (tl V974))))))))) (shen.legitimate-term? (hd (tl V974)))) ((cons? V974) false) (true true)))

(defun shen.eval-cons (V975) (cond ((and (cons? V975) (and (= cons (hd V975)) (and (cons? (tl V975)) (and (cons? (tl (tl V975))) (= () (tl (tl (tl V975)))))))) (cons (shen.eval-cons (hd (tl V975))) (shen.eval-cons (hd (tl (tl V975)))))) ((and (cons? V975) (and (= mode (hd V975)) (and (cons? (tl V975)) (and (cons? (tl (tl V975))) (= () (tl (tl (tl V975)))))))) (cons mode (cons (shen.eval-cons (hd (tl V975))) (tl (tl V975))))) (true V975)))

(defun shen.<body*> (V980) (let Result (let Parse_shen.<literal*> (shen.<literal*> V980) (if (not (= (fail) Parse_shen.<literal*>)) (let Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>) (if (not (= (fail) Parse_shen.<body*>)) (shen.pair (hd Parse_shen.<body*>) (cons (shen.hdtl Parse_shen.<literal*>) (shen.hdtl Parse_shen.<body*>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V980) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (append (shen.hdtl Parse_<e>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<literal*> (V985) (let Result (if (and (cons? (hd V985)) (= ! (hd (hd V985)))) (shen.pair (hd (shen.pair (tl (hd V985)) (shen.hdtl V985))) (cons cut (cons (intern "Throwcontrol") ()))) (fail)) (if (= Result (fail)) (let Result (if (cons? (hd V985)) (let Parse_X (hd (hd V985)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V985)) (shen.hdtl V985))) Parse_X) (fail))) (fail)) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<end*> (V990) (let Result (if (cons? (hd V990)) (let Parse_X (hd (hd V990)) (if (= Parse_X ;) (shen.pair (hd (shen.pair (tl (hd V990)) (shen.hdtl V990))) Parse_X) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun cut (V991 V992 V993) (let Result (thaw V993) (if (= Result false) V991 Result)))

(defun shen.insert_modes (V994) (cond ((and (cons? V994) (and (= mode (hd V994)) (and (cons? (tl V994)) (and (cons? (tl (tl V994))) (= () (tl (tl (tl V994)))))))) V994) ((= () V994) ()) ((cons? V994) (cons (cons mode (cons (hd V994) (cons + ()))) (cons mode (cons (shen.insert_modes (tl V994)) (cons - ()))))) (true V994)))

(defun shen.s-prolog (V995) (map (lambda V921 (eval V921)) (shen.prolog->shen V995)))

(defun shen.prolog->shen (V996) (map shen.compile_prolog_procedure (shen.group_clauses (map shen.s-prolog_clause (mapcan shen.head_abstraction V996)))))

(defun shen.s-prolog_clause (V997) (cond ((and (cons? V997) (and (cons? (tl V997)) (and (= :- (hd (tl V997))) (and (cons? (tl (tl V997))) (= () (tl (tl (tl V997)))))))) (cons (hd V997) (cons :- (cons (map shen.s-prolog_literal (hd (tl (tl V997)))) ())))) (true (shen.sys-error shen.s-prolog_clause))))

(defun shen.head_abstraction (V998) (cond ((and (cons? V998) (and (cons? (tl V998)) (and (= :- (hd (tl V998))) (and (cons? (tl (tl V998))) (and (= () (tl (tl (tl V998)))) (< (shen.complexity_head (hd V998)) (value shen.*maxcomplexity*))))))) (cons V998 ())) ((and (cons? V998) (and (cons? (hd V998)) (and (cons? (tl V998)) (and (= :- (hd (tl V998))) (and (cons? (tl (tl V998))) (= () (tl (tl (tl V998))))))))) (let Terms (map (lambda Y (gensym V)) (tl (hd V998))) (let XTerms (shen.rcons_form (shen.remove_modes (tl (hd V998)))) (let Literal (cons unify (cons (shen.cons_form Terms) (cons XTerms ()))) (let Clause (cons (cons (hd (hd V998)) Terms) (cons :- (cons (cons Literal (hd (tl (tl V998)))) ()))) (cons Clause ())))))) (true (shen.sys-error shen.head_abstraction))))

(defun shen.complexity_head (V1003) (cond ((cons? V1003) (shen.product (map shen.complexity (tl V1003)))) (true (shen.sys-error shen.complexity_head))))

(defun shen.complexity (V1011) (cond ((and (cons? V1011) (and (= mode (hd V1011)) (and (cons? (tl V1011)) (and (cons? (hd (tl V1011))) (and (= mode (hd (hd (tl V1011)))) (and (cons? (tl (hd (tl V1011)))) (and (cons? (tl (tl (hd (tl V1011))))) (and (= () (tl (tl (tl (hd (tl V1011)))))) (and (cons? (tl (tl V1011))) (= () (tl (tl (tl V1011))))))))))))) (shen.complexity (hd (tl V1011)))) ((and (cons? V1011) (and (= mode (hd V1011)) (and (cons? (tl V1011)) (and (cons? (hd (tl V1011))) (and (cons? (tl (tl V1011))) (and (= + (hd (tl (tl V1011)))) (= () (tl (tl (tl V1011)))))))))) (* 2 (* (shen.complexity (cons mode (cons (hd (hd (tl V1011))) (tl (tl V1011))))) (shen.complexity (cons mode (cons (tl (hd (tl V1011))) (tl (tl V1011)))))))) ((and (cons? V1011) (and (= mode (hd V1011)) (and (cons? (tl V1011)) (and (cons? (hd (tl V1011))) (and (cons? (tl (tl V1011))) (and (= - (hd (tl (tl V1011)))) (= () (tl (tl (tl V1011)))))))))) (* (shen.complexity (cons mode (cons (hd (hd (tl V1011))) (tl (tl V1011))))) (shen.complexity (cons mode (cons (tl (hd (tl V1011))) (tl (tl V1011))))))) ((and (cons? V1011) (and (= mode (hd V1011)) (and (cons? (tl V1011)) (and (cons? (tl (tl V1011))) (and (= () (tl (tl (tl V1011)))) (variable? (hd (tl V1011)))))))) 1) ((and (cons? V1011) (and (= mode (hd V1011)) (and (cons? (tl V1011)) (and (cons? (tl (tl V1011))) (and (= + (hd (tl (tl V1011)))) (= () (tl (tl (tl V1011))))))))) 2) ((and (cons? V1011) (and (= mode (hd V1011)) (and (cons? (tl V1011)) (and (cons? (tl (tl V1011))) (and (= - (hd (tl (tl V1011)))) (= () (tl (tl (tl V1011))))))))) 1) (true (shen.complexity (cons mode (cons V1011 (cons + ())))))))

(defun shen.product (V1012) (cond ((= () V1012) 1) ((cons? V1012) (* (hd V1012) (shen.product (tl V1012)))) (true (shen.sys-error shen.product))))

(defun shen.s-prolog_literal (V1013) (cond ((and (cons? V1013) (and (= is (hd V1013)) (and (cons? (tl V1013)) (and (cons? (tl (tl V1013))) (= () (tl (tl (tl V1013)))))))) (cons bind (cons (hd (tl V1013)) (cons (shen.insert_deref (hd (tl (tl V1013)))) ())))) ((and (cons? V1013) (and (= when (hd V1013)) (and (cons? (tl V1013)) (= () (tl (tl V1013)))))) (cons fwhen (cons (shen.insert_deref (hd (tl V1013))) ()))) ((and (cons? V1013) (and (= bind (hd V1013)) (and (cons? (tl V1013)) (and (cons? (tl (tl V1013))) (= () (tl (tl (tl V1013)))))))) (cons bind (cons (hd (tl V1013)) (cons (shen.insert_lazyderef (hd (tl (tl V1013)))) ())))) ((and (cons? V1013) (and (= fwhen (hd V1013)) (and (cons? (tl V1013)) (= () (tl (tl V1013)))))) (cons fwhen (cons (shen.insert_lazyderef (hd (tl V1013))) ()))) ((cons? V1013) (cons (shen.m_prolog_to_s-prolog_predicate (hd V1013)) (tl V1013))) (true (shen.sys-error shen.s-prolog_literal))))

(defun shen.insert_deref (V1014) (cond ((variable? V1014) (cons shen.deref (cons V1014 (cons ProcessN ())))) ((cons? V1014) (cons (shen.insert_deref (hd V1014)) (shen.insert_deref (tl V1014)))) (true V1014)))

(defun shen.insert_lazyderef (V1015) (cond ((variable? V1015) (cons shen.lazyderef (cons V1015 (cons ProcessN ())))) ((cons? V1015) (cons (shen.insert_lazyderef (hd V1015)) (shen.insert_lazyderef (tl V1015)))) (true V1015)))

(defun shen.m_prolog_to_s-prolog_predicate (V1016) (cond ((= = V1016) unify) ((= =! V1016) unify!) ((= == V1016) identical) (true V1016)))

(defun shen.group_clauses (V1017) (cond ((= () V1017) ()) ((cons? V1017) (let Group (shen.collect (lambda X (shen.same_predicate? (hd V1017) X)) V1017) (let Rest (difference V1017 Group) (cons Group (shen.group_clauses Rest))))) (true (shen.sys-error shen.group_clauses))))

(defun shen.collect (V1020 V1021) (cond ((= () V1021) ()) ((cons? V1021) (if (V1020 (hd V1021)) (cons (hd V1021) (shen.collect V1020 (tl V1021))) (shen.collect V1020 (tl V1021)))) (true (shen.sys-error shen.collect))))

(defun shen.same_predicate? (V1038 V1039) (cond ((and (cons? V1038) (and (cons? (hd V1038)) (and (cons? V1039) (cons? (hd V1039))))) (= (hd (hd V1038)) (hd (hd V1039)))) (true (shen.sys-error shen.same_predicate?))))

(defun shen.compile_prolog_procedure (V1040) (let F (shen.procedure_name V1040) (let Shen (shen.clauses-to-shen F V1040) Shen)))

(defun shen.procedure_name (V1053) (cond ((and (cons? V1053) (and (cons? (hd V1053)) (cons? (hd (hd V1053))))) (hd (hd (hd V1053)))) (true (shen.sys-error shen.procedure_name))))

(defun shen.clauses-to-shen (V1054 V1055) (let Linear (map shen.linearise-clause V1055) (let Arity (shen.prolog-aritycheck V1054 (map (lambda V922 (head V922)) V1055)) (let Parameters (shen.parameters Arity) (let AUM_instructions (map (lambda X (shen.aum X Parameters)) Linear) (let Code (shen.catch-cut (shen.nest-disjunct (map shen.aum_to_shen AUM_instructions))) (let ShenDef (cons define (cons V1054 (append Parameters (append (cons ProcessN (cons Continuation ())) (cons -> (cons Code ())))))) ShenDef)))))))

(defun shen.catch-cut (V1056) (cond ((not (shen.occurs? cut V1056)) V1056) (true (cons let (cons Throwcontrol (cons (cons shen.catchpoint ()) (cons (cons shen.cutpoint (cons Throwcontrol (cons V1056 ()))) ())))))))

(defun shen.catchpoint () (set shen.*catch* (+ 1 (value shen.*catch*))))

(defun shen.cutpoint (V1061 V1062) (cond ((= V1062 V1061) false) (true V1062)))

(defun shen.nest-disjunct (V1064) (cond ((and (cons? V1064) (= () (tl V1064))) (hd V1064)) ((cons? V1064) (shen.lisp-or (hd V1064) (shen.nest-disjunct (tl V1064)))) (true (shen.sys-error shen.nest-disjunct))))

(defun shen.lisp-or (V1065 V1066) (cons let (cons Case (cons V1065 (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons V1066 (cons Case ())))) ())))))

(defun shen.prolog-aritycheck (V1069 V1070) (cond ((and (cons? V1070) (= () (tl V1070))) (- (length (hd V1070)) 1)) ((and (cons? V1070) (cons? (tl V1070))) (if (= (length (hd V1070)) (length (hd (tl V1070)))) (shen.prolog-aritycheck V1069 (tl V1070)) (simple-error (cn "arity error in prolog procedure " (shen.app (cons V1069 ()) "
" shen.a))))) (true (shen.sys-error shen.prolog-aritycheck))))

(defun shen.linearise-clause (V1071) (cond ((and (cons? V1071) (and (cons? (tl V1071)) (and (= :- (hd (tl V1071))) (and (cons? (tl (tl V1071))) (= () (tl (tl (tl V1071)))))))) (let Linear (shen.linearise (cons (hd V1071) (tl (tl V1071)))) (shen.clause_form Linear))) (true (shen.sys-error shen.linearise-clause))))

(defun shen.clause_form (V1072) (cond ((and (cons? V1072) (and (cons? (tl V1072)) (= () (tl (tl V1072))))) (cons (shen.explicit_modes (hd V1072)) (cons :- (cons (shen.cf_help (hd (tl V1072))) ())))) (true (shen.sys-error shen.clause_form))))

(defun shen.explicit_modes (V1073) (cond ((cons? V1073) (cons (hd V1073) (map shen.em_help (tl V1073)))) (true (shen.sys-error shen.explicit_modes))))

(defun shen.em_help (V1074) (cond ((and (cons? V1074) (and (= mode (hd V1074)) (and (cons? (tl V1074)) (and (cons? (tl (tl V1074))) (= () (tl (tl (tl V1074)))))))) V1074) (true (cons mode (cons V1074 (cons + ()))))))

(defun shen.cf_help (V1075) (cond ((and (cons? V1075) (and (= where (hd V1075)) (and (cons? (tl V1075)) (and (cons? (hd (tl V1075))) (and (= = (hd (hd (tl V1075)))) (and (cons? (tl (hd (tl V1075)))) (and (cons? (tl (tl (hd (tl V1075))))) (and (= () (tl (tl (tl (hd (tl V1075)))))) (and (cons? (tl (tl V1075))) (= () (tl (tl (tl V1075))))))))))))) (cons (cons (if (value shen.*occurs*) unify! unify) (tl (hd (tl V1075)))) (shen.cf_help (hd (tl (tl V1075)))))) (true V1075)))

(defun occurs-check (V1080) (cond ((= + V1080) (set shen.*occurs* true)) ((= - V1080) (set shen.*occurs* false)) (true (simple-error "occurs-check expects + or -
"))))

(defun shen.aum (V1081 V1082) (cond ((and (cons? V1081) (and (cons? (hd V1081)) (and (cons? (tl V1081)) (and (= :- (hd (tl V1081))) (and (cons? (tl (tl V1081))) (= () (tl (tl (tl V1081))))))))) (let MuApplication (shen.make_mu_application (cons shen.mu (cons (tl (hd V1081)) (cons (shen.continuation_call (tl (hd V1081)) (hd (tl (tl V1081)))) ()))) V1082) (shen.mu_reduction MuApplication +))) (true (shen.sys-error shen.aum))))

(defun shen.continuation_call (V1083 V1084) (let VTerms (cons ProcessN (shen.extract_vars V1083)) (let VBody (shen.extract_vars V1084) (let Free (remove Throwcontrol (difference VBody VTerms)) (shen.cc_help Free V1084)))))

(defun remove (V1085 V1086) (shen.remove-h V1085 V1086 ()))

(defun shen.remove-h (V1089 V1090 V1091) (cond ((= () V1090) (reverse V1091)) ((and (cons? V1090) (= (hd V1090) V1089)) (shen.remove-h (hd V1090) (tl V1090) V1091)) ((cons? V1090) (shen.remove-h V1089 (tl V1090) (cons (hd V1090) V1091))) (true (shen.sys-error shen.remove-h))))

(defun shen.cc_help (V1093 V1094) (cond ((and (= () V1093) (= () V1094)) (cons shen.pop (cons shen.the (cons shen.stack ())))) ((= () V1094) (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1093 (cons and (cons shen.then (cons (cons shen.pop (cons shen.the (cons shen.stack ()))) ()))))))))) ((= () V1093) (cons call (cons shen.the (cons shen.continuation (cons V1094 ()))))) (true (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1093 (cons and (cons shen.then (cons (cons call (cons shen.the (cons shen.continuation (cons V1094 ())))) ())))))))))))

(defun shen.make_mu_application (V1095 V1096) (cond ((and (cons? V1095) (and (= shen.mu (hd V1095)) (and (cons? (tl V1095)) (and (= () (hd (tl V1095))) (and (cons? (tl (tl V1095))) (and (= () (tl (tl (tl V1095)))) (= () V1096))))))) (hd (tl (tl V1095)))) ((and (cons? V1095) (and (= shen.mu (hd V1095)) (and (cons? (tl V1095)) (and (cons? (hd (tl V1095))) (and (cons? (tl (tl V1095))) (and (= () (tl (tl (tl V1095)))) (cons? V1096))))))) (cons (cons shen.mu (cons (hd (hd (tl V1095))) (cons (shen.make_mu_application (cons shen.mu (cons (tl (hd (tl V1095))) (tl (tl V1095)))) (tl V1096)) ()))) (cons (hd V1096) ()))) (true (shen.sys-error shen.make_mu_application))))

(defun shen.mu_reduction (V1103 V1104) (cond ((and (cons? V1103) (and (cons? (hd V1103)) (and (= shen.mu (hd (hd V1103))) (and (cons? (tl (hd V1103))) (and (cons? (hd (tl (hd V1103)))) (and (= mode (hd (hd (tl (hd V1103))))) (and (cons? (tl (hd (tl (hd V1103))))) (and (cons? (tl (tl (hd (tl (hd V1103)))))) (and (= () (tl (tl (tl (hd (tl (hd V1103))))))) (and (cons? (tl (tl (hd V1103)))) (and (= () (tl (tl (tl (hd V1103))))) (and (cons? (tl V1103)) (= () (tl (tl V1103))))))))))))))) (shen.mu_reduction (cons (cons shen.mu (cons (hd (tl (hd (tl (hd V1103))))) (tl (tl (hd V1103))))) (tl V1103)) (hd (tl (tl (hd (tl (hd V1103)))))))) ((and (cons? V1103) (and (cons? (hd V1103)) (and (= shen.mu (hd (hd V1103))) (and (cons? (tl (hd V1103))) (and (cons? (tl (tl (hd V1103)))) (and (= () (tl (tl (tl (hd V1103))))) (and (cons? (tl V1103)) (and (= () (tl (tl V1103))) (= _ (hd (tl (hd V1103)))))))))))) (shen.mu_reduction (hd (tl (tl (hd V1103)))) V1104)) ((and (cons? V1103) (and (cons? (hd V1103)) (and (= shen.mu (hd (hd V1103))) (and (cons? (tl (hd V1103))) (and (cons? (tl (tl (hd V1103)))) (and (= () (tl (tl (tl (hd V1103))))) (and (cons? (tl V1103)) (and (= () (tl (tl V1103))) (shen.ephemeral_variable? (hd (tl (hd V1103))) (hd (tl V1103))))))))))) (subst (hd (tl V1103)) (hd (tl (hd V1103))) (shen.mu_reduction (hd (tl (tl (hd V1103)))) V1104))) ((and (cons? V1103) (and (cons? (hd V1103)) (and (= shen.mu (hd (hd V1103))) (and (cons? (tl (hd V1103))) (and (cons? (tl (tl (hd V1103)))) (and (= () (tl (tl (tl (hd V1103))))) (and (cons? (tl V1103)) (and (= () (tl (tl V1103))) (variable? (hd (tl (hd V1103)))))))))))) (cons let (cons (hd (tl (hd V1103))) (cons shen.be (cons (hd (tl V1103)) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1103)))) V1104) ()))))))) ((and (cons? V1103) (and (cons? (hd V1103)) (and (= shen.mu (hd (hd V1103))) (and (cons? (tl (hd V1103))) (and (cons? (tl (tl (hd V1103)))) (and (= () (tl (tl (tl (hd V1103))))) (and (cons? (tl V1103)) (and (= () (tl (tl V1103))) (and (= - V1104) (shen.prolog_constant? (hd (tl (hd V1103))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1103))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1103))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1103)))) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1103) (and (cons? (hd V1103)) (and (= shen.mu (hd (hd V1103))) (and (cons? (tl (hd V1103))) (and (cons? (tl (tl (hd V1103)))) (and (= () (tl (tl (tl (hd V1103))))) (and (cons? (tl V1103)) (and (= () (tl (tl V1103))) (and (= + V1104) (shen.prolog_constant? (hd (tl (hd V1103))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1103))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1103))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1103)))) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (hd (tl (hd V1103))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1103)))) +) ())))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) ((and (cons? V1103) (and (cons? (hd V1103)) (and (= shen.mu (hd (hd V1103))) (and (cons? (tl (hd V1103))) (and (cons? (hd (tl (hd V1103)))) (and (cons? (tl (tl (hd V1103)))) (and (= () (tl (tl (tl (hd V1103))))) (and (cons? (tl V1103)) (and (= () (tl (tl V1103))) (= - V1104)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1103))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1103)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1103)))) (tl (tl (hd V1103))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1103) (and (cons? (hd V1103)) (and (= shen.mu (hd (hd V1103))) (and (cons? (tl (hd V1103))) (and (cons? (hd (tl (hd V1103)))) (and (cons? (tl (tl (hd V1103)))) (and (= () (tl (tl (tl (hd V1103))))) (and (cons? (tl V1103)) (and (= () (tl (tl V1103))) (= + V1104)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1103))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1103)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1103)))) (tl (tl (hd V1103))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (shen.extract_vars (hd (tl (hd V1103)))) (cons and (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (shen.rcons_form (shen.remove_modes (hd (tl (hd V1103))))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1103)))) +) ())))))) ())))))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) (true V1103)))

(defun shen.rcons_form (V1105) (cond ((cons? V1105) (cons cons (cons (shen.rcons_form (hd V1105)) (cons (shen.rcons_form (tl V1105)) ())))) (true V1105)))

(defun shen.remove_modes (V1106) (cond ((and (cons? V1106) (and (= mode (hd V1106)) (and (cons? (tl V1106)) (and (cons? (tl (tl V1106))) (and (= + (hd (tl (tl V1106)))) (= () (tl (tl (tl V1106))))))))) (shen.remove_modes (hd (tl V1106)))) ((and (cons? V1106) (and (= mode (hd V1106)) (and (cons? (tl V1106)) (and (cons? (tl (tl V1106))) (and (= - (hd (tl (tl V1106)))) (= () (tl (tl (tl V1106))))))))) (shen.remove_modes (hd (tl V1106)))) ((cons? V1106) (cons (shen.remove_modes (hd V1106)) (shen.remove_modes (tl V1106)))) (true V1106)))

(defun shen.ephemeral_variable? (V1107 V1108) (and (variable? V1107) (variable? V1108)))

(defun shen.prolog_constant? (V1117) (cond ((cons? V1117) false) (true true)))

(defun shen.aum_to_shen (V1118) (cond ((and (cons? V1118) (and (= let (hd V1118)) (and (cons? (tl V1118)) (and (cons? (tl (tl V1118))) (and (= shen.be (hd (tl (tl V1118)))) (and (cons? (tl (tl (tl V1118)))) (and (cons? (tl (tl (tl (tl V1118))))) (and (= in (hd (tl (tl (tl (tl V1118)))))) (and (cons? (tl (tl (tl (tl (tl V1118)))))) (= () (tl (tl (tl (tl (tl (tl V1118)))))))))))))))) (cons let (cons (hd (tl V1118)) (cons (shen.aum_to_shen (hd (tl (tl (tl V1118))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1118))))))) ()))))) ((and (cons? V1118) (and (= shen.the (hd V1118)) (and (cons? (tl V1118)) (and (= shen.result (hd (tl V1118))) (and (cons? (tl (tl V1118))) (and (= shen.of (hd (tl (tl V1118)))) (and (cons? (tl (tl (tl V1118)))) (and (= shen.dereferencing (hd (tl (tl (tl V1118))))) (and (cons? (tl (tl (tl (tl V1118))))) (= () (tl (tl (tl (tl (tl V1118))))))))))))))) (cons shen.lazyderef (cons (shen.aum_to_shen (hd (tl (tl (tl (tl V1118)))))) (cons ProcessN ())))) ((and (cons? V1118) (and (= if (hd V1118)) (and (cons? (tl V1118)) (and (cons? (tl (tl V1118))) (and (= shen.then (hd (tl (tl V1118)))) (and (cons? (tl (tl (tl V1118)))) (and (cons? (tl (tl (tl (tl V1118))))) (and (= shen.else (hd (tl (tl (tl (tl V1118)))))) (and (cons? (tl (tl (tl (tl (tl V1118)))))) (= () (tl (tl (tl (tl (tl (tl V1118)))))))))))))))) (cons if (cons (shen.aum_to_shen (hd (tl V1118))) (cons (shen.aum_to_shen (hd (tl (tl (tl V1118))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1118))))))) ()))))) ((and (cons? V1118) (and (cons? (tl V1118)) (and (= is (hd (tl V1118))) (and (cons? (tl (tl V1118))) (and (= shen.a (hd (tl (tl V1118)))) (and (cons? (tl (tl (tl V1118)))) (and (= shen.variable (hd (tl (tl (tl V1118))))) (= () (tl (tl (tl (tl V1118)))))))))))) (cons shen.pvar? (cons (hd V1118) ()))) ((and (cons? V1118) (and (cons? (tl V1118)) (and (= is (hd (tl V1118))) (and (cons? (tl (tl V1118))) (and (= shen.a (hd (tl (tl V1118)))) (and (cons? (tl (tl (tl V1118)))) (and (= shen.non-empty (hd (tl (tl (tl V1118))))) (and (cons? (tl (tl (tl (tl V1118))))) (and (= list (hd (tl (tl (tl (tl V1118)))))) (= () (tl (tl (tl (tl (tl V1118))))))))))))))) (cons cons? (cons (hd V1118) ()))) ((and (cons? V1118) (and (= shen.rename (hd V1118)) (and (cons? (tl V1118)) (and (= shen.the (hd (tl V1118))) (and (cons? (tl (tl V1118))) (and (= shen.variables (hd (tl (tl V1118)))) (and (cons? (tl (tl (tl V1118)))) (and (= in (hd (tl (tl (tl V1118))))) (and (cons? (tl (tl (tl (tl V1118))))) (and (= () (hd (tl (tl (tl (tl V1118)))))) (and (cons? (tl (tl (tl (tl (tl V1118)))))) (and (= and (hd (tl (tl (tl (tl (tl V1118))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1118))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1118)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1118)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1118)))))))))))))))))))))))) (shen.aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V1118)))))))))) ((and (cons? V1118) (and (= shen.rename (hd V1118)) (and (cons? (tl V1118)) (and (= shen.the (hd (tl V1118))) (and (cons? (tl (tl V1118))) (and (= shen.variables (hd (tl (tl V1118)))) (and (cons? (tl (tl (tl V1118)))) (and (= in (hd (tl (tl (tl V1118))))) (and (cons? (tl (tl (tl (tl V1118))))) (and (cons? (hd (tl (tl (tl (tl V1118)))))) (and (cons? (tl (tl (tl (tl (tl V1118)))))) (and (= and (hd (tl (tl (tl (tl (tl V1118))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1118))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1118)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1118)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1118)))))))))))))))))))))))) (cons let (cons (hd (hd (tl (tl (tl (tl V1118)))))) (cons (cons shen.newpv (cons ProcessN ())) (cons (shen.aum_to_shen (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (tl (hd (tl (tl (tl (tl V1118)))))) (tl (tl (tl (tl (tl V1118))))))))))) ()))))) ((and (cons? V1118) (and (= bind (hd V1118)) (and (cons? (tl V1118)) (and (cons? (tl (tl V1118))) (and (= shen.to (hd (tl (tl V1118)))) (and (cons? (tl (tl (tl V1118)))) (and (cons? (tl (tl (tl (tl V1118))))) (and (= in (hd (tl (tl (tl (tl V1118)))))) (and (cons? (tl (tl (tl (tl (tl V1118)))))) (= () (tl (tl (tl (tl (tl (tl V1118)))))))))))))))) (cons do (cons (cons shen.bindv (cons (hd (tl V1118)) (cons (shen.chwild (hd (tl (tl (tl V1118))))) (cons ProcessN ())))) (cons (cons let (cons Result (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1118))))))) (cons (cons do (cons (cons shen.unbindv (cons (hd (tl V1118)) (cons ProcessN ()))) (cons Result ()))) ())))) ())))) ((and (cons? V1118) (and (cons? (tl V1118)) (and (= is (hd (tl V1118))) (and (cons? (tl (tl V1118))) (and (= identical (hd (tl (tl V1118)))) (and (cons? (tl (tl (tl V1118)))) (and (= shen.to (hd (tl (tl (tl V1118))))) (and (cons? (tl (tl (tl (tl V1118))))) (= () (tl (tl (tl (tl (tl V1118)))))))))))))) (cons = (cons (hd (tl (tl (tl (tl V1118))))) (cons (hd V1118) ())))) ((= shen.failed! V1118) false) ((and (cons? V1118) (and (= shen.the (hd V1118)) (and (cons? (tl V1118)) (and (= head (hd (tl V1118))) (and (cons? (tl (tl V1118))) (and (= shen.of (hd (tl (tl V1118)))) (and (cons? (tl (tl (tl V1118)))) (= () (tl (tl (tl (tl V1118)))))))))))) (cons hd (tl (tl (tl V1118))))) ((and (cons? V1118) (and (= shen.the (hd V1118)) (and (cons? (tl V1118)) (and (= tail (hd (tl V1118))) (and (cons? (tl (tl V1118))) (and (= shen.of (hd (tl (tl V1118)))) (and (cons? (tl (tl (tl V1118)))) (= () (tl (tl (tl (tl V1118)))))))))))) (cons tl (tl (tl (tl V1118))))) ((and (cons? V1118) (and (= shen.pop (hd V1118)) (and (cons? (tl V1118)) (and (= shen.the (hd (tl V1118))) (and (cons? (tl (tl V1118))) (and (= shen.stack (hd (tl (tl V1118)))) (= () (tl (tl (tl V1118)))))))))) (cons do (cons (cons shen.incinfs ()) (cons (cons thaw (cons Continuation ())) ())))) ((and (cons? V1118) (and (= call (hd V1118)) (and (cons? (tl V1118)) (and (= shen.the (hd (tl V1118))) (and (cons? (tl (tl V1118))) (and (= shen.continuation (hd (tl (tl V1118)))) (and (cons? (tl (tl (tl V1118)))) (= () (tl (tl (tl (tl V1118)))))))))))) (cons do (cons (cons shen.incinfs ()) (cons (shen.call_the_continuation (shen.chwild (hd (tl (tl (tl V1118))))) ProcessN Continuation) ())))) (true V1118)))

(defun shen.chwild (V1119) (cond ((= V1119 _) (cons shen.newpv (cons ProcessN ()))) ((cons? V1119) (map shen.chwild V1119)) (true V1119)))

(defun shen.newpv (V1120) (let Count+1 (+ (<-address (value shen.*varcounter*) V1120) 1) (let IncVar (address-> (value shen.*varcounter*) V1120 Count+1) (let Vector (<-address (value shen.*prologvectors*) V1120) (let ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen.resizeprocessvector V1120 Count+1) shen.skip) (shen.mk-pvar Count+1))))))

(defun shen.resizeprocessvector (V1121 V1122) (let Vector (<-address (value shen.*prologvectors*) V1121) (let BigVector (shen.resize-vector Vector (+ V1122 V1122) shen.-null-) (address-> (value shen.*prologvectors*) V1121 BigVector))))

(defun shen.resize-vector (V1123 V1124 V1125) (let BigVector (address-> (absvector (+ 1 V1124)) 0 V1124) (shen.copy-vector V1123 BigVector (limit V1123) V1124 V1125)))

(defun shen.copy-vector (V1126 V1127 V1128 V1129 V1130) (shen.copy-vector-stage-2 (+ 1 V1128) (+ V1129 1) V1130 (shen.copy-vector-stage-1 1 V1126 V1127 (+ 1 V1128))))

(defun shen.copy-vector-stage-1 (V1133 V1134 V1135 V1136) (cond ((= V1136 V1133) V1135) (true (shen.copy-vector-stage-1 (+ 1 V1133) V1134 (address-> V1135 V1133 (<-address V1134 V1133)) V1136))))

(defun shen.copy-vector-stage-2 (V1140 V1141 V1142 V1143) (cond ((= V1141 V1140) V1143) (true (shen.copy-vector-stage-2 (+ V1140 1) V1141 V1142 (address-> V1143 V1140 V1142)))))

(defun shen.mk-pvar (V1145) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V1145))

(defun shen.pvar? (V1146) (and (absvector? V1146) (= (<-address V1146 0) shen.pvar)))

(defun shen.bindv (V1147 V1148 V1149) (let Vector (<-address (value shen.*prologvectors*) V1149) (address-> Vector (<-address V1147 1) V1148)))

(defun shen.unbindv (V1150 V1151) (let Vector (<-address (value shen.*prologvectors*) V1151) (address-> Vector (<-address V1150 1) shen.-null-)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.call_the_continuation (V1152 V1153 V1154) (cond ((and (cons? V1152) (and (cons? (hd V1152)) (= () (tl V1152)))) (cons (hd (hd V1152)) (append (tl (hd V1152)) (cons V1153 (cons V1154 ()))))) ((and (cons? V1152) (cons? (hd V1152))) (let NewContinuation (shen.newcontinuation (tl V1152) V1153 V1154) (cons (hd (hd V1152)) (append (tl (hd V1152)) (cons V1153 (cons NewContinuation ())))))) (true (shen.sys-error shen.call_the_continuation))))

(defun shen.newcontinuation (V1155 V1156 V1157) (cond ((= () V1155) V1157) ((and (cons? V1155) (cons? (hd V1155))) (cons freeze (cons (cons (hd (hd V1155)) (append (tl (hd V1155)) (cons V1156 (cons (shen.newcontinuation (tl V1155) V1156 V1157) ())))) ()))) (true (shen.sys-error shen.newcontinuation))))

(defun return (V1162 V1163 V1164) (shen.deref V1162 V1163))

(defun shen.measure&return (V1169 V1170 V1171) (do (shen.prhush (shen.app (value shen.*infs*) " inferences
" shen.a) (stoutput)) (shen.deref V1169 V1170)))

(defun unify (V1172 V1173 V1174 V1175) (shen.lzy= (shen.lazyderef V1172 V1174) (shen.lazyderef V1173 V1174) V1174 V1175))

(defun shen.lzy= (V1192 V1193 V1194 V1195) (cond ((= V1193 V1192) (thaw V1195)) ((shen.pvar? V1192) (bind V1192 V1193 V1194 V1195)) ((shen.pvar? V1193) (bind V1193 V1192 V1194 V1195)) ((and (cons? V1192) (cons? V1193)) (shen.lzy= (shen.lazyderef (hd V1192) V1194) (shen.lazyderef (hd V1193) V1194) V1194 (freeze (shen.lzy= (shen.lazyderef (tl V1192) V1194) (shen.lazyderef (tl V1193) V1194) V1194 V1195)))) (true false)))

(defun shen.deref (V1197 V1198) (cond ((cons? V1197) (cons (shen.deref (hd V1197) V1198) (shen.deref (tl V1197) V1198))) (true (if (shen.pvar? V1197) (let Value (shen.valvector V1197 V1198) (if (= Value shen.-null-) V1197 (shen.deref Value V1198))) V1197))))

(defun shen.lazyderef (V1199 V1200) (if (shen.pvar? V1199) (let Value (shen.valvector V1199 V1200) (if (= Value shen.-null-) V1199 (shen.lazyderef Value V1200))) V1199))

(defun shen.valvector (V1201 V1202) (<-address (<-address (value shen.*prologvectors*) V1202) (<-address V1201 1)))

(defun unify! (V1203 V1204 V1205 V1206) (shen.lzy=! (shen.lazyderef V1203 V1205) (shen.lazyderef V1204 V1205) V1205 V1206))

(defun shen.lzy=! (V1223 V1224 V1225 V1226) (cond ((= V1224 V1223) (thaw V1226)) ((and (shen.pvar? V1223) (not (shen.occurs? V1223 (shen.deref V1224 V1225)))) (bind V1223 V1224 V1225 V1226)) ((and (shen.pvar? V1224) (not (shen.occurs? V1224 (shen.deref V1223 V1225)))) (bind V1224 V1223 V1225 V1226)) ((and (cons? V1223) (cons? V1224)) (shen.lzy=! (shen.lazyderef (hd V1223) V1225) (shen.lazyderef (hd V1224) V1225) V1225 (freeze (shen.lzy=! (shen.lazyderef (tl V1223) V1225) (shen.lazyderef (tl V1224) V1225) V1225 V1226)))) (true false)))

(defun shen.occurs? (V1236 V1237) (cond ((= V1237 V1236) true) ((cons? V1237) (or (shen.occurs? V1236 (hd V1237)) (shen.occurs? V1236 (tl V1237)))) (true false)))

(defun identical (V1239 V1240 V1241 V1242) (shen.lzy== (shen.lazyderef V1239 V1241) (shen.lazyderef V1240 V1241) V1241 V1242))

(defun shen.lzy== (V1259 V1260 V1261 V1262) (cond ((= V1260 V1259) (thaw V1262)) ((and (cons? V1259) (cons? V1260)) (shen.lzy== (shen.lazyderef (hd V1259) V1261) (shen.lazyderef (hd V1260) V1261) V1261 (freeze (shen.lzy== (tl V1259) (tl V1260) V1261 V1262)))) (true false)))

(defun shen.pvar (V1264) (cn "Var" (shen.app (<-address V1264 1) "" shen.a)))

(defun bind (V1265 V1266 V1267 V1268) (do (shen.bindv V1265 V1266 V1267) (let Result (thaw V1268) (do (shen.unbindv V1265 V1267) Result))))

(defun fwhen (V1283 V1284 V1285) (cond ((= true V1283) (thaw V1285)) ((= false V1283) false) (true (simple-error (cn "fwhen expects a boolean: not " (shen.app V1283 "%" shen.s))))))

(defun call (V1298 V1299 V1300) (cond ((cons? V1298) (shen.call-help (shen.m_prolog_to_s-prolog_predicate (shen.lazyderef (hd V1298) V1299)) (tl V1298) V1299 V1300)) (true false)))

(defun shen.call-help (V1301 V1302 V1303 V1304) (cond ((= () V1302) (V1301 V1303 V1304)) ((cons? V1302) (shen.call-help (V1301 (hd V1302)) (tl V1302) V1303 V1304)) (true (shen.sys-error shen.call-help))))

(defun shen.intprolog (V1305) (cond ((and (cons? V1305) (cons? (hd V1305))) (let ProcessN (shen.start-new-prolog-process) (shen.intprolog-help (hd (hd V1305)) (shen.insert-prolog-variables (cons (tl (hd V1305)) (cons (tl V1305) ())) ProcessN) ProcessN))) (true (shen.sys-error shen.intprolog))))

(defun shen.intprolog-help (V1306 V1307 V1308) (cond ((and (cons? V1307) (and (cons? (tl V1307)) (= () (tl (tl V1307))))) (shen.intprolog-help-help V1306 (hd V1307) (hd (tl V1307)) V1308)) (true (shen.sys-error shen.intprolog-help))))

(defun shen.intprolog-help-help (V1309 V1310 V1311 V1312) (cond ((= () V1310) (V1309 V1312 (freeze (shen.call-rest V1311 V1312)))) ((cons? V1310) (shen.intprolog-help-help (V1309 (hd V1310)) (tl V1310) V1311 V1312)) (true (shen.sys-error shen.intprolog-help-help))))

(defun shen.call-rest (V1315 V1316) (cond ((= () V1315) true) ((and (cons? V1315) (and (cons? (hd V1315)) (cons? (tl (hd V1315))))) (shen.call-rest (cons (cons ((hd (hd V1315)) (hd (tl (hd V1315)))) (tl (tl (hd V1315)))) (tl V1315)) V1316)) ((and (cons? V1315) (and (cons? (hd V1315)) (= () (tl (hd V1315))))) ((hd (hd V1315)) V1316 (freeze (shen.call-rest (tl V1315) V1316)))) (true (shen.sys-error shen.call-rest))))

(defun shen.start-new-prolog-process () (let IncrementProcessCounter (set shen.*process-counter* (+ 1 (value shen.*process-counter*))) (shen.initialise-prolog IncrementProcessCounter)))

(defun shen.insert-prolog-variables (V1317 V1318) (shen.insert-prolog-variables-help V1317 (shen.flatten V1317) V1318))

(defun shen.insert-prolog-variables-help (V1323 V1324 V1325) (cond ((= () V1324) V1323) ((and (cons? V1324) (variable? (hd V1324))) (let V (shen.newpv V1325) (let XV/Y (subst V (hd V1324) V1323) (let Z-Y (remove (hd V1324) (tl V1324)) (shen.insert-prolog-variables-help XV/Y Z-Y V1325))))) ((cons? V1324) (shen.insert-prolog-variables-help V1323 (tl V1324) V1325)) (true (shen.sys-error shen.insert-prolog-variables-help))))

(defun shen.initialise-prolog (V1326) (let Vector (address-> (value shen.*prologvectors*) V1326 (shen.fillvector (vector 10) 1 10 shen.-null-)) (let Counter (address-> (value shen.*varcounter*) V1326 1) V1326)))



