"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.shen->kl (V607 V608) (compile shen.<define> (cons V607 V608) (lambda X (shen.shen-syntax-error V607 X))))

(defun shen.shen-syntax-error (V609 V610) (simple-error (cn "syntax error in " (shen.app V609 (cn " here:

 " (shen.app (shen.next-50 50 V610) "
" shen.a)) shen.a))))

(defun shen.<define> (V615) (let Result (let Parse_shen.<name> (shen.<name> V615) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<signature> (shen.<signature> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<name> (shen.<name> V615) (if (not (= (fail) Parse_shen.<name>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<name>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (shen.compile_to_machine_code (shen.hdtl Parse_shen.<name>) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<name> (V620) (let Result (if (cons? (hd V620)) (let Parse_X (hd (hd V620)) (shen.pair (hd (shen.pair (tl (hd V620)) (shen.hdtl V620))) (if (and (symbol? Parse_X) (not (shen.sysfunc? Parse_X))) Parse_X (simple-error (shen.app Parse_X " is not a legitimate function name.
" shen.a))))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.sysfunc? (V621) (element? V621 (get (intern "shen") shen.external-symbols (value *property-vector*))))

(defun shen.<signature> (V626) (let Result (if (and (cons? (hd V626)) (= { (hd (hd V626)))) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V626)) (shen.hdtl V626))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (and (cons? (hd Parse_shen.<signature-help>)) (= } (hd (hd Parse_shen.<signature-help>)))) (shen.pair (hd (shen.pair (tl (hd Parse_shen.<signature-help>)) (shen.hdtl Parse_shen.<signature-help>))) (shen.demodulate (shen.curry-type (shen.hdtl Parse_shen.<signature-help>)))) (fail)) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.curry-type (V629) (cond ((and (cons? V629) (and (cons? (tl V629)) (and (= --> (hd (tl V629))) (and (cons? (tl (tl V629))) (and (cons? (tl (tl (tl V629)))) (= --> (hd (tl (tl (tl V629)))))))))) (shen.curry-type (cons (hd V629) (cons --> (cons (tl (tl V629)) ()))))) ((and (cons? V629) (and (= cons (hd V629)) (and (cons? (tl V629)) (and (cons? (tl (tl V629))) (= () (tl (tl (tl V629)))))))) (cons list (cons (shen.curry-type (hd (tl V629))) ()))) ((and (cons? V629) (and (cons? (tl V629)) (and (= * (hd (tl V629))) (and (cons? (tl (tl V629))) (and (cons? (tl (tl (tl V629)))) (= * (hd (tl (tl (tl V629)))))))))) (shen.curry-type (cons (hd V629) (cons * (cons (tl (tl V629)) ()))))) ((cons? V629) (map shen.curry-type V629)) (true V629)))

(defun shen.<signature-help> (V634) (let Result (if (cons? (hd V634)) (let Parse_X (hd (hd V634)) (let Parse_shen.<signature-help> (shen.<signature-help> (shen.pair (tl (hd V634)) (shen.hdtl V634))) (if (not (= (fail) Parse_shen.<signature-help>)) (if (not (element? Parse_X (cons { (cons } ())))) (shen.pair (hd Parse_shen.<signature-help>) (cons Parse_X (shen.hdtl Parse_shen.<signature-help>))) (fail)) (fail)))) (fail)) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V634) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<rules> (V639) (let Result (let Parse_shen.<rule> (shen.<rule> V639) (if (not (= (fail) Parse_shen.<rule>)) (let Parse_shen.<rules> (shen.<rules> Parse_shen.<rule>) (if (not (= (fail) Parse_shen.<rules>)) (shen.pair (hd Parse_shen.<rules>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) (shen.hdtl Parse_shen.<rules>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<rule> (shen.<rule> V639) (if (not (= (fail) Parse_shen.<rule>)) (shen.pair (hd Parse_shen.<rule>) (cons (shen.linearise (shen.hdtl Parse_shen.<rule>)) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<rule> (V644) (let Result (let Parse_shen.<patterns> (shen.<patterns> V644) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<action>) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<patterns> (shen.<patterns> V644) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= -> (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<action>) ()))) (fail))) (fail)) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<patterns> (shen.<patterns> V644) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (if (and (cons? (hd Parse_shen.<action>)) (= where (hd (hd Parse_shen.<action>)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd Parse_shen.<action>)) (shen.hdtl Parse_shen.<action>))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons where (cons (shen.hdtl Parse_shen.<guard>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) ()))) (fail))) (fail)) (fail))) (fail)) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<patterns> (shen.<patterns> V644) (if (not (= (fail) Parse_shen.<patterns>)) (if (and (cons? (hd Parse_shen.<patterns>)) (= <- (hd (hd Parse_shen.<patterns>)))) (let Parse_shen.<action> (shen.<action> (shen.pair (tl (hd Parse_shen.<patterns>)) (shen.hdtl Parse_shen.<patterns>))) (if (not (= (fail) Parse_shen.<action>)) (shen.pair (hd Parse_shen.<action>) (cons (shen.hdtl Parse_shen.<patterns>) (cons (cons shen.choicepoint! (cons (shen.hdtl Parse_shen.<action>) ())) ()))) (fail))) (fail)) (fail))) (if (= Result (fail)) (fail) Result)) Result)) Result)) Result)))

(defun shen.fail_if (V645 V646) (if (V645 V646) (fail) V646))

(defun shen.succeeds? (V651) (cond ((= V651 (fail)) false) (true true)))

(defun shen.<patterns> (V656) (let Result (let Parse_shen.<pattern> (shen.<pattern> V656) (if (not (= (fail) Parse_shen.<pattern>)) (let Parse_shen.<patterns> (shen.<patterns> Parse_shen.<pattern>) (if (not (= (fail) Parse_shen.<patterns>)) (shen.pair (hd Parse_shen.<patterns>) (cons (shen.hdtl Parse_shen.<pattern>) (shen.hdtl Parse_shen.<patterns>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V656) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) ()) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<pattern> (V661) (let Result (if (and (cons? (hd V661)) (cons? (hd (hd V661)))) (shen.snd-or-fail (if (and (cons? (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))) (= @p (hd (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))) (shen.hdtl (shen.pair (hd (hd V661)) (shen.hdtl V661))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd Parse_shen.<pattern2>) (shen.pair (hd (shen.pair (tl (hd V661)) (shen.hdtl V661))) (cons @p (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ()))))) (fail))) (fail))) (fail))) (fail)) (if (= Result (fail)) (let Result (if (and (cons? (hd V661)) (cons? (hd (hd V661)))) (shen.snd-or-fail (if (and (cons? (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))) (= cons (hd (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))) (shen.hdtl (shen.pair (hd (hd V661)) (shen.hdtl V661))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd Parse_shen.<pattern2>) (shen.pair (hd (shen.pair (tl (hd V661)) (shen.hdtl V661))) (cons cons (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ()))))) (fail))) (fail))) (fail))) (fail)) (if (= Result (fail)) (let Result (if (and (cons? (hd V661)) (cons? (hd (hd V661)))) (shen.snd-or-fail (if (and (cons? (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))) (= @v (hd (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))) (shen.hdtl (shen.pair (hd (hd V661)) (shen.hdtl V661))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd Parse_shen.<pattern2>) (shen.pair (hd (shen.pair (tl (hd V661)) (shen.hdtl V661))) (cons @v (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ()))))) (fail))) (fail))) (fail))) (fail)) (if (= Result (fail)) (let Result (if (and (cons? (hd V661)) (cons? (hd (hd V661)))) (shen.snd-or-fail (if (and (cons? (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))) (= @s (hd (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))))) (let Parse_shen.<pattern1> (shen.<pattern1> (shen.pair (tl (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))) (shen.hdtl (shen.pair (hd (hd V661)) (shen.hdtl V661))))) (if (not (= (fail) Parse_shen.<pattern1>)) (let Parse_shen.<pattern2> (shen.<pattern2> Parse_shen.<pattern1>) (if (not (= (fail) Parse_shen.<pattern2>)) (shen.pair (hd Parse_shen.<pattern2>) (shen.pair (hd (shen.pair (tl (hd V661)) (shen.hdtl V661))) (cons @s (cons (shen.hdtl Parse_shen.<pattern1>) (cons (shen.hdtl Parse_shen.<pattern2>) ()))))) (fail))) (fail))) (fail))) (fail)) (if (= Result (fail)) (let Result (if (and (cons? (hd V661)) (cons? (hd (hd V661)))) (shen.snd-or-fail (if (and (cons? (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))) (= vector (hd (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))))) (if (and (cons? (hd (shen.pair (tl (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))) (shen.hdtl (shen.pair (hd (hd V661)) (shen.hdtl V661)))))) (= 0 (hd (hd (shen.pair (tl (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))) (shen.hdtl (shen.pair (hd (hd V661)) (shen.hdtl V661)))))))) (shen.pair (hd (shen.pair (tl (hd (shen.pair (tl (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))) (shen.hdtl (shen.pair (hd (hd V661)) (shen.hdtl V661)))))) (shen.hdtl (shen.pair (tl (hd (shen.pair (hd (hd V661)) (shen.hdtl V661)))) (shen.hdtl (shen.pair (hd (hd V661)) (shen.hdtl V661))))))) (shen.pair (hd (shen.pair (tl (hd V661)) (shen.hdtl V661))) (cons vector (cons 0 ())))) (fail)) (fail))) (fail)) (if (= Result (fail)) (let Result (if (cons? (hd V661)) (let Parse_X (hd (hd V661)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V661)) (shen.hdtl V661))) (shen.constructor-error Parse_X)) (fail))) (fail)) (if (= Result (fail)) (let Result (let Parse_shen.<simple_pattern> (shen.<simple_pattern> V661) (if (not (= (fail) Parse_shen.<simple_pattern>)) (shen.pair (hd Parse_shen.<simple_pattern>) (shen.hdtl Parse_shen.<simple_pattern>)) (fail))) (if (= Result (fail)) (fail) Result)) Result)) Result)) Result)) Result)) Result)) Result)))

(defun shen.constructor-error (V662) (simple-error (shen.app V662 " is not a legitimate constructor
" shen.a)))

(defun shen.<simple_pattern> (V667) (let Result (if (cons? (hd V667)) (let Parse_X (hd (hd V667)) (if (= Parse_X _) (shen.pair (hd (shen.pair (tl (hd V667)) (shen.hdtl V667))) (gensym Parse_Y)) (fail))) (fail)) (if (= Result (fail)) (let Result (if (cons? (hd V667)) (let Parse_X (hd (hd V667)) (if (not (element? Parse_X (cons -> (cons <- ())))) (shen.pair (hd (shen.pair (tl (hd V667)) (shen.hdtl V667))) Parse_X) (fail))) (fail)) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<pattern1> (V672) (let Result (let Parse_shen.<pattern> (shen.<pattern> V672) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<pattern2> (V677) (let Result (let Parse_shen.<pattern> (shen.<pattern> V677) (if (not (= (fail) Parse_shen.<pattern>)) (shen.pair (hd Parse_shen.<pattern>) (shen.hdtl Parse_shen.<pattern>)) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<action> (V682) (let Result (if (cons? (hd V682)) (let Parse_X (hd (hd V682)) (shen.pair (hd (shen.pair (tl (hd V682)) (shen.hdtl V682))) Parse_X)) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<guard> (V687) (let Result (if (cons? (hd V687)) (let Parse_X (hd (hd V687)) (shen.pair (hd (shen.pair (tl (hd V687)) (shen.hdtl V687))) Parse_X)) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.compile_to_machine_code (V688 V689) (let Lambda+ (shen.compile_to_lambda+ V688 V689) (let KL (shen.compile_to_kl V688 Lambda+) (let Record (shen.record-source V688 KL) KL))))

(defun shen.record-source (V692 V693) (cond ((value shen.*installing-kl*) shen.skip) (true (put V692 shen.source V693 (value *property-vector*)))))

(defun shen.compile_to_lambda+ (V694 V695) (let Arity (shen.aritycheck V694 V695) (let Free (map (lambda Rule (shen.free_variable_check V694 Rule)) V695) (let Variables (shen.parameters Arity) (let Strip (map shen.strip-protect V695) (let Abstractions (map shen.abstract_rule Strip) (let Applications (map (lambda X (shen.application_build Variables X)) Abstractions) (cons Variables (cons Applications ())))))))))

(defun shen.free_variable_check (V696 V697) (cond ((and (cons? V697) (and (cons? (tl V697)) (= () (tl (tl V697))))) (let Bound (shen.extract_vars (hd V697)) (let Free (shen.extract_free_vars Bound (hd (tl V697))) (shen.free_variable_warnings V696 Free)))) (true (shen.sys-error shen.free_variable_check))))

(defun shen.extract_vars (V698) (cond ((variable? V698) (cons V698 ())) ((cons? V698) (union (shen.extract_vars (hd V698)) (shen.extract_vars (tl V698)))) (true ())))

(defun shen.extract_free_vars (V708 V709) (cond ((and (cons? V709) (and (cons? (tl V709)) (and (= () (tl (tl V709))) (= (hd V709) protect)))) ()) ((and (variable? V709) (not (element? V709 V708))) (cons V709 ())) ((and (cons? V709) (and (= lambda (hd V709)) (and (cons? (tl V709)) (and (cons? (tl (tl V709))) (= () (tl (tl (tl V709)))))))) (shen.extract_free_vars (cons (hd (tl V709)) V708) (hd (tl (tl V709))))) ((and (cons? V709) (and (= let (hd V709)) (and (cons? (tl V709)) (and (cons? (tl (tl V709))) (and (cons? (tl (tl (tl V709)))) (= () (tl (tl (tl (tl V709)))))))))) (union (shen.extract_free_vars V708 (hd (tl (tl V709)))) (shen.extract_free_vars (cons (hd (tl V709)) V708) (hd (tl (tl (tl V709))))))) ((cons? V709) (union (shen.extract_free_vars V708 (hd V709)) (shen.extract_free_vars V708 (tl V709)))) (true ())))

(defun shen.free_variable_warnings (V712 V713) (cond ((= () V713) _) (true (simple-error (cn "error: the following variables are free in " (shen.app V712 (cn ": " (shen.app (shen.list_variables V713) "" shen.a)) shen.a))))))

(defun shen.list_variables (V714) (cond ((and (cons? V714) (= () (tl V714))) (cn (str (hd V714)) ".")) ((cons? V714) (cn (str (hd V714)) (cn ", " (shen.list_variables (tl V714))))) (true (shen.sys-error shen.list_variables))))

(defun shen.strip-protect (V715) (cond ((and (cons? V715) (and (cons? (tl V715)) (and (= () (tl (tl V715))) (= (hd V715) protect)))) (hd (tl V715))) ((cons? V715) (cons (shen.strip-protect (hd V715)) (shen.strip-protect (tl V715)))) (true V715)))

(defun shen.linearise (V716) (cond ((and (cons? V716) (and (cons? (tl V716)) (= () (tl (tl V716))))) (shen.linearise_help (shen.flatten (hd V716)) (hd V716) (hd (tl V716)))) (true (shen.sys-error shen.linearise))))

(defun shen.flatten (V717) (cond ((= () V717) ()) ((cons? V717) (append (shen.flatten (hd V717)) (shen.flatten (tl V717)))) (true (cons V717 ()))))

(defun shen.linearise_help (V718 V719 V720) (cond ((= () V718) (cons V719 (cons V720 ()))) ((cons? V718) (if (and (variable? (hd V718)) (element? (hd V718) (tl V718))) (let Var (gensym (hd V718)) (let NewAction (cons where (cons (cons = (cons (hd V718) (cons Var ()))) (cons V720 ()))) (let NewPatts (shen.linearise_X (hd V718) Var V719) (shen.linearise_help (tl V718) NewPatts NewAction)))) (shen.linearise_help (tl V718) V719 V720))) (true (shen.sys-error shen.linearise_help))))

(defun shen.linearise_X (V729 V730 V731) (cond ((= V731 V729) V730) ((cons? V731) (let L (shen.linearise_X V729 V730 (hd V731)) (if (= L (hd V731)) (cons (hd V731) (shen.linearise_X V729 V730 (tl V731))) (cons L (tl V731))))) (true V731)))

(defun shen.aritycheck (V733 V734) (cond ((and (cons? V734) (and (cons? (hd V734)) (and (cons? (tl (hd V734))) (and (= () (tl (tl (hd V734)))) (= () (tl V734)))))) (do (shen.aritycheck-action (hd (tl (hd V734)))) (shen.aritycheck-name V733 (arity V733) (length (hd (hd V734)))))) ((and (cons? V734) (and (cons? (hd V734)) (and (cons? (tl (hd V734))) (and (= () (tl (tl (hd V734)))) (and (cons? (tl V734)) (and (cons? (hd (tl V734))) (and (cons? (tl (hd (tl V734)))) (= () (tl (tl (hd (tl V734)))))))))))) (if (= (length (hd (hd V734))) (length (hd (hd (tl V734))))) (do (shen.aritycheck-action (hd (tl (hd V734)))) (shen.aritycheck V733 (tl V734))) (simple-error (cn "arity error in " (shen.app V733 "
" shen.a))))) (true (shen.sys-error shen.aritycheck))))

(defun shen.aritycheck-name (V743 V744 V745) (cond ((= -1 V744) V745) ((= V745 V744) V745) (true (do (shen.prhush (cn "
warning: changing the arity of " (shen.app V743 " can cause errors.
" shen.a)) (stoutput)) V745))))

(defun shen.aritycheck-action (V751) (cond ((cons? V751) (do (shen.aah (hd V751) (tl V751)) (map shen.aritycheck-action V751))) (true shen.skip)))

(defun shen.aah (V752 V753) (let Arity (arity V752) (let Len (length V753) (if (and (> Arity -1) (> Len Arity)) (shen.prhush (cn "warning: " (shen.app V752 (cn " might not like " (shen.app Len (cn " argument" (shen.app (if (> Len 1) "s" "") ".
" shen.a)) shen.a)) shen.a)) (stoutput)) shen.skip))))

(defun shen.abstract_rule (V754) (cond ((and (cons? V754) (and (cons? (tl V754)) (= () (tl (tl V754))))) (shen.abstraction_build (hd V754) (hd (tl V754)))) (true (shen.sys-error shen.abstract_rule))))

(defun shen.abstraction_build (V755 V756) (cond ((= () V755) V756) ((cons? V755) (cons /. (cons (hd V755) (cons (shen.abstraction_build (tl V755) V756) ())))) (true (shen.sys-error shen.abstraction_build))))

(defun shen.parameters (V757) (cond ((= 0 V757) ()) (true (cons (gensym V) (shen.parameters (- V757 1))))))

(defun shen.application_build (V758 V759) (cond ((= () V758) V759) ((cons? V758) (shen.application_build (tl V758) (cons V759 (cons (hd V758) ())))) (true (shen.sys-error shen.application_build))))

(defun shen.compile_to_kl (V760 V761) (cond ((and (cons? V761) (and (cons? (tl V761)) (= () (tl (tl V761))))) (let Arity (shen.store-arity V760 (length (hd V761))) (let Reduce (map shen.reduce (hd (tl V761))) (let CondExpression (shen.cond-expression V760 (hd V761) Reduce) (let TypeTable (if (value shen.*optimise*) (shen.typextable (shen.get-type V760) (hd V761)) shen.skip) (let TypedCondExpression (if (value shen.*optimise*) (shen.assign-types (hd V761) TypeTable CondExpression) CondExpression) (let KL (cons defun (cons V760 (cons (hd V761) (cons TypedCondExpression ())))) KL))))))) (true (shen.sys-error shen.compile_to_kl))))

(defun shen.get-type (V766) (cond ((cons? V766) shen.skip) (true (let FType (assoc V766 (value shen.*signedfuncs*)) (if (empty? FType) shen.skip (tl FType))))))

(defun shen.typextable (V775 V776) (cond ((and (cons? V775) (and (cons? (tl V775)) (and (= --> (hd (tl V775))) (and (cons? (tl (tl V775))) (and (= () (tl (tl (tl V775)))) (cons? V776)))))) (if (variable? (hd V775)) (shen.typextable (hd (tl (tl V775))) (tl V776)) (cons (cons (hd V776) (hd V775)) (shen.typextable (hd (tl (tl V775))) (tl V776))))) (true ())))

(defun shen.assign-types (V777 V778 V779) (cond ((and (cons? V779) (and (= let (hd V779)) (and (cons? (tl V779)) (and (cons? (tl (tl V779))) (and (cons? (tl (tl (tl V779)))) (= () (tl (tl (tl (tl V779)))))))))) (cons let (cons (hd (tl V779)) (cons (shen.assign-types V777 V778 (hd (tl (tl V779)))) (cons (shen.assign-types (cons (hd (tl V779)) V777) V778 (hd (tl (tl (tl V779))))) ()))))) ((and (cons? V779) (and (= lambda (hd V779)) (and (cons? (tl V779)) (and (cons? (tl (tl V779))) (= () (tl (tl (tl V779)))))))) (cons lambda (cons (hd (tl V779)) (cons (shen.assign-types (cons (hd (tl V779)) V777) V778 (hd (tl (tl V779)))) ())))) ((and (cons? V779) (= cond (hd V779))) (cons cond (map (lambda Y (cons (shen.assign-types V777 V778 (hd Y)) (cons (shen.assign-types V777 V778 (hd (tl Y))) ()))) (tl V779)))) ((cons? V779) (let NewTable (shen.typextable (shen.get-type (hd V779)) (tl V779)) (cons (hd V779) (map (lambda Y (shen.assign-types V777 (append V778 NewTable) Y)) (tl V779))))) (true (let AtomType (assoc V779 V778) (if (cons? AtomType) (cons type (cons V779 (cons (tl AtomType) ()))) (if (element? V779 V777) V779 (shen.atom-type V779)))))))

(defun shen.atom-type (V780) (if (string? V780) (cons type (cons V780 (cons string ()))) (if (number? V780) (cons type (cons V780 (cons number ()))) (if (boolean? V780) (cons type (cons V780 (cons boolean ()))) (if (symbol? V780) (cons type (cons V780 (cons symbol ()))) V780)))))

(defun shen.store-arity (V783 V784) (cond ((value shen.*installing-kl*) shen.skip) (true (put V783 arity V784 (value *property-vector*)))))

(defun shen.reduce (V785) (do (set shen.*teststack* ()) (let Result (shen.reduce_help V785) (cons (cons : (cons shen.tests (reverse (value shen.*teststack*)))) (cons Result ())))))

(defun shen.reduce_help (V786) (cond ((and (cons? V786) (and (cons? (hd V786)) (and (= /. (hd (hd V786))) (and (cons? (tl (hd V786))) (and (cons? (hd (tl (hd V786)))) (and (= cons (hd (hd (tl (hd V786))))) (and (cons? (tl (hd (tl (hd V786))))) (and (cons? (tl (tl (hd (tl (hd V786)))))) (and (= () (tl (tl (tl (hd (tl (hd V786))))))) (and (cons? (tl (tl (hd V786)))) (and (= () (tl (tl (tl (hd V786))))) (and (cons? (tl V786)) (= () (tl (tl V786))))))))))))))) (do (shen.add_test (cons cons? (tl V786))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V786))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V786)))))) (cons (shen.ebr (hd (tl V786)) (hd (tl (hd V786))) (hd (tl (tl (hd V786))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hd (tl V786)) ())) (cons (cons tl (tl V786)) ())) (shen.reduce_help Application))))) ((and (cons? V786) (and (cons? (hd V786)) (and (= /. (hd (hd V786))) (and (cons? (tl (hd V786))) (and (cons? (hd (tl (hd V786)))) (and (= @p (hd (hd (tl (hd V786))))) (and (cons? (tl (hd (tl (hd V786))))) (and (cons? (tl (tl (hd (tl (hd V786)))))) (and (= () (tl (tl (tl (hd (tl (hd V786))))))) (and (cons? (tl (tl (hd V786)))) (and (= () (tl (tl (tl (hd V786))))) (and (cons? (tl V786)) (= () (tl (tl V786))))))))))))))) (do (shen.add_test (cons tuple? (tl V786))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V786))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V786)))))) (cons (shen.ebr (hd (tl V786)) (hd (tl (hd V786))) (hd (tl (tl (hd V786))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons fst (tl V786)) ())) (cons (cons snd (tl V786)) ())) (shen.reduce_help Application))))) ((and (cons? V786) (and (cons? (hd V786)) (and (= /. (hd (hd V786))) (and (cons? (tl (hd V786))) (and (cons? (hd (tl (hd V786)))) (and (= @v (hd (hd (tl (hd V786))))) (and (cons? (tl (hd (tl (hd V786))))) (and (cons? (tl (tl (hd (tl (hd V786)))))) (and (= () (tl (tl (tl (hd (tl (hd V786))))))) (and (cons? (tl (tl (hd V786)))) (and (= () (tl (tl (tl (hd V786))))) (and (cons? (tl V786)) (= () (tl (tl V786))))))))))))))) (do (shen.add_test (cons shen.+vector? (tl V786))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V786))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V786)))))) (cons (shen.ebr (hd (tl V786)) (hd (tl (hd V786))) (hd (tl (tl (hd V786))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons hdv (tl V786)) ())) (cons (cons tlv (tl V786)) ())) (shen.reduce_help Application))))) ((and (cons? V786) (and (cons? (hd V786)) (and (= /. (hd (hd V786))) (and (cons? (tl (hd V786))) (and (cons? (hd (tl (hd V786)))) (and (= @s (hd (hd (tl (hd V786))))) (and (cons? (tl (hd (tl (hd V786))))) (and (cons? (tl (tl (hd (tl (hd V786)))))) (and (= () (tl (tl (tl (hd (tl (hd V786))))))) (and (cons? (tl (tl (hd V786)))) (and (= () (tl (tl (tl (hd V786))))) (and (cons? (tl V786)) (= () (tl (tl V786))))))))))))))) (do (shen.add_test (cons shen.+string? (tl V786))) (let Abstraction (cons /. (cons (hd (tl (hd (tl (hd V786))))) (cons (cons /. (cons (hd (tl (tl (hd (tl (hd V786)))))) (cons (shen.ebr (hd (tl V786)) (hd (tl (hd V786))) (hd (tl (tl (hd V786))))) ()))) ()))) (let Application (cons (cons Abstraction (cons (cons pos (cons (hd (tl V786)) (cons 0 ()))) ())) (cons (cons tlstr (tl V786)) ())) (shen.reduce_help Application))))) ((and (cons? V786) (and (cons? (hd V786)) (and (= /. (hd (hd V786))) (and (cons? (tl (hd V786))) (and (cons? (tl (tl (hd V786)))) (and (= () (tl (tl (tl (hd V786))))) (and (cons? (tl V786)) (and (= () (tl (tl V786))) (not (variable? (hd (tl (hd V786))))))))))))) (do (shen.add_test (cons = (cons (hd (tl (hd V786))) (tl V786)))) (shen.reduce_help (hd (tl (tl (hd V786))))))) ((and (cons? V786) (and (cons? (hd V786)) (and (= /. (hd (hd V786))) (and (cons? (tl (hd V786))) (and (cons? (tl (tl (hd V786)))) (and (= () (tl (tl (tl (hd V786))))) (and (cons? (tl V786)) (= () (tl (tl V786)))))))))) (shen.reduce_help (shen.ebr (hd (tl V786)) (hd (tl (hd V786))) (hd (tl (tl (hd V786))))))) ((and (cons? V786) (and (= where (hd V786)) (and (cons? (tl V786)) (and (cons? (tl (tl V786))) (= () (tl (tl (tl V786)))))))) (do (shen.add_test (hd (tl V786))) (shen.reduce_help (hd (tl (tl V786)))))) ((and (cons? V786) (and (cons? (tl V786)) (= () (tl (tl V786))))) (let Z (shen.reduce_help (hd V786)) (if (= (hd V786) Z) V786 (shen.reduce_help (cons Z (tl V786)))))) (true V786)))

(defun shen.+string? (V787) (cond ((= "" V787) false) (true (string? V787))))

(defun shen.+vector (V788) (cond ((= V788 (vector 0)) false) (true (vector? V788))))

(defun shen.ebr (V797 V798 V799) (cond ((= V799 V798) V797) ((and (cons? V799) (and (= /. (hd V799)) (and (cons? (tl V799)) (and (cons? (tl (tl V799))) (and (= () (tl (tl (tl V799)))) (> (occurrences V798 (hd (tl V799))) 0)))))) V799) ((and (cons? V799) (and (= let (hd V799)) (and (cons? (tl V799)) (and (cons? (tl (tl V799))) (and (cons? (tl (tl (tl V799)))) (and (= () (tl (tl (tl (tl V799))))) (= (hd (tl V799)) V798))))))) (cons let (cons (hd (tl V799)) (cons (shen.ebr V797 (hd (tl V799)) (hd (tl (tl V799)))) (tl (tl (tl V799))))))) ((cons? V799) (cons (shen.ebr V797 V798 (hd V799)) (shen.ebr V797 V798 (tl V799)))) (true V799)))

(defun shen.add_test (V802) (set shen.*teststack* (cons V802 (value shen.*teststack*))))

(defun shen.cond-expression (V803 V804 V805) (let Err (shen.err-condition V803) (let Cases (shen.case-form V805 Err) (let EncodeChoices (shen.encode-choices Cases V803) (shen.cond-form EncodeChoices)))))

(defun shen.cond-form (V808) (cond ((and (cons? V808) (and (cons? (hd V808)) (and (= true (hd (hd V808))) (and (cons? (tl (hd V808))) (= () (tl (tl (hd V808)))))))) (hd (tl (hd V808)))) (true (cons cond V808))))

(defun shen.encode-choices (V811 V812) (cond ((= () V811) ()) ((and (cons? V811) (and (cons? (hd V811)) (and (= true (hd (hd V811))) (and (cons? (tl (hd V811))) (and (cons? (hd (tl (hd V811)))) (and (= shen.choicepoint! (hd (hd (tl (hd V811))))) (and (cons? (tl (hd (tl (hd V811))))) (and (= () (tl (tl (hd (tl (hd V811)))))) (and (= () (tl (tl (hd V811)))) (= () (tl V811))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V811))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (if (value shen.*installing-kl*) (cons shen.sys-error (cons V812 ())) (cons shen.f_error (cons V812 ()))) (cons Result ())))) ())))) ())) ())) ((and (cons? V811) (and (cons? (hd V811)) (and (= true (hd (hd V811))) (and (cons? (tl (hd V811))) (and (cons? (hd (tl (hd V811)))) (and (= shen.choicepoint! (hd (hd (tl (hd V811))))) (and (cons? (tl (hd (tl (hd V811))))) (and (= () (tl (tl (hd (tl (hd V811)))))) (= () (tl (tl (hd V811)))))))))))) (cons (cons true (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V811))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (shen.cond-form (shen.encode-choices (tl V811) V812)) (cons Result ())))) ())))) ())) ())) ((and (cons? V811) (and (cons? (hd V811)) (and (cons? (tl (hd V811))) (and (cons? (hd (tl (hd V811)))) (and (= shen.choicepoint! (hd (hd (tl (hd V811))))) (and (cons? (tl (hd (tl (hd V811))))) (and (= () (tl (tl (hd (tl (hd V811)))))) (= () (tl (tl (hd V811))))))))))) (cons (cons true (cons (cons let (cons Freeze (cons (cons freeze (cons (shen.cond-form (shen.encode-choices (tl V811) V812)) ())) (cons (cons if (cons (hd (hd V811)) (cons (cons let (cons Result (cons (hd (tl (hd (tl (hd V811))))) (cons (cons if (cons (cons = (cons Result (cons (cons fail ()) ()))) (cons (cons thaw (cons Freeze ())) (cons Result ())))) ())))) (cons (cons thaw (cons Freeze ())) ())))) ())))) ())) ())) ((and (cons? V811) (and (cons? (hd V811)) (and (cons? (tl (hd V811))) (= () (tl (tl (hd V811))))))) (cons (hd V811) (shen.encode-choices (tl V811) V812))) (true (shen.sys-error shen.encode-choices))))

(defun shen.case-form (V817 V818) (cond ((= () V817) (cons V818 ())) ((and (cons? V817) (and (cons? (hd V817)) (and (cons? (hd (hd V817))) (and (= : (hd (hd (hd V817)))) (and (cons? (tl (hd (hd V817)))) (and (= shen.tests (hd (tl (hd (hd V817))))) (and (= () (tl (tl (hd (hd V817))))) (and (cons? (tl (hd V817))) (and (cons? (hd (tl (hd V817)))) (and (= shen.choicepoint! (hd (hd (tl (hd V817))))) (and (cons? (tl (hd (tl (hd V817))))) (and (= () (tl (tl (hd (tl (hd V817)))))) (= () (tl (tl (hd V817)))))))))))))))) (cons (cons true (tl (hd V817))) (shen.case-form (tl V817) V818))) ((and (cons? V817) (and (cons? (hd V817)) (and (cons? (hd (hd V817))) (and (= : (hd (hd (hd V817)))) (and (cons? (tl (hd (hd V817)))) (and (= shen.tests (hd (tl (hd (hd V817))))) (and (= () (tl (tl (hd (hd V817))))) (and (cons? (tl (hd V817))) (= () (tl (tl (hd V817)))))))))))) (cons (cons true (tl (hd V817))) ())) ((and (cons? V817) (and (cons? (hd V817)) (and (cons? (hd (hd V817))) (and (= : (hd (hd (hd V817)))) (and (cons? (tl (hd (hd V817)))) (and (= shen.tests (hd (tl (hd (hd V817))))) (and (cons? (tl (hd V817))) (= () (tl (tl (hd V817))))))))))) (cons (cons (shen.embed-and (tl (tl (hd (hd V817))))) (tl (hd V817))) (shen.case-form (tl V817) V818))) (true (shen.sys-error shen.case-form))))

(defun shen.embed-and (V819) (cond ((and (cons? V819) (= () (tl V819))) (hd V819)) ((cons? V819) (cons and (cons (hd V819) (cons (shen.embed-and (tl V819)) ())))) (true (shen.sys-error shen.embed-and))))

(defun shen.err-condition (V820) (cons true (cons (cons shen.f_error (cons V820 ())) ())))

(defun shen.sys-error (V821) (simple-error (cn "system function " (shen.app V821 ": unexpected argument
" shen.a))))



